<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raymond Demitrio Tel | TEL & Gently Overdone</title>
    <meta name="description" content="Raymond Demitrio Tel - Producer & Creative Director bei TEL & Gently Overdone">
    <meta name="author" content="Raymond Demitrio Tel">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --text: #1f2937;
            --text-light: #6b7280;
            --bg: #ffffff;
            --bg-light: #f9fafb;
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: var(--text);
        }

        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand h1 {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .nav-brand p {
            font-size: 0.875rem;
            opacity: 0.9;
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background 0.2s;
        }

        .nav-link:hover, .nav-link.active {
            background: rgba(255,255,255,0.1);
        }

        .language-selector select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
        }

        .language-selector select option {
            background: var(--bg);
            color: var(--text);
        }

        .main {
            min-height: calc(100vh - 200px);
        }

        .section {
            padding: 4rem 2rem;
            display: block;
        }

        .home-section {
            background: var(--bg-light);
            text-align: center;
        }

        .home-hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .home-hero p {
            font-size: 1.5rem;
            margin-bottom: 3rem;
            color: var(--text-light);
        }

        .home-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1000px;
            margin: 0 auto;
        }

        .feature-card {
            background: var(--bg);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow);
        }

        .feature-card h3 {
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .cms-section {
            background: var(--bg-light);
            text-align: center;
        }

        .cms-hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .cms-hero p {
            font-size: 1.5rem;
            margin-bottom: 3rem;
            color: var(--text-light);
        }

        .cms-editor {
            max-width: 1100px;
            margin: 0 auto;
            background: var(--bg);
            border-radius: 1rem;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .editor-toolbar {
            background: var(--primary);
            padding: 1rem;
            display: flex;
            gap: 1rem;
            justify-content: space-between;
            flex-wrap: wrap;
            align-items: center;
        }

        .tool-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 1rem;
        }

        .tool-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .tool-btn.export-btn {
            background: var(--success);
            margin-left: auto;
        }

        .editor-workspace {
            padding: 1rem;
            min-height: 400px;
        }

        #wysiwyg {
            width: 100%;
            min-height: 500px;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.6;
        }

        .about-hero {
            background: linear-gradient(135deg, var(--bg-light), #f3f4f6);
            padding: 4rem 2rem;
        }

        .about-hero-content {
            max-width: 1000px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 3rem;
            align-items: center;
        }

        .profile-image {
            text-align: center;
        }

        .profile-placeholder {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            margin: 0 auto;
            color: white;
        }

        .profile-info h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .profile-info h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--text-light);
        }

        .company-name {
            font-size: 1.25rem;
            color: var(--primary);
            font-weight: 600;
            margin-bottom: 1.5rem;
        }

        .contact-info p {
            margin-bottom: 0.5rem;
        }

        .contact-info a {
            color: var(--primary);
        }

        .about-content {
            padding: 4rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .about-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
        }

        .about-section {
            background: var(--bg);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow);
        }

        .about-section h3 {
            margin-bottom: 1rem;
        }

        .spotify-section, .youtube-section {
            padding: 4rem 2rem;
            background: var(--bg-light);
            text-align: center;
        }

        .spotify-section h3, .youtube-section h3 {
            margin-bottom: 1rem;
            font-size: 2.5rem;
        }

        .spotify-section p, .youtube-section p {
            margin-bottom: 2rem;
            font-size: 1.125rem;
        }

        .spotify-embed, .youtube-embed {
            margin-top: 2rem;
        }

        .philosophy-section {
            padding: 4rem 2rem;
            background: var(--bg-light);
            max-width: 1200px;
            margin: 0 auto;
        }

        .philosophy-content {
            text-align: center;
        }

        .philosophy-content blockquote {
            font-size: 1.5rem;
            font-style: italic;
            margin-bottom: 2rem;
            padding: 2rem;
            background: var(--bg);
            border-radius: 1rem;
            box-shadow: var(--shadow);
        }

        .contact-section {
            padding: 4rem 2rem;
            background: var(--bg);
            text-align: center;
        }

        .contact-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            max-width: 800px;
            margin: 2rem auto 0;
        }

        .contact-method {
            background: var(--bg-light);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow);
        }

        .contact-method h4 {
            margin-bottom: 1rem;
        }

        .footer {
            background: var(--text);
            color: white;
            padding: 3rem 2rem 1rem;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .footer-section h4 {
            margin-bottom: 1rem;
        }

        .footer-section p, .footer-section ul li a {
            color: #d1d5db;
            margin-bottom: 0.5rem;
        }

        .footer-section ul {
            list-style: none;
        }

        .footer-section ul li {
            margin-bottom: 0.5rem;
        }

        .footer-section ul li a:hover {
            color: white;
        }

        .footer-bottom {
            text-align: center;
            padding-top: 2rem;
            border-top: 1px solid #374151;
            color: #9ca3af;
        }

        /* Donation Button Styling */
        .donation-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            border: none;
            cursor: pointer;
        }

        .donation-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .donation-btn:active {
            transform: translateY(0);
        }

        .donation-btn .heart-icon {
            color: #ef4444;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .nav {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
            
            .nav-menu {
                flex-direction: column;
                gap: 1rem;
            }
            
            .about-hero-content {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .about-grid {
                grid-template-columns: 1fr;
            }
            
            .contact-methods {
                grid-template-columns: 1fr;
            }
        }

        /* KORRIGIERT: CMS-Fenster Scrolling + Werkzeugleiste */
        .cms-editor {
            overflow: visible !important;
            max-height: none !important;
        }
        
        .cms-editor .tox-tinymce {
            overflow: visible !important;
        }
        
        .cms-editor .tox-edit-area {
            overflow: visible !important;
        }
        
        .cms-editor .tox-edit-area__iframe {
            overflow: auto !important;
            min-height: 600px !important;
        }
        
        .cms-editor .tox-toolbar {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .cms-editor .tox-toolbar__group {
            display: flex !important;
        }
        
        /* File Management Styles */
        .filter-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .filter-btn:hover, .filter-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .upload-area:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .file-item {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .file-item:hover {
            border-color: var(--primary);
            box-shadow: var(--shadow);
            transform: translateY(-2px);
        }

        .file-item.selected {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .file-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .file-name {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        .file-size {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .file-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: none;
        }

        .file-item:hover .file-actions {
            display: block;
        }

        .file-action-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 0.25rem;
        }

        .file-action-btn:hover {
            background: var(--secondary);
        }

        .toolbar-left, .toolbar-center {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .toolbar-center {
            flex: 1;
            justify-content: center;
        }

        .presentation-mode {
            background: var(--bg-light);
            padding: 2rem;
            border-radius: 1rem;
        }

        .presentation-controls {
            background: var(--bg);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
        }

        .presentation-view {
            background: var(--bg);
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
            min-height: 400px;
            text-align: center;
            position: relative;
        }

        /* Drag and Drop Styles */
        .upload-area.dragover {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }

        /* File Type Specific Styles */
        .file-item[data-type="image"] .file-icon { color: #10b981; }
        .file-item[data-type="video"] .file-icon { color: #ef4444; }
        .file-item[data-type="audio"] .file-icon { color: #8b5cf6; }
        .file-item[data-type="document"] .file-icon { color: #3b82f6; }
        .file-item[data-type="presentation"] .file-icon { color: #f59e0b; }
        .file-item[data-type="archive"] .file-icon { color: #6b7280; }

        /* Mini-Styles f√ºr Mehrfachauswahl-Dialog */
        .modal{position:fixed;inset:0;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;z-index:10000;padding:2rem}
        .box{background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25);max-width:900px;width:100%;max-height:80vh;display:flex;flex-direction:column}
        .box h3{margin:1rem 1rem 0}
        .toolbar{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin:1rem;padding: .5rem;background:#f3f4f6;border-radius:8px}
        .toolbar button{border:0;padding:.6rem 1rem;border-radius:8px;background:#111827;color:#fff;cursor:pointer}
        .toolbar button:nth-child(1){background:#6366f1}
        .toolbar button:nth-child(2){background:#6b7280}
        .toolbar button:nth-child(3){background:#10b981}
        .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:.75rem;margin:0 1rem 1rem;overflow:auto;padding-bottom:1rem}
        .pick{display:flex;flex-direction:column;gap:.25rem;align-items:center;justify-content:center;padding:1rem;border:1px solid #e5e7eb;border-radius:10px}
        .pick input{margin-bottom:.25rem}
        .pick .icon{font-size:2rem}
        .file-chip{background:#eef2ff;border-left:4px solid #6366f1;padding:.75rem;border-radius:8px;margin:.5rem 0}

        /* Thumbnails im Grid */
        .file-item .thumb{
          width:100%;
          height:120px;
          object-fit:cover;
          border-radius:8px;
          margin-bottom:.5rem;
          background:#eef2ff;
        }
        
        /* KORRIGIERT: CMS-Container maximale Gr√∂√üe */
        .cms-editor {
          height: 100vh !important;
          max-height: none !important;
          overflow: auto !important;
          width: 100% !important;
        }
        
        .cms-editor .tox-tinymce {
          height: 100vh !important;
          max-height: none !important;
          width: 100% !important;
        }
        
        .cms-editor .tox-edit-area {
          height: 100vh !important;
          max-height: none !important;
          width: 100% !important;
        }
        
        .cms-editor .tox-edit-area__iframe {
          height: 100vh !important;
          max-height: none !important;
          width: 100% !important;
          overflow: auto !important;
        }
        
        /* KORRIGIERT: Werkzeugleiste immer sichtbar */
        .tox-toolbar {
          display: flex !important;
          visibility: visible !important;
          opacity: 1 !important;
          position: relative !important;
        }
        
        .tox-toolbar__group {
          display: flex !important;
          visibility: visible !important;
          opacity: 1 !important;
        }
        
        /* NEU: Verbesserte Darstellung mehrerer Dateien im Editor */
        .cms-editor .tox-edit-area__iframe body {
          padding: 20px !important;
          line-height: 1.6 !important;
        }
        
        .cms-editor .tox-edit-area__iframe img,
        .cms-editor .tox-edit-area__iframe video,
        .cms-editor .tox-edit-area__iframe audio {
          transition: transform 0.2s ease-in-out !important;
        }
        
        .cms-editor .tox-edit-area__iframe img:hover,
        .cms-editor .tox-edit-area__iframe video:hover {
          transform: scale(1.02) !important;
          box-shadow: 0 4px 8px rgba(0,0,0,0.15) !important;
        }
        
        /* KORRIGIERT: Z-Index Probleme f√ºr "mehrere Fenster" beheben */
        .cms-editor {
          z-index: 1 !important;
          position: relative !important;
        }
        
        .cms-editor .tox-tinymce {
          z-index: 1 !important;
          position: relative !important;
        }
        
        .cms-editor .tox-edit-area {
          z-index: 1 !important;
          position: relative !important;
        }
        
        .cms-editor .tox-edit-area__iframe {
          z-index: 1 !important;
          position: relative !important;
        }
        
        /* Export-Bereich Z-Index korrigieren */
        .export-section {
          z-index: 1 !important;
          position: relative !important;
        }
        
        /* Modal Z-Index korrigieren */
        .modal {
          z-index: 1000 !important;
          position: fixed !important;
        }
        
        .modal .box {
          z-index: 1001 !important;
          position: relative !important;
        }
    </style>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="nav-brand">
                <h1>üéµ TEL & Gently Overdone</h1>
                <p>Ultimate Multimedia WYSIWYG CMS</p>
            </div>
            <div class="nav-menu">
                <a href="#home" class="nav-link" onclick="showSection('home')">Home</a>
                <a href="#cms" class="nav-link" onclick="showSection('cms')">CMS</a>
                <a href="#about" class="nav-link" onclick="showSection('about')">About</a>
                <div class="language-selector">
                    <select id="languageSelect" onchange="changeLanguage(this.value)">
                        <option value="en">üá∫üá∏ English</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="nl">üá≥üá± Nederlands</option>
                        <option value="fr">üá´üá∑ Fran√ßais</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
            </div>
        </nav>
    </header>

    <main class="main">
        <section id="home" class="section home-section">
            <div class="home-hero">
                <h1>üéµ Willkommen bei TEL & Gently Overdone</h1>
                <p>Ultimate Multimedia WYSIWYG CMS</p>
                <div class="home-features">
                    <div class="feature-card">
                        <h3>üé® Kreative Freiheit</h3>
                        <p>Erstelle und bearbeite Multimedia-Inhalte mit unserem intuitiven CMS</p>
                    </div>
                    <div class="feature-card">
                        <h3>üéµ Musik & Medien</h3>
                        <p>Entdecke die einzigartigen Kl√§nge von Raymond Demitrio Tel</p>
                    </div>
                    <div class="feature-card">
                        <h3>üåç Mehrsprachig</h3>
                        <p>Unterst√ºtzung f√ºr verschiedene Sprachen</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="cms" class="section cms-section">
            <div class="cms-hero">
                <h1>üñ•Ô∏è Ultimate Multimedia WYSIWYG CMS</h1>
                <p>Erstelle und bearbeite deine Multimedia-Inhalte mit vollst√§ndiger Dateiverwaltung</p>
                
                <!-- Browser Compatibility Notice -->
                <div id="browserNotice" style="display: block; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; text-align: center;">
                    <p style="margin: 0; color: #92400e;">
                        <strong>‚ö†Ô∏è Tracking Prevention aktiv:</strong> 
                        Dein Browser blockiert LocalStorage. Das CMS verwendet automatisch alternative Speichermethoden (SessionStorage, IndexedDB, RAM).
                        <button onclick="this.parentElement.parentElement.style.display='none';" style="background: #f59e0b; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-left: 0.5rem; cursor: pointer;">Verstanden</button>
                    </p>
                </div>
                
                <!-- File Management Panel -->
                <div class="file-management-panel" style="max-width: 1100px; margin: 0 auto 2rem; background: var(--bg); border-radius: 1rem; box-shadow: var(--shadow); overflow: hidden;">
                    <div class="panel-header" style="background: var(--secondary); padding: 1rem; color: white;">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                            üìÅ Dateiverwaltung & Medien
                        </h3>
                    </div>
                    
                    <div class="panel-content" style="padding: 1.5rem;">
                        <!-- File Upload Section -->
                        <div class="upload-section" style="margin-bottom: 2rem;">
                            <h4 style="margin-bottom: 1rem; color: var(--primary);">üì§ Dateien hochladen</h4>
                            <div class="upload-area" id="uploadArea" style="border: 2px dashed var(--border); border-radius: 0.5rem; padding: 2rem; text-align: center; background: var(--bg-light); cursor: pointer; transition: all 0.3s;">
                                <div class="upload-icon" style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                                <p style="margin-bottom: 0.5rem; font-weight: 500;">Dateien hierher ziehen oder klicken zum Ausw√§hlen</p>
                                <p style="font-size: 0.9rem; color: var(--text-light);">Unterst√ºtzt: Bilder, Videos, Audio, Dokumente, Pr√§sentationen</p>
                                
                                <!-- NEU: Informationen √ºber flexible Upload-Gr√∂√üen -->
                                <div style="margin-top: 1rem; padding: 1rem; background: var(--bg); border-radius: 0.5rem; border: 1px solid var(--border);">
                                    <h5 style="margin: 0 0 0.5rem 0; color: var(--primary); font-size: 0.9rem;">üéØ Intelligente Gr√∂√üenanpassung</h5>
                                    <div style="font-size: 0.8rem; color: var(--text-light); line-height: 1.4;">
                                        <div>üì∑ <strong>Bilder:</strong> ‚â§1MB (100%), ‚â§5MB (60%), ‚â§10MB (50%), >10MB (40%)</div>
                                        <div>üé• <strong>Videos:</strong> ‚â§10MB (100%), ‚â§50MB (60%), ‚â§100MB (60%), >100MB (50%)</div>
                                        <div>üéµ <strong>Audio:</strong> ‚â§5MB (100%), ‚â§20MB (75%), >20MB (50%)</div>
                                        <div>üìÑ <strong>Dokumente:</strong> Max 50MB (100%)</div>
                                    </div>
                                </div>
                                
                                <input type="file" id="fileInput" multiple accept="*/*" style="display: none;">
                            </div>
                        </div>
                        
                        <!-- File Type Filters -->
                        <div class="file-filters" style="margin-bottom: 1.5rem;">
                            <h4 style="margin-bottom: 1rem; color: var(--primary);">üîç Dateitypen filtern</h4>
                            <div class="filter-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button class="filter-btn active" data-type="all" onclick="filterFiles('all')">Alle</button>
                                <button class="filter-btn" data-type="image" onclick="filterFiles('image')">üñºÔ∏è Bilder</button>
                                <button class="filter-btn" data-type="video" onclick="filterFiles('video')">üé• Videos</button>
                                <button class="filter-btn" data-type="audio" onclick="filterFiles('audio')">üéµ Audio</button>
                                <button class="filter-btn" data-type="document" onclick="filterFiles('document')">üìÑ Dokumente</button>
                                <button class="filter-btn" data-type="presentation" onclick="filterFiles('presentation')">üìä Pr√§sentationen</button>
                                <button class="filter-btn" data-type="archive" onclick="filterFiles('archive')">üì¶ Archive</button>
                            </div>
                        </div>
                        
                        <!-- Search and Bulk Operations -->
                        <div class="search-bulk-section" style="margin-bottom: 1.5rem;">
                            <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 200px;">
                                    <input type="text" id="fileSearch" placeholder="üîç Dateien durchsuchen..." 
                                           style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem;" 
                                           oninput="searchFiles(this.value)">
                                </div>
                                <button class="tool-btn" onclick="selectAllFiles()" style="background: var(--primary); color: white;">üìã Alle ausw√§hlen</button>
                                <button class="tool-btn" onclick="clearSelection()" style="background: var(--text-light); color: white;">‚ùå Auswahl aufheben</button>
                                <button class="tool-btn" onclick="bulkDelete()" style="background: #ef4444; color: white;">üóëÔ∏è Ausgew√§hlte l√∂schen</button>
                                <button class="tool-btn" onclick="exportFileLibrary()" style="background: var(--success); color: white;">üì§ Bibliothek exportieren</button>
                                <button class="tool-btn" onclick="importFileLibrary()" style="background: var(--secondary); color: white;">üì• Bibliothek importieren</button>
                                <button class="tool-btn" onclick="showHelp()" style="background: var(--text-light); color: white;" title="Hilfe anzeigen">‚ùì Hilfe</button>
                            </div>
                        </div>
                        
                        <!-- Statistics Panel -->
                        <div class="stats-panel" style="margin-bottom: 1.5rem; background: var(--bg-light); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border);">
                            <h4 style="margin-bottom: 1rem; color: var(--primary);">üìä Statistiken</h4>
                            <div class="stats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem;">
                                <div class="stat-item" style="text-align: center; padding: 0.5rem; background: var(--bg); border-radius: 0.5rem;">
                                    <div style="font-size: 1.5rem; font-weight: 600; color: var(--primary);" id="totalFiles">0</div>
                                    <div style="font-size: 0.8rem; color: var(--text-light);">Gesamt</div>
                                </div>
                                <div class="stat-item" style="text-align: center; padding: 0.5rem; background: var(--bg); border-radius: 0.5rem;">
                                    <div style="font-size: 1.5rem; font-weight: 600; color: #10b981;" id="totalSize">0 B</div>
                                    <div style="font-size: 0.8rem; color: var(--text-light);">Speicher</div>
                                </div>
                                <div class="stat-item" style="text-align: center; padding: 0.5rem; background: var(--bg); border-radius: 0.5rem;">
                                    <div style="font-size: 1.5rem; font-weight: 600; color: #8b5cf6;" id="imageCount">0</div>
                                    <div style="font-size: 0.8rem; color: var(--text-light);">Bilder</div>
                                </div>
                                <div class="stat-item" style="text-align: center; padding: 0.5rem; background: var(--bg); border-radius: 0.5rem;">
                                    <div style="font-size: 1.5rem; font-weight: 600; color: #ef4444;" id="videoCount">0</div>
                                    <div style="font-size: 0.8rem; color: var(--text-light);">Videos</div>
                                </div>
                                <div class="stat-item" style="text-align: center; padding: 0.5rem; background: var(--bg); border-radius: 0.5rem;">
                                    <div style="font-size: 1.5rem; font-weight: 600; color: #f59e0b;" id="presentationCount">0</div>
                                    <div style="font-size: 0.8rem; color: var(--text-light);">Pr√§sentationen</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- File Library -->
                        <div class="file-library">
                            <h4 style="margin-bottom: 1rem; color: var(--primary);">üìö Medienbibliothek</h4>
                            <div class="file-grid" id="fileGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; max-height: 400px; overflow-y: auto; padding: 1rem; background: var(--bg-light); border-radius: 0.5rem;">
                                <div class="no-files" style="grid-column: 1 / -1; text-align: center; color: var(--text-light); padding: 2rem;">
                                    <div style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                                    <p>Keine Dateien vorhanden</p>
                                    <p style="font-size: 0.9rem;">Lade Dateien hoch, um zu beginnen</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Enhanced CMS Editor -->
                <div class="cms-editor">
                    <div class="editor-toolbar">
                        <div class="toolbar-left">
                            <h3 style="color: white; margin: 0;">üìù WYSIWYG Editor</h3>
                            <p style="color: rgba(255,255,255,0.8); margin: 0; font-size: 0.9rem;">Funktionsf√§hig und zuverl√§ssig</p>
                        </div>
                        <div class="toolbar-center">
                            <button class="tool-btn" onclick="insertMedia()">üìé Medien einf√ºgen</button>
                            <button class="tool-btn" onclick="createPresentation()">üìä Pr√§sentation erstellen</button>
                            <button class="tool-btn" onclick="saveEditorContent()">üíæ Speichern</button>
                            <button class="tool-btn" onclick="loadEditorContent()">üìÇ Laden</button>
                        </div>
                        <label style="color: white; margin-right: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                          <input type="checkbox" id="ckStaticExport" style="margin: 0;">
                          <span style="font-size: 0.9rem;">Static-Only</span>
                        </label>
                        <button class="tool-btn export-btn" onclick="exportWebsiteFinal()">‚¨áÔ∏é Exportieren (Gepatcht)</button>
                        <button class="tool-btn" onclick="exportWebsiteZIP()" style="background: var(--secondary);">üì¶ ZIP Export</button>
                        <button class="tool-btn" onclick="openPageView()" style="background: var(--success);">üëÅÔ∏è Page View</button>
                        <button class="tool-btn" onclick="openPageView({ staticOnly: true })" style="background: var(--warning); font-size: 0.8rem;">üëÅÔ∏è Page View (Static)</button>
                        <button class="tool-btn" onclick="openFullSiteView()" style="background: var(--primary);">üåê Full Site View</button>
                        <button class="tool-btn" onclick="debugMediaLibrary()" style="background: var(--text-light); font-size: 0.8rem;">üîç Debug</button>
                    </div>
                    <div class="editor-workspace">
                        <textarea id="wysiwyg"></textarea>
                    </div>
                </div>
                
                <!-- Presentation Mode -->
                <div class="presentation-mode" id="presentationMode" style="display: none; margin-top: 2rem;">
                    <div class="presentation-controls" style="background: var(--bg); padding: 1rem; border-radius: 0.5rem; box-shadow: var(--shadow); margin-bottom: 1rem;">
                        <h4 style="margin-bottom: 1rem; color: var(--primary);">üé¨ Pr√§sentationsmodus</h4>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
                            <button class="tool-btn" onclick="previousSlide()">‚èÆÔ∏è Vorherige</button>
                            <span id="slideCounter" style="font-weight: 500;">Folie 1 von 1</span>
                            <button class="tool-btn" onclick="nextSlide()">‚è≠Ô∏è N√§chste</button>
                            <button class="tool-btn" onclick="toggleTimer()" id="timerBtn">‚è±Ô∏è Timer starten</button>
                            <span id="presentationTimer" style="font-weight: 500; color: var(--primary);">00:00</span>
                            <button class="tool-btn" onclick="toggleNotes()" id="notesBtn">üìù Notizen</button>
                            <button class="tool-btn" onclick="exitPresentation()">‚ùå Beenden</button>
                        </div>
                    </div>
                    <div class="presentation-view" id="presentationView" style="background: var(--bg); padding: 2rem; border-radius: 0.5rem; box-shadow: var(--shadow); min-height: 400px; text-align: center; position: relative;">
                        <div id="slideContent" style="font-size: 1.5rem; line-height: 1.8;">
                            <h2>Willkommen zur Pr√§sentation</h2>
                            <p>Verwende den Editor, um Inhalte zu erstellen</p>
                        </div>
                        <div id="presentationNotes" style="display: none; position: absolute; bottom: 1rem; left: 1rem; right: 1rem; background: rgba(0,0,0,0.8); color: white; padding: 1rem; border-radius: 0.5rem; font-size: 0.9rem;">
                            <strong>üìù Notizen:</strong> <span id="notesContent">Keine Notizen verf√ºgbar</span>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 2rem; text-align: center; color: var(--text-light); font-size: 0.9rem;">
                    <p>üí° Tipp: Alle Dateitypen werden lokal verarbeitet - keine externen Uploads erforderlich!</p>
                </div>
            </div>
        </section>

        <section id="about" class="section about-hero">
            <div class="about-hero-content">
                <div class="profile-image">
                    <div class="profile-placeholder">üéµ</div>
                </div>
                <div class="profile-info">
                    <h1>Raymond Demitrio Tel</h1>
                    <h2>Producer & Creative Director</h2>
                    <p class="company-name">TEL & Gently Overdone</p>
                    <div class="contact-info">
                        <p>üìß <a href="mailto:gentlyoverdone@outlook.com">gentlyoverdone@outlook.com</a></p>
                        <p>üåê <a href="https://tel1.jouwweb.nl/-1" target="_blank">tel1.nl</a></p>
                        <p>üéµ <a href="https://open.spotify.com/playlist/7BXr0cyoKuJSH6NUdPkrQ4" target="_blank">Spotify Playlist</a></p>
                    </div>
                </div>
            </div>
        </section>

        <section class="about-content">
            <div class="about-grid">
                <div class="about-section">
                    <h3>üé® About the Artist</h3>
                    <p>"I'm an artist passionate about sharing my work and connecting with others who appreciate it. My art blends traditional and modern elements, using everything from software and digital content to visuals and music."</p>
                    <p>My work represents the voice of numbers and the first to tell, known in many languages, chosen well. We count, we speak, we go digital too, for ads and the future‚Äîperfect for you!</p>
                </div>

                <div class="about-section">
                    <h3>üéµ Musical Journey</h3>
                    <p>The music of Raymond Demitrio TEL ‚Äì with his project TEL & Gentlyoverdone ‚Äì has created a niche that combines futuristic soundscapes with classical rock influences, appealing to a growing underground audience.</p>
                    <p>The project began as a form of musical therapy and developed into a full-fledged creative enterprise.</p>
                </div>

                <div class="about-section">
                    <h3>üåç Vision & Mission</h3>
                    <p>When "success" is the goal, life often becomes a competition. When "self-expression" is the goal, life becomes a work of art.</p>
                    <p>We are the voice of numbers and the first to tell, known in many languages, chosen well.</p>
                </div>

                <div class="about-section">
                    <h3>üéØ TEL1.NL Brand</h3>
                    <p>TEL1.NL represents clarity, directness, and reach. Whether it's innovative communication solutions, smart digital products, or support for entrepreneurial parties, TEL1.NL provides a solid and scalable foundation.</p>
                    <p>The power of this name lies in its simplicity and versatility. "Tel E√©n" sounds like a starting signal, a measuring point, a new standard.</p>
                </div>
            </div>
        </section>

        <section class="spotify-section">
            <h3>üéµ Featured Music Collection</h3>
            <p>47 tracks, approximately 3 hours 45 minutes of original music</p>
            <div class="spotify-embed">
                <div style="max-width:900px;margin:auto">
                    <iframe
                        style="border-radius:12px;width:100%;height:min(80vh,720px)"
                        src="https://open.spotify.com/embed/playlist/7BXr0cyoKuJSH6NUdPkrQ4?utm_source=generator"
                        frameborder="0"
                        allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                        loading="lazy">
                    </iframe>
                </div>
            </div>
        </section>

        <section class="youtube-section">
            <h3>üì∫ YouTube Channel</h3>
            <p>Alle Uploads dieses Kanals als abspielbare Playlist</p>
            <div class="youtube-embed">
                <div style="max-width:900px;margin:auto">
                    <iframe
                      width="100%"
                      height="450"
                      src="https://www.youtube.com/embed/videoseries?list=UU9Vswyv2pHCN-bXd-egc8XQ"
                      title="YouTube video playlist"
                      frameborder="0"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                      referrerpolicy="strict-origin-when-cross-origin"
                      allowfullscreen>
                    </iframe>
                </div>
            </div>
        </section>

        <section class="philosophy-section">
            <h3>üí≠ Philosophical Approach</h3>
            <div class="philosophy-content">
                <blockquote>
                    "Waiting for communication is all that remains for so many. Things that exist ‚Äî both positive and negative ‚Äî indicate that humans prefer to take the best of everything, often without measure."
                </blockquote>
                <p>Consider social media: it's simultaneously a source of connection and division. People seek contact, recognition, understanding ‚Äî but often collide with walls of language, culture, or misunderstanding.</p>
            </div>
        </section>

        <section class="contact-section">
            <h3>üìû Get in Touch</h3>
            <p>Interested in collaboration, licensing, or just want to say hello?</p>
            <div class="contact-methods">
                <div class="contact-method">
                    <h4>üìß Email</h4>
                    <p><a href="mailto:gentlyoverdone@outlook.com">gentlyoverdone@outlook.com</a></p>
                </div>
                <div class="contact-method">
                    <h4>üåê Website</h4>
                    <p><a href="https://tel1.jouwweb.nl/-1" target="_blank">tel1.nl</a></p>
                </div>
                <div class="contact-method">
                    <h4>üéµ Music</h4>
                    <p><a href="https://open.spotify.com/artist/3skMNuv9SjTqTQcDbCDk2T/discography" target="_blank">Spotify Discography</a></p>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>TEL & Gently Overdone</h4>
                <p>Ultimate Multimedia WYSIWYG CMS</p>
                <p>Producer: Raymond Demitrio Tel</p>
            </div>
            <div class="footer-section">
                <h4>Contact</h4>
                <p>üìß gentlyoverdone@outlook.com</p>
                <p>üåê <a href="https://tel1.jouwweb.nl/-1" target="_blank">tel1.nl</a></p>
            </div>
            <div class="footer-section">
                <h4>Quick Links</h4>
                <ul>
                    <li><a href="#" onclick="showSection('home')">Home</a></li>
                    <li><a href="#" onclick="showSection('cms')">CMS Editor</a></li>
                    <li><a href="https://open.spotify.com/playlist/7BXr0cyoKuJSH6NUdPkrQ4" target="_blank">Spotify</a></li>
                </ul>
                <div style="margin-top: 1rem;">
                    <a href="https://www.gofundme.com/f/magnitudo?utm_campaign=unknown&utm_medium=referral&utm_source=widget" 
                       target="_blank" 
                       class="donation-btn">
                        <span class="heart-icon">‚ù§Ô∏è</span>
                        Magnitudo Musica Mundo
                    </a>
                </div>
            </div>
        </div>
        <div class="footer-bottom">
            <p>¬© 2025 TEL & Gently Overdone. All rights reserved.</p>
        </div>
    </footer>

    <!-- TinyMCE 100% funktionsf√§hige lokale Version -->
    <script src="https://unpkg.com/tinymce@6.8.3/tinymce.min.js" referrerpolicy="no-referrer"></script>
    
    <!-- JSZip f√ºr ZIP-Export/Import -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous"></script>

    <script>
        // =============================================================
        // TEL CMS ‚Äì Bereinigte Version (alle Fehler behoben)
        // Features: Fallback-Modus, Mehrfachauswahl, ZIP-Export/Import
        // Page-View Patches integriert f√ºr bessere Kompatibilit√§t
        // =============================================================

        // --- PATCHES START ---------------------------------------------------------
        // Utilities
        const enc = (s) => new TextEncoder().encode(s);
        const dec = (b) => new TextDecoder().decode(b);

        /**
         * buildPatchedExport(htmlString, options?)
         *  - Entfernt <base>, injiziert CSP & Force-Visible, normalisiert Lazy-Media,
         *    optional "Static-Only" (harter Fallback f√ºr strenge Viewer).
         */
        function buildPatchedExport(contentHTML, {
          title = "Export",
          staticOnly = false,
        } = {}) {
          // Sicherheitsnetz: DOM parsen
          const doc = new DOMParser().parseFromString(wrapAsHTML(contentHTML, title), "text/html");

          // 1) <base> entfernen (h√§ufige Ursache f√ºr leere Page-Views)
          doc.querySelectorAll("base").forEach(b => b.remove());

          // 2) CSP-Meta injizieren (erlaubt data:/blob: & inline styles)
          ensureCspMeta(doc);

          // 3) Force-Visible CSS im <head> ganz oben
          injectForceVisibleStyle(doc);

          // 4) Lazy-Media normalisieren (data-src/srcset -> echte src/srcset)
          normalizeLazyMedia(doc);

          // 5) Optional: Static-Only ‚Äì Theme-/Background-Fallbacks rendern
          if (staticOnly) {
            promoteBackgroundImagesToImgFallbacks(doc);
            stripAllScriptsStylesExceptPatches(doc);
          }

          // 6) Runtime-Notbremse (falls Viewer trotzdem was strippt)
          injectRuntimeBootstrap(doc);

          return "<!doctype html>\n" + doc.documentElement.outerHTML;
        }

        // Wrap Editor-Inhalt in ein minimales HTML-Skelett
        function wrapAsHTML(bodyHTML, title) {
          return `
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>${escapeHtml(title)}</title>
</head>
<body>
  ${bodyHTML}
</body>
</html>`;
        }

        function escapeHtml(s){return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]))}

            function ensureCspMeta(doc) {
      const have = doc.querySelector('meta[http-equiv="Content-Security-Policy"]');
      if (have) have.remove();

      const m = doc.createElement("meta");
      m.setAttribute("http-equiv", "Content-Security-Policy");

      // Basis: alles lokal/data/blob ‚Äì plus echte Freigaben f√ºr iframes (YouTube/Spotify) & Fonts
      const csp = [
        "default-src 'self' data: blob:",
        "img-src 'self' data: blob: https:",
        "media-src 'self' data: blob: https:",
        "style-src 'self' 'unsafe-inline' data:",
        "font-src 'self' data: https:",
        "script-src 'self' 'unsafe-inline' data: blob:",
        // WICHTIG: iframes/embeds
        "frame-src 'self' https://www.youtube.com https://open.spotify.com data: blob:",
        // Wer will, kann auch connect-src √∂ffnen (z.B. f√ºr eingebettete Player)
        "connect-src 'self' https://*.youtube.com https://*.googlevideo.com https://open.spotify.com https://*.scdn.co data:"
      ].join("; ");
      m.setAttribute("content", csp);

      doc.head.prepend(m);
    }

        function injectForceVisibleStyle(doc) {
          if (doc.getElementById("force-visible")) return;
          const style = doc.createElement("style");
          style.id = "force-visible";
          style.textContent = `
html,body{min-height:100%;opacity:1!important;visibility:visible!important}
body{display:block!important}
[hidden],template{display:none!important}
.mce-content-body,.mce-content-body *{opacity:1!important;visibility:visible!important}
*[data-hidden="true"]{display:none!important}
`;
          doc.head.prepend(style);
        }

        function normalizeLazyMedia(doc) {
          // data-src/srcset => src/srcset (img, iframe, source, video, audio)
          doc.querySelectorAll("[data-src]").forEach(el=>{
            if(!el.getAttribute("src")) el.setAttribute("src", el.getAttribute("data-src"));
          });
          doc.querySelectorAll("[data-srcset]").forEach(el=>{
            if(!el.getAttribute("srcset")) el.setAttribute("srcset", el.getAttribute("data-srcset"));
          });
          // <picture> sources
          doc.querySelectorAll("source[data-srcset]").forEach(s=>{
            if(!s.getAttribute("srcset")) s.setAttribute("srcset", s.getAttribute("data-srcset"));
          });
          // Videos: <source data-src> -> src
          doc.querySelectorAll("video source[data-src], audio source[data-src]").forEach(s=>{
            if(!s.getAttribute("src")) s.setAttribute("src", s.getAttribute("data-src"));
          });
          // Entferne Lazy-Trigger-Klassen/Attr, die Sichtbarkeit beeinflussen k√∂nnten
          doc.querySelectorAll("[data-lazy],[data-loaded]").forEach(n=>{
            n.removeAttribute("data-lazy"); n.removeAttribute("data-loaded");
          });
        }

        // Static-Only: macht aus CSS-Backgrounds <img>-Fallbacks
        function promoteBackgroundImagesToImgFallbacks(doc) {
          const candidates = [];
          doc.querySelectorAll("*").forEach(el=>{
            const s = el.getAttribute("style") || "";
            const m = /background(?:-image)?:[^;]*url\((['"]?)([^)'"?]+)\1\)[^;]*/i.exec(s);
            if (m) candidates.push({el, url:m[2]});
          });
          candidates.forEach(({el,url})=>{
            // wenn Element schon ein img enth√§lt, nichts tun
            const hasImgChild = el.querySelector(":scope > img.bg-fallback");
            if (hasImgChild) return;
            const img = doc.createElement("img");
            img.className = "bg-fallback";
            img.setAttribute("alt","");
            img.setAttribute("aria-hidden","true");
            img.setAttribute("src", url);
            // etwas generische Gr√∂√üe, sofern das Element eine H√∂he hat
            const rectH = el.getAttribute("data-h") || "";
            if (rectH) img.style.height = rectH + "px";
            img.style.maxWidth = "100%";
            img.style.display = "block";
            // ans Ende des Elements
            el.appendChild(img);
          });
          // Minimale Styles, falls Viewer Styles strippt
          const s = doc.createElement("style");
          s.textContent = `.bg-fallback{display:block;max-width:100%}`;
          doc.head.appendChild(s);
        }

        // Entfernt ALLE <script> und (fast) alle <style>, bel√§sst aber unsere Patches
        function stripAllScriptsStylesExceptPatches(doc){
          doc.querySelectorAll("script").forEach(s=>{
            if (!/__PAGEVIEW_BOOTSTRAP__/.test(s.textContent)) s.remove();
          });
          doc.querySelectorAll("style").forEach(st=>{
            if (st.id !== "force-visible") st.remove();
          });
          // Inline style-Attribute bleiben ‚Äì oft werden sie akzeptiert, wenn <style>-Bl√∂cke entfernt sind
        }

        function injectRuntimeBootstrap(doc){
          if (doc.getElementById("__PAGEVIEW_BOOTSTRAP__")) return;
          const sc = doc.createElement("script");
          sc.id = "__PAGEVIEW_BOOTSTRAP__";
          sc.textContent = String.raw`
(() => {
  try {
    // BASE kill (falls Exporter es nicht entfernt hat oder Viewer es injiziert)
    const b = document.querySelector('base'); if (b) b.remove();

    // Force-Visible fallback (falls <style> gestript)
    const need = !document.getElementById('force-visible');
    if (need) {
      const s = document.createElement('style');
      s.id = 'force-visible';
      s.textContent = 'html,body{min-height:100%;opacity:1!important;visibility:visible!important} body{display:block!important} [hidden],template{display:none!important}';
      (document.head||document.documentElement).prepend(s);
    }

    // Lazy-Media: data-* -> echte Attribute (nochmal zur Sicherheit)
    document.querySelectorAll('[data-src]').forEach(el=>{
      if(!el.getAttribute('src')) el.setAttribute('src', el.getAttribute('data-src'));
    });
    document.querySelectorAll('[data-srcset]').forEach(el=>{
      if(!el.getAttribute('srcset')) el.setAttribute('srcset', el.getAttribute('data-srcset'));
    });

    // Sichtbarkeits-Killer neutralisieren
    document.querySelectorAll('*').forEach(el=>{
      const cs = getComputedStyle(el);
      if (cs && (cs.visibility === 'hidden' || cs.opacity === '0')) {
        el.style.visibility = 'visible';
        if (parseFloat(cs.opacity) === 0) el.style.opacity = '1';
      }
    });
  } catch(e) { /* still show content */ }
})();
      `;
          (doc.body || doc.documentElement).appendChild(sc);
        }
        // --- PATCHES END -----------------------------------------------------------

        // --- MEDIA INLINING PATCHES START ------------------------------------------
        // Hilfen f√ºr Blob-zu-Data-URL Konvertierung
        async function blobToDataURL(blob){
          return await new Promise((res, rej)=>{
            const fr = new FileReader();
            fr.onload = () => res(fr.result);
            fr.onerror = rej;
            fr.readAsDataURL(blob);
          });
        }

        async function srcToDataUrl(src, el){
          try {
            // 1) Direkt vom blob: holen
            const r = await fetch(src);
            if (!r.ok) throw new Error('fetch failed');
            const b = await r.blob();
            return await blobToDataURL(b);
          } catch (e) {
            // 2) Fallback √ºber data-file-id ‚Üí fileLibrary
            const id = el?.getAttribute('data-file-id');
            if (id && window.fileLibrary && Array.isArray(window.fileLibrary)) {
              const item = window.fileLibrary.find(f => f.id === id || f.uuid === id);
              const f = item?.file || item?.blob || item; // je nach Struktur
              if (f instanceof Blob) return await blobToDataURL(f);
            }
            // 3) Fallback √ºber urlCache Map
            if (window.urlCache && window.urlCache instanceof Map) {
              for (const [key, objUrl] of window.urlCache.entries()) {
                if (objUrl === src) {
                  // Versuch: Key kann id sein
                  const maybe = window.fileLibrary?.find(f => f.id === key || f.uuid === key);
                  const fb = maybe?.file || maybe?.blob;
                  if (fb instanceof Blob) return await blobToDataURL(fb);
                }
              }
            }
            throw e;
          }
        }

        function extractUrlsFromCss(cssText){
          const urls = [];
          const re = /url\((['"]?)(.*?)\1\)/g;
          let m; 
          while((m = re.exec(cssText))){ urls.push(m[2]); }
          return urls;
        }

        function replaceUrlsInCss(cssText, replacements){
          return cssText.replace(/url\((['"]?)(.*?)\1\)/g, (all,q,u)=> {
            const newU = replacements.get(u) || u;
            return `url(${q||''}${newU}${q||''})`;
          });
        }

        // Hauptfunktion: alle Medien inline als data: URLs umschreiben
        async function inlineAllMediaToDataURLs(doc){
          const tasks = [];

          // IMG / VIDEO / AUDIO / SOURCE (src)
          doc.querySelectorAll('img[src], video[src], audio[src], source[src], iframe[src]')
            .forEach(el => {
              const src = el.getAttribute('src');
              if (src && src.startsWith('blob:')) {
                tasks.push((async()=>{
                  try {
                    const data = await srcToDataUrl(src, el);
                    el.setAttribute('src', data);
                    console.log('‚úÖ Blob zu Data-URL konvertiert:', src.substring(0, 30) + '...');
                  } catch (e) {
                    console.warn('‚ö†Ô∏è Konvertierung fehlgeschlagen f√ºr:', src, e);
                  }
                })());
              }
            });

          // Poster-Attribute bei <video>
          doc.querySelectorAll('video[poster]').forEach(el=>{
            const poster = el.getAttribute('poster');
            if (poster && poster.startsWith('blob:')) {
              tasks.push((async()=>{
                try {
                  const data = await srcToDataUrl(poster, el);
                  el.setAttribute('poster', data);
                  console.log('‚úÖ Poster Blob zu Data-URL konvertiert');
                } catch (e) {
                  console.warn('‚ö†Ô∏è Poster-Konvertierung fehlgeschlagen:', e);
                }
              })());
            }
          });

          // SRCSET (img/picture/source)
          doc.querySelectorAll('img[srcset], source[srcset]').forEach(el=>{
            const srcset = el.getAttribute('srcset');
            if (!srcset) return;
            const candidates = srcset.split(',').map(s=>s.trim());
            const replPromises = [];
            const replacements = new Map();

            candidates.forEach(c=>{
              const url = c.split(/\s+/)[0];
              if (url && url.startsWith('blob:')) {
                replPromises.push((async()=>{
                  try {
                    const data = await srcToDataUrl(url, el);
                    replacements.set(url, data);
                  } catch (e) {
                    console.warn('‚ö†Ô∏è Srcset-Konvertierung fehlgeschlagen:', e);
                  }
                })());
              }
            });

            if (replPromises.length) {
              tasks.push((async()=>{
                await Promise.all(replPromises);
                if (replacements.size){
                  const newSet = candidates.map(c=>{
                    const parts = c.split(/\s+/);
                    const u = parts[0];
                    if (replacements.has(u)) parts[0] = replacements.get(u);
                    return parts.join(' ');
                  }).join(', ');
                  el.setAttribute('srcset', newSet);
                  console.log('‚úÖ Srcset Blobs zu Data-URLs konvertiert');
                }
              })());
            }
          });

          // CSS inline styles mit background-image
          doc.querySelectorAll('[style]').forEach(el=>{
            const style = el.getAttribute('style');
            if (style && style.includes('url(')) {
              const urls = extractUrlsFromCss(style).filter(u=>u.startsWith('blob:'));
              if (urls.length){
                tasks.push((async()=>{
                  try {
                    const replacements = new Map();
                    for (const u of urls){
                      const data = await srcToDataUrl(u, el);
                      replacements.set(u, data);
                    }
                    el.setAttribute('style', replaceUrlsInCss(style, replacements));
                    console.log('‚úÖ CSS Background-URLs zu Data-URLs konvertiert');
                  } catch (e) {
                    console.warn('‚ö†Ô∏è CSS-URL-Konvertierung fehlgeschlagen:', e);
                  }
                })());
              }
            }
          });

          // <a href="blob:..."> zu data:
          doc.querySelectorAll('a[href^="blob:"]').forEach(a=>{
            const href = a.getAttribute('href');
            tasks.push((async()=>{
              try {
                const data = await srcToDataUrl(href, a);
                a.setAttribute('href', data);
                a.setAttribute('download', a.getAttribute('download') || 'file'); // sicherheitshalber
                console.log('‚úÖ Link Blob zu Data-URL konvertiert');
              } catch (e) {
                console.warn('‚ö†Ô∏è Link-Konvertierung fehlgeschlagen:', e);
              }
            })());
          });

          console.log(`üîÑ Konvertiere ${tasks.length} Blob-URLs zu Data-URLs...`);
          await Promise.all(tasks);
          console.log('‚úÖ Alle Medien erfolgreich inline konvertiert!');
        }
        // --- MEDIA INLINING PATCHES END --------------------------------------------

        // --- EDITOR CONTENT SAFETY PATCHES START -----------------------------------
        // Sichere Editor-Inhalt-Funktion - verhindert doppelte HTML/Body-Tags
        function getEditorInnerHtmlSafe() {
          const ed = tinymce.get('wysiwyg');
          if (!ed) return '';
          
          // Nur den "Inhalt" holen (inner HTML), NICHT outer
          let html = ed.getContent({ format: 'html' }) || '';

          // Falls doch ein komplettes Dokument reingekommen ist: auf Body-Inhalt reduzieren
          if (/<(html|head|body)(\s|>)/i.test(html)) {
            console.log('‚ö†Ô∏è Editor enth√§lt HTML/Body-Tags - reduziere auf Body-Inhalt');
            try {
              const tmp = new DOMParser().parseFromString(html, 'text/html');
              html = (tmp.body && tmp.body.innerHTML) ? tmp.body.innerHTML : html;
              console.log('‚úÖ HTML auf Body-Inhalt reduziert');
            } catch (e) {
              console.warn('‚ö†Ô∏è HTML-Parsing fehlgeschlagen, verwende Original:', e);
            }
          }
          
          return html;
        }
        // --- EDITOR CONTENT SAFETY PATCHES END -------------------------------------

        // Navigation - Alle Sections korrekt umschalten
        function showSection(sectionName) {
            // Alle Sections in main verstecken
            const allSections = Array.from(document.querySelectorAll('main > section'));
            allSections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Basis-Section zeigen
            const baseSection = document.getElementById(sectionName);
            if (baseSection) {
                baseSection.style.display = 'block';
            }
            
            // "About" soll die nachfolgenden Info-Abschnitte mit anzeigen
            if (sectionName === 'about') {
                const aboutSections = document.querySelectorAll('.about-content, .spotify-section, .youtube-section, .philosophy-section, .contact-section');
                aboutSections.forEach(section => {
                    section.style.display = 'block';
                });
            }
            
            // Aktiven Nav-Link setzen
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            const activeLink = document.querySelector(`[onclick="showSection('${sectionName}')"]`);
            if (activeLink) {
                activeLink.classList.add('active');
            }
        }

        // Language
        function changeLanguage(lang) {
            localStorage.setItem('preferredLanguage', lang);
            showNotification(`Sprache ge√§ndert zu ${lang === 'de' ? 'Deutsch' : lang === 'en' ? 'English' : lang === 'nl' ? 'Nederlands' : lang === 'fr' ? 'Fran√ßais' : 'Espa√±ol'}`, 'success');
        }

        // ------- Utilities -------
        function showNotification(message, type = 'info') {
            const color = type==='success' ? '#10b981' : type==='warning' ? '#f59e0b' : type==='error' ? '#ef4444' : '#3b82f6';
            const n = Object.assign(document.createElement('div'),{textContent:message});
            n.style.cssText = `position:fixed;top:20px;right:20px;padding:1rem 1.25rem;border-radius:10px;color:#fff;font-weight:600;z-index:100000;background:${color};box-shadow:0 10px 15px -3px rgba(0,0,0,.2);transform:translateX(120%);transition:transform .25s`;
            document.body.appendChild(n); requestAnimationFrame(()=>n.style.transform='translateX(0)');
            setTimeout(()=>{n.style.transform='translateX(120%)'; setTimeout(()=>n.remove(),250)}, 2800);
        }
        
        function formatFileSize(bytes){ if(bytes===0) return '0 Bytes'; const k=1024; const sizes=['Bytes','KB','MB','GB','TB']; const i=Math.floor(Math.log(bytes)/Math.log(k)); return (bytes/Math.pow(k,i)).toFixed(2)+' '+sizes[i]; }

        // ------- Typ-Erkennung -------
        const EXT_MAP = { image:['png','jpg','jpeg','gif','bmp','webp','svg','tiff','heic'], video:['mp4','webm','mov','mkv','avi','m4v'], audio:['mp3','wav','ogg','m4a','flac','aac','aiff','mid','midi'], presentation:['ppt','pptx','key','odp'], document:['pdf','doc','docx','odt','txt','rtf','md','csv','xls','xlsx'], archive:['zip','rar','7z','tar','gz','bz2'] };
        function getFileTypeByMimeOrExt(f){ const mime=(f.type||f.mime||'').toLowerCase(); const ext=(f.ext||(f.name||'').split('.').pop()||'').toLowerCase();
          if(mime.startsWith('image/')||EXT_MAP.image.includes(ext)) return 'image';
          if(mime.startsWith('video/')||EXT_MAP.video.includes(ext)) return 'video';
          if(mime.startsWith('audio/')||EXT_MAP.audio.includes(ext)) return 'audio';
          if(EXT_MAP.presentation.includes(ext)) return 'presentation';
          if(EXT_MAP.archive.includes(ext)) return 'archive';
          return 'document';
        }
        function getFileIcon(type){ return ({image:'üñºÔ∏è',video:'üé•',audio:'üéµ',document:'üìÑ',presentation:'üìä',archive:'üì¶'})[type]||'üìÑ'; }

        // ------- State -------
        let fileLibrary = []; // nur Metadaten im RAM
        let currentFilter = 'all';
        let urlCache = new Map(); // id -> objectURL
        let pickSelection = new Set();

        // Pr√§sentations-Globals
        let slides = [];
        let currentSlide = 0;
        let timerRunning = false;
        let presentationTimer = null;
        let timerStartTime = null;
        let notesVisible = false;

        // TinyMCE Editor Functions
        function getEditorHtml() {
            const editor = tinymce.get('wysiwyg');
            if (!editor) return '';
            
            // KORRIGIERT: Rohen HTML-Code mit allen Tags speichern
            return editor.getContent({
                format: 'html',           // HTML-Format erzwingen
                get_inner: false,         // Kompletten HTML-Code (nicht nur Body)
                get_outer: true,          // Alle Tags einschlie√ülich Wrapper
                no_events: true,          // Keine Event-Handler
                no_selection: true,       // Keine Selection-Markierungen
                preserve_caret_position: false, // Keine Caret-Position
                get_outer: true           // √Ñu√üere Tags behalten
            }) || '';
        }

        function setEditorHtml(html) {
            const editor = tinymce.get('wysiwyg');
            if (editor) {
                editor.setContent(html || '');
            }
        }

        // NEU: Globale getAvailableStorage Funktion
        function getAvailableStorage() {
            console.log('üîç Pr√ºfe verf√ºgbare Speichertypen...');
            
            try {
                // 1. Versuche LocalStorage (wenn Tracking Prevention es erlaubt)
                let testSize = 1024 * 1024; // Starte mit 1MB
                let maxSize = 0;
                
                while (testSize <= 2 * 1024 * 1024 * 1024) { // Max 2GB Test
                    try {
                        const testData = 'x'.repeat(testSize);
                        const testKey = `tel_quota_test_${Date.now()}`;
                        localStorage.setItem(testKey, testData);
                        localStorage.removeItem(testKey);
                        maxSize = testSize;
                        testSize *= 1.5;
                    } catch {
                        break;
                    }
                }
                
                if (maxSize > 0) {
                    // LocalStorage funktioniert
                    const availableSize = Math.floor(maxSize * 0.67);
                    console.log(`‚úÖ LocalStorage funktioniert: ${Math.round(maxSize / 1024 / 1024 / 1024 * 100) / 100}GB, Verf√ºgbar: ${Math.round(availableSize / 1024 / 1024 / 1024 * 100) / 100}GB`);
                    return { type: 'localStorage', size: availableSize };
                } else {
                    console.log('‚ùå LocalStorage blockiert durch Tracking Prevention');
                }
            } catch (error) {
                console.warn('‚ùå LocalStorage blockiert:', error);
            }
            
            // 2. Fallback: SessionStorage (weniger Speicher, aber funktioniert)
            try {
                let testSize = 1024 * 1024; // 1MB
                let maxSize = 0;
                
                while (testSize <= 100 * 1024 * 1024) { // Max 100MB
                    try {
                        const testData = 'x'.repeat(testSize);
                        const testKey = `tel_session_test_${Date.now()}`;
                        sessionStorage.setItem(testKey, testData);
                        sessionStorage.removeItem(testKey);
                        maxSize = testSize;
                        testSize *= 2;
                    } catch {
                        break;
                    }
                }
                
                if (maxSize > 0) {
                    const availableSize = Math.floor(maxSize * 0.67);
                    console.log(`üîÑ SessionStorage verf√ºgbar: ${Math.round(maxSize / 1024 / 1024 * 100) / 100}MB, Verf√ºgbar: ${Math.round(availableSize / 1024 / 1024 * 100) / 100}MB`);
                    return { type: 'sessionStorage', size: availableSize };
                } else {
                    console.log('‚ùå SessionStorage blockiert');
                }
            } catch (error) {
                console.warn('‚ùå SessionStorage blockiert:', error);
            }
            
            // 3. Fallback: IndexedDB (gr√∂√üter Speicher, aber komplexer)
            try {
                if ('indexedDB' in window) {
                    console.log('üîÑ IndexedDB verf√ºgbar - verwende 100MB Fallback');
                    return { type: 'indexedDB', size: 100 * 1024 * 1024 };
                } else {
                    console.log('‚ùå IndexedDB nicht verf√ºgbar');
                }
            } catch (error) {
                console.warn('‚ùå IndexedDB nicht verf√ºgbar:', error);
            }
            
            // 4. Letzter Fallback: RAM-Speicher (nur f√ºr aktuelle Session)
            console.log('‚ö†Ô∏è Alle Speicher blockiert - verwende RAM-Speicher (nur f√ºr aktuelle Session)');
            console.log('üí° Tipp: Deaktiviere Tracking Prevention in deinen Browser-Einstellungen f√ºr bessere Speicherkapazit√§t');
            return { type: 'ram', size: 50 * 1024 * 1024 }; // 50MB RAM
        }

        // NEU: Globale saveContentToStorage Funktion
        function saveContentToStorage(content, storageType) {
            try {
                switch (storageType) {
                    case 'localStorage':
                        localStorage.setItem('tel_editor_content', content);
                        break;
                    case 'sessionStorage':
                        sessionStorage.setItem('tel_editor_content', content);
                        break;
                    case 'indexedDB':
                        // IndexedDB Speicherung (vereinfacht)
                        if ('indexedDB' in window) {
                            const request = indexedDB.open('telEditorDB', 1);
                            request.onupgradeneeded = function() {
                                const db = request.result;
                                if (!db.objectStoreNames.contains('content')) {
                                    db.createObjectStore('content', { keyPath: 'id' });
                                }
                            };
                            request.onsuccess = function() {
                                const db = request.result;
                                const transaction = db.transaction(['content'], 'readwrite');
                                const store = transaction.objectStore('content');
                                store.put({ id: 'editor_content', data: content });
                            };
                        }
                        break;
                    case 'ram':
                        // RAM-Speicher (nur f√ºr aktuelle Session)
                        if (!window.telEditorContent) window.telEditorContent = {};
                        window.telEditorContent.editor_content = content;
                        break;
                    default:
                        console.error('Unbekannter Speichertyp:', storageType);
                }
            } catch (error) {
                console.error('Fehler beim Speichern in', storageType, ':', error);
            }
        }

        // TinyMCE Content Management
        function saveEditorContent() {
            try {
                const content = getEditorHtml();
                
                const storageInfo = getAvailableStorage();
                const availableStorage = storageInfo.size;
                
                if (content.length <= availableStorage) {
                    // Inhalt passt in verf√ºgbaren Speicher
                    saveContentToStorage(content, storageInfo.type);
                    showNotification(`Inhalt in ${storageInfo.type} gespeichert!`, 'success');
                    console.log(`Inhalt erfolgreich gespeichert in ${storageInfo.type}`);
                } else {
                    // Inhalt zu gro√ü - k√ºrze auf verf√ºgbare Gr√∂√üe
                    const truncatedContent = content.substring(0, availableStorage);
                    saveContentToStorage(truncatedContent, storageInfo.type);
                    showNotification(`Inhalt wurde auf ${Math.round(availableStorage / 1024 / 1024 * 100) / 100}MB gek√ºrzt gespeichert (${storageInfo.type})`, 'warning');
                    console.warn(`Inhalt gek√ºrzt: ${content.length} -> ${truncatedContent.length} Zeichen`);
                }
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                showNotification('Fehler beim Speichern!', 'error');
            }
        }

        // KORRIGIERT: Intelligente Inhaltsladung aus verschiedenen Speichertypen
        function loadEditorContent() {
            try {
                // 1. Versuche LocalStorage
                let saved = localStorage.getItem('tel_editor_content');
                if (saved) {
                    setEditorHtml(saved);
                    showNotification('Inhalt aus LocalStorage geladen!', 'success');
                    console.log('‚úÖ Inhalt aus LocalStorage geladen');
                    return;
                }
                
                // 2. Fallback: SessionStorage
                saved = sessionStorage.getItem('tel_editor_content');
                if (saved) {
                    setEditorHtml(saved);
                    showNotification('Inhalt aus SessionStorage geladen!', 'success');
                    console.log('üîÑ Inhalt aus SessionStorage geladen');
                    return;
                }
                
                // 3. Fallback: IndexedDB
                if ('indexedDB' in window) {
                    const request = indexedDB.open('telEditorDB', 1);
                    request.onsuccess = function() {
                        const db = request.result;
                        const transaction = db.transaction(['content'], 'readonly');
                        const store = transaction.objectStore('content');
                        const getRequest = store.get('editor_content');
                        getRequest.onsuccess = function() {
                            if (getRequest.result && getRequest.result.data) {
                                setEditorHtml(getRequest.result.data);
                                showNotification('Inhalt aus IndexedDB geladen!', 'success');
                                console.log('üîÑ Inhalt aus IndexedDB geladen');
                            }
                        };
                    };
                }
                
                // 4. Fallback: RAM-Speicher
                if (window.telEditorContent && window.telEditorContent.editor_content) {
                    setEditorHtml(window.telEditorContent.editor_content);
                    showNotification('Inhalt aus RAM-Speicher geladen!', 'success');
                    console.log('‚ö†Ô∏è Inhalt aus RAM-Speicher geladen');
                    return;
                }
                
                console.log('‚ÑπÔ∏è Kein gespeicherter Inhalt gefunden');
                
            } catch (error) {
                console.error('Fehler beim Laden des Inhalts:', error);
                showNotification('Fehler beim Laden des Inhalts!', 'error');
            }
        }
        
        // KORRIGIERT: Intelligente Speicherung je nach verf√ºgbarem Speichertyp
        function saveContentToStorage(content, storageType) {
            try {
                switch (storageType) {
                    case 'localStorage':
                        localStorage.setItem('tel_editor_content', content);
                        console.log('‚úÖ Inhalt in LocalStorage gespeichert');
                        break;
                    case 'sessionStorage':
                        sessionStorage.setItem('tel_editor_content', content);
                        console.log('üîÑ Inhalt in SessionStorage gespeichert');
                        break;
                    case 'indexedDB':
                        // IndexedDB Speicherung (vereinfacht)
                        if ('indexedDB' in window) {
                            const request = indexedDB.open('telEditorDB', 1);
                            request.onupgradeneeded = function() {
                                const db = request.result;
                                if (!db.objectStoreNames.contains('content')) {
                                    db.createObjectStore('content', { keyPath: 'id' });
                                }
                            };
                            request.onsuccess = function() {
                                const db = request.result;
                                const transaction = db.transaction(['content'], 'readwrite');
                                const store = transaction.objectStore('content');
                                store.put({ id: 'editor_content', data: content });
                                console.log('üîÑ Inhalt in IndexedDB gespeichert');
                            };
                        }
                        break;
                    case 'ram':
                        // RAM-Speicher (nur f√ºr aktuelle Session)
                        if (!window.telEditorContent) window.telEditorContent = {};
                        window.telEditorContent.editor_content = content;
                        console.log('‚ö†Ô∏è Inhalt in RAM-Speicher gespeichert');
                        break;
                    default:
                        console.error('Unbekannter Speichertyp:', storageType);
                }
            } catch (error) {
                console.error('Fehler beim Speichern in', storageType, ':', error);
                // Fallback auf LocalStorage wenn m√∂glich
                try {
                    localStorage.setItem('tel_editor_content', content);
                    console.log('üîÑ Fallback: Inhalt in LocalStorage gespeichert');
                } catch (fallbackError) {
                    console.error('Auch Fallback fehlgeschlagen:', fallbackError);
                }
            }
        }

        // TinyMCE Auto-save
        function setupAutoSave() {
            const editor = tinymce.get('wysiwyg');
            if (editor) {
                editor.on('change keyup', debounce(() => {
                    try {
                        const content = getEditorHtml();
                        
                        // KORRIGIERT: Intelligente Fallback-Speicherung bei Tracking Prevention
                        const getAvailableStorage = () => {
                            try {
                                // 1. Versuche LocalStorage (wenn Tracking Prevention es erlaubt)
                                let testSize = 1024 * 1024; // Starte mit 1MB
                                let maxSize = 0;
                                
                                while (testSize <= 2 * 1024 * 1024 * 1024) { // Max 2GB Test
                                    try {
                                        const testData = 'x'.repeat(testSize);
                                        const testKey = `tel_quota_test_${Date.now()}`;
                                        localStorage.setItem(testKey, testData);
                                        localStorage.removeItem(testKey);
                                        maxSize = testSize;
                                        testSize *= 1.5;
                                    } catch {
                                        break;
                                    }
                                }
                                
                                if (maxSize > 0) {
                                    // LocalStorage funktioniert
                                    const availableSize = Math.floor(maxSize * 0.67);
                                    console.log(`‚úÖ LocalStorage: ${Math.round(maxSize / 1024 / 1024 / 1024 * 100) / 100}GB, Verf√ºgbar: ${Math.round(availableSize / 1024 / 1024 / 1024 * 100) / 100}GB`);
                                    return { type: 'localStorage', size: availableSize };
                                }
                            } catch (error) {
                                console.warn('LocalStorage blockiert:', error);
                            }
                            
                            // 2. Fallback: SessionStorage (weniger Speicher, aber funktioniert)
                            try {
                                let testSize = 1024 * 1024; // 1MB
                                let maxSize = 0;
                                
                                while (testSize <= 100 * 1024 * 1024) { // Max 100MB
                                    try {
                                        const testData = 'x'.repeat(testSize);
                                        const testKey = `tel_session_test_${Date.now()}`;
                                        sessionStorage.setItem(testKey, testData);
                                        sessionStorage.removeItem(testKey);
                                        maxSize = testSize;
                                        testSize *= 2;
                                    } catch {
                                        break;
                                    }
                                }
                                
                                if (maxSize > 0) {
                                    const availableSize = Math.floor(maxSize * 0.67);
                                    console.log(`üîÑ SessionStorage: ${Math.round(maxSize / 1024 / 1024 * 100) / 100}MB, Verf√ºgbar: ${Math.round(availableSize / 1024 / 1024 * 100) / 100}MB`);
                                    return { type: 'sessionStorage', size: availableSize };
                                }
                            } catch (error) {
                                console.warn('SessionStorage blockiert:', error);
                            }
                            
                            // 3. Fallback: IndexedDB (gr√∂√üter Speicher, aber komplexer)
                            try {
                                if ('indexedDB' in window) {
                                    console.log('üîÑ IndexedDB verf√ºgbar - verwende 100MB Fallback');
                                    return { type: 'indexedDB', size: 100 * 1024 * 1024 };
                                }
                            } catch (error) {
                                console.warn('IndexedDB nicht verf√ºgbar:', error);
                            }
                            
                            // 4. Letzter Fallback: RAM-Speicher (nur f√ºr aktuelle Session)
                            console.log('‚ö†Ô∏è Alle Speicher blockiert - verwende RAM-Speicher (nur f√ºr aktuelle Session)');
                            return { type: 'ram', size: 50 * 1024 * 1024 }; // 50MB RAM
                        };
                        
                        const storageInfo = getAvailableStorage();
                        const availableStorage = storageInfo.size;
                        
                        if (content.length <= availableStorage) {
                            // Inhalt passt in verf√ºgbaren Speicher
                            saveContentToStorage(content, storageInfo.type);
                            console.log(`Auto-Save: Inhalt erfolgreich gespeichert in ${storageInfo.type}`);
                        } else {
                            // Inhalt zu gro√ü - k√ºrze auf verf√ºgbare Gr√∂√üe
                            const truncatedContent = content.substring(0, availableStorage);
                            saveContentToStorage(truncatedContent, storageInfo.type);
                            console.warn(`Auto-Save: Inhalt gek√ºrzt: ${content.length} -> ${truncatedContent.length} Zeichen (${storageInfo.type})`);
                        }
                    } catch (error) {
                        console.error('Fehler beim Auto-Save:', error);
                    }
                }, 1000));
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }



        console.log('üéµ Ultimate Multimedia WYSIWYG CMS mit TinyMCE geladen!');
        
        // ------- Core: Dateien hinzuf√ºgen (Fallback-Modus) -------
        async function addFileToLibrary(file, uploadInfo = null){ 
          try{
            // √úberpr√ºfe Datei
            if (!file || !file.name) {
              showNotification('Ung√ºltige Datei!', 'error');
              return;
            }
            
            // NEU: Flexible Upload-Gr√∂√üen je nach Dateityp und Original-Gr√∂√üe
            if (!uploadInfo) {
              uploadInfo = getOptimalUploadSize(file);
            }
            
            // √úberpr√ºfe Dateigr√∂√üe basierend auf optimaler Gr√∂√üe
            if (uploadInfo.finalSize > uploadInfo.availableStorage) {
              showNotification(`Datei zu gro√ü f√ºr verf√ºgbaren Speicher: ${file.name} (${formatFileSize(uploadInfo.finalSize)} > ${formatFileSize(uploadInfo.availableStorage)})`, 'warning');
              return;
            }
            
            // √úberpr√ºfe Dateityp
            const fileType = getFileTypeByMimeOrExt(file);
            console.log(`Datei: ${file.name}, Typ: ${file.type}, Erkannt als: ${fileType}`);
            console.log(`üìä Gr√∂√üe: ${formatFileSize(uploadInfo.originalSize)} ‚Üí ${formatFileSize(uploadInfo.finalSize)} (${uploadInfo.compressionRatio}%)`);
            
            const id = crypto.randomUUID();
            
            // Verwende IMMER Fallback-Modus wegen Tracking Prevention
            const fallbackFile = {
              id,
              name: file.name,
              size: uploadInfo.finalSize, // Verwende optimierte Gr√∂√üe
              originalSize: uploadInfo.originalSize, // Speichere Original-Gr√∂√üe
              type: fileType,
              mime: file.type || 'application/octet-stream',
              file: file,
              url: URL.createObjectURL(file),
              added: new Date(),
              selected: false,
              uploadInfo: uploadInfo // Speichere Upload-Informationen
            };
            
            // KORRIGIERT: URL-Cache f√ºr bessere Verwaltung
            if (!window.urlCache) window.urlCache = new Map();
            window.urlCache.set(id, fallbackFile.url);
            
            fileLibrary.push(fallbackFile);
            renderFileLibrary();
            updateStatistics();
            
            // Benachrichtigung √ºber erfolgreichen Upload mit Optimierung
            if (uploadInfo.finalSize < uploadInfo.originalSize) {
              showNotification(`Datei "${file.name}" optimiert gespeichert: ${formatFileSize(uploadInfo.originalSize)} ‚Üí ${formatFileSize(uploadInfo.finalSize)}`, 'success');
            } else {
              showNotification(`Datei "${file.name}" erfolgreich gespeichert!`, 'success');
            }
            
          } catch(err){ 
            console.error('Allgemeiner Fehler beim Hinzuf√ºgen:', err); 
            showNotification(`Fehler beim Hinzuf√ºgen von "${file.name}": ${err.message}`, 'error'); 
          }
        }

        async function getBlobUrl(id){ 
          // KORRIGIERT: Sichere URL-Verwaltung mit URL-Speicherung
          try {
            // Verwende IMMER Fallback-Modus wegen Tracking Prevention
            const fallbackFile = fileLibrary.find(f => f.id === id);
            if (!fallbackFile || !fallbackFile.file) {
              return null;
            }
            
            // Pr√ºfe ob bereits eine g√ºltige URL existiert
            if (fallbackFile.url && fallbackFile.url.startsWith('blob:')) {
              // Teste ob die URL noch g√ºltig ist
              try {
                const testImg = new Image();
                testImg.src = fallbackFile.url;
                await new Promise((resolve, reject) => {
                  testImg.onload = resolve;
                  testImg.onerror = reject;
                  setTimeout(reject, 1000); // 1s timeout
                });
                return fallbackFile.url;
              } catch (e) {
                // URL ist ung√ºltig, l√∂sche sie
                fallbackFile.url = null;
              }
            }
            
            // Erstelle neue URL
            const newUrl = URL.createObjectURL(fallbackFile.file);
            
            // WICHTIG: Speichere URL in fileLibrary UND urlCache
            fallbackFile.url = newUrl;
            if (!window.urlCache) window.urlCache = new Map();
            window.urlCache.set(id, newUrl);
            
            console.log(`üîÑ Neue Blob-URL erstellt f√ºr ${fallbackFile.name}:`, newUrl);
            return newUrl;
            
          } catch (error) {
            console.error('Fehler beim Abrufen der Blob-URL:', error);
            return null;
          }
        }

        // ------- UI Hooks -------
        function setupFileUpload() {
          const uploadArea = document.getElementById('uploadArea');
          const fileInput  = document.getElementById('fileInput');
          if(uploadArea&&fileInput){
            uploadArea.addEventListener('click',()=>fileInput.click());
            fileInput.addEventListener('change',(e)=>{
              console.log('Datei-Input ge√§ndert:', e.target.files);
              [...e.target.files].forEach(file => {
                console.log('Verarbeite Datei:', file.name, file.type, file.size);
                
                // Direkt zur Bibliothek hinzuf√ºgen (ohne Optimierung)
                addFileToLibrary(file, { originalSize: file.size, finalSize: file.size, compressionRatio: 100 });
              });
              e.target.value='';
            });
            uploadArea.addEventListener('dragover',(e)=>{ e.preventDefault(); uploadArea.classList.add('dragover'); });
            uploadArea.addEventListener('dragleave',()=>uploadArea.classList.remove('dragover'));
            uploadArea.addEventListener('drop',(e)=>{
              e.preventDefault(); 
              uploadArea.classList.remove('dragover'); 
              console.log('Dateien gedroppt:', e.dataTransfer.files);
              [...e.dataTransfer.files].forEach(file => {
                console.log('Verarbeite gedroppte Datei:', file.name, file.type, file.size);
                
                // Direkt zur Bibliothek hinzuf√ºgen (ohne Optimierung)
                addFileToLibrary(file, { originalSize: file.size, finalSize: file.size, compressionRatio: 100 });
              });
            });
          }
        }

        // ------- Bibliothek laden -------
        async function loadFileLibrary(){ 
          // Verwende IMMER leere Bibliothek wegen Tracking Prevention
          fileLibrary = [];
          renderFileLibrary(); 
          updateStatistics();
          console.log('Dateibibliothek im Fallback-Modus geladen (Tracking Prevention aktiv)');
        }

        // ------- Render File-Grid -------
        function renderFileLibrary(files=null){
          const fileGrid = document.getElementById('fileGrid'); if(!fileGrid) return;
          const src = files||fileLibrary; 
          if(!src.length){ 
            fileGrid.innerHTML = `<div class="no-files" style="grid-column:1/-1;text-align:center;color:var(--text-light);padding:2rem">
              <div style="font-size:3rem;margin-bottom:1rem">üìÅ</div>
              <p>Keine Dateien vorhanden</p>
              <p style="font-size:.9rem">Lade Dateien hoch, um zu beginnen</p>
            </div>`;
            return;
          }
          
          const filtered = currentFilter==='all' ? src : src.filter(f=>f.type===currentFilter);
          fileGrid.innerHTML = filtered.map(file=>{
            return `<div class="file-item ${file.selected?'selected':''}" data-type="${file.type}" onclick="toggleSelect('${file.id}')">
              <div class="file-icon" onclick="previewFile('${file.id}');event.stopPropagation();" style="cursor:pointer" title="Vorschau">${getFileIcon(file.type)}</div>
              <div class="file-name">${file.name}</div>
              <div class="file-size">${formatFileSize(file.size)}</div>
              <div class="file-actions">
                <button class="file-action-btn" onclick="insertSingle('${file.id}');event.stopPropagation();" title="In Editor einf√ºgen">üìù</button>
                <button class="file-action-btn" onclick="previewFile('${file.id}');event.stopPropagation();" title="Vorschau">üëÅÔ∏è</button>
                <button class="file-action-btn" onclick="deleteFile('${file.id}');event.stopPropagation();" title="L√∂schen">üóëÔ∏è</button>
              </div>
            </div>`;
          }).join('');
        }

        function filterFiles(type){ currentFilter=type; document.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active')); const btn=document.querySelector(`.filter-btn[data-type="${type}"]`); if(btn) btn.classList.add('active'); renderFileLibrary(); }

        function toggleSelect(id){ const f=fileLibrary.find(x=>x.id===id); if(!f) return; f.selected=!f.selected; renderFileLibrary(); }
        function selectAllFiles(){ fileLibrary.forEach(f=>f.selected=true); renderFileLibrary(); showNotification('Alle Dateien ausgew√§hlt.','success'); }
        function clearSelection(){ fileLibrary.forEach(f=>f.selected=false); renderFileLibrary(); showNotification('Auswahl aufgehoben.','info'); }

        // ------- Vorschau -------
        async function previewFile(id){ 
          try {
            const meta=fileLibrary.find(f=>f.id===id); if(!meta) return; 
            const url=await getBlobUrl(id);
            if (!url) {
              showNotification('Fehler beim Laden der Datei!', 'error');
              return;
            }
            
            const mime = meta.mime || meta.file?.type || '';
            const wrap=document.createElement('div'); wrap.className='modal';
            let inner='';
            
            // KORRIGIERT: Sichere URL-Verwendung
            if(meta.type==='image') {
              inner=`<img src="${url}" alt="${meta.name}" style="max-width:100%;max-height:80vh;border-radius:12px;object-fit:contain" onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
                     <div style="display:none;color:#fff;text-align:center"><div style="font-size:4rem">‚ùå</div><h3>Bild konnte nicht geladen werden</h3></div>`;
            } else if(meta.type==='video') {
              inner=`<video controls style="max-width:100%;max-height:80vh;border-radius:12px" onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
                       <source src="${url}" type="${mime}">
                     </video>
                     <div style="display:none;color:#fff;text-align:center"><div style="font-size:4rem">‚ùå</div><h3>Video konnte nicht geladen werden</h3></div>`;
            } else if(meta.type==='audio') {
              inner=`<audio controls style="width:100%" onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
                       <source src="${url}" type="${mime}">
                     </audio>
                     <div style="display:none;color:#fff;text-align:center"><div style="font-size:4rem">‚ùå</div><h3>Audio konnte nicht geladen werden</h3></div>`;
            } else {
              inner=`<div style="color:#fff;text-align:center"><div style="font-size:4rem">${getFileIcon(meta.type)}</div><h3>${meta.name}</h3><p>${meta.type} ‚Ä¢ ${formatFileSize(meta.size)}</p></div>`;
            }
            
            wrap.innerHTML=`<div class="box" style="padding:1rem;align-items:center;justify-content:center">${inner}<div style="padding:1rem"><button onclick="this.closest('.modal').remove()" style="background:#ef4444;color:#fff;border:0;border-radius:10px;padding:.6rem 1rem;cursor:pointer">Schlie√üen</button></div></div>`;
            document.body.appendChild(wrap);
          } catch (error) {
            console.error('Fehler in previewFile:', error);
            showNotification('Fehler beim Laden der Vorschau!', 'error');
          }
        }

        // ------- Editor-Integration -------
        // KORRIGIERT: Saubere Darstellung ohne zus√§tzliche DIV-Wrapper
        function renderEmbed(meta, url) {
          if (!url) {
            return `<div class="file-chip" style="color:#ef4444; padding: 10px; border: 1px solid #ef4444; border-radius: 8px; margin: 10px 0; background: #fef2f2;">‚ùå ${meta.name} - Fehler beim Laden</div>`;
          }
          
          const safeAlt = (meta?.name || '').replace(/"/g, '&quot;');
          
          switch(meta.type) {
            case 'image': 
              // WICHTIG: Bild direkt einbetten, nicht als Dateiname
              return `<img src="${url}" alt="${safeAlt}" style="width:100%;height:auto;border-radius:8px;margin:1rem 0;display:block;" data-file-id="${meta.id}" data-mce-blob-uri="${url}">`;
              
            case 'video': 
              // WICHTIG: Video-Element mit korrekter Struktur f√ºr Export
              return `<video controls preload="metadata" playsinline style="width:100%;height:auto;border-radius:8px;margin:1rem 0;display:block;" data-file-id="${meta.id}" data-mce-blob-uri="${url}">
                <source src="${url}" type="${meta.mime || meta.file?.type || 'video/mp4'}">
                Dein Browser unterst√ºtzt keine Video-Wiedergabe.
              </video>`;
              
            case 'audio': 
              return `<audio controls preload="metadata" style="width:100%;border-radius:8px;margin:1rem 0;display:block;" data-file-id="${meta.id}" data-mce-blob-uri="${url}">
                <source src="${url}" type="${meta.mime || 'audio/mpeg'}">
                Dein Browser unterst√ºtzt keine Audio-Wiedergabe.
              </audio>`;
              
            default: 
              return `<div class="file-chip" style="padding: 10px; text-align: center; font-size: 14px; border: 1px solid #e5e7eb; border-radius: 8px; background: #f9fafb;">
                üìé ${safeAlt} <br><small style="color: #6b7280;">(${meta.type}, ${formatFileSize(meta.size)})</small>
              </div>`;
          }
        }
        async function insertSingle(id){ 
          const meta=fileLibrary.find(f=>f.id===id); 
          if(!meta) return; 
          
          const url=await getBlobUrl(id); 
          if(!url) {
            showNotification(`Fehler beim Laden von "${meta.name}"`, 'error');
            return;
          }
          
          const ed = window.tinymce?.get('wysiwyg'); 
          if(ed) {
            const embedHtml = renderEmbed(meta, url);
            console.log('üìù F√ºge ein:', meta.type, meta.name, 'HTML:', embedHtml);
            ed.insertContent(embedHtml);
            showNotification(`"${meta.name}" eingef√ºgt.`, 'success');
          } else {
            showNotification('Editor nicht bereit!', 'error');
          }
        }

        // ------- Mehrfachauswahl-Dialog -------
        // Alias f√ºr den "Medien einf√ºgen" Button
        function insertMedia() {
            return openInsertModal();
        }
        
        function openInsertModal(){
          const items = fileLibrary.map(f=>`
            <label class="pick">
              <input type="checkbox" data-id="${f.id}" onchange="togglePick(this)">
              <span class="icon">${getFileIcon(f.type)}</span>
              <span class="name" title="${f.name}">${f.name}</span>
              <span class="type" style="color:#6b7280">${f.type}</span>
            </label>`).join('');
          const html = `<div class="modal"><div class="box">
            <h3>üìé Medien einf√ºgen</h3>
            <div class="toolbar">
              <button onclick="pickAll()">Alle</button>
              <button onclick="pickNone()">Keine</button>
              <button onclick="insertPicked()">Einf√ºgen (<span id="pickCount">0</span>)</button>
              <button onclick="document.querySelector('.modal')?.remove()">Schlie√üen</button>
            </div>
            <div class="grid">${items}</div>
          </div></div>`;
          document.body.insertAdjacentHTML('beforeend', html);
          pickSelection.clear(); updatePickCount();
        }
        function togglePick(cb){ const id=cb.getAttribute('data-id'); cb.checked?pickSelection.add(id):pickSelection.delete(id); updatePickCount(); }
        function pickAll(){ pickSelection=new Set(fileLibrary.map(f=>f.id)); document.querySelectorAll('.grid input[type=checkbox]').forEach(c=>c.checked=true); updatePickCount(); }
        function pickNone(){ pickSelection.clear(); document.querySelectorAll('.grid input[type=checkbox]').forEach(c=>c.checked=false); updatePickCount(); }
        function updatePickCount(){ const n=document.getElementById('pickCount'); if(n) n.textContent=pickSelection.size; }
        // KORRIGIERT: Mehrere Dateien ANH√ÑNGEN statt √ºberschreiben
        async function insertPicked() { 
          const ed = window.tinymce?.get('wysiwyg'); 
          if (!ed) return; 
          
          // Aktuelle Cursor-Position speichern
          const currentContent = ed.getContent({
          format: 'html',
          get_inner: false,
          get_outer: true,
          no_events: true,
          no_selection: true
        });
          let insertedCount = 0;
          
          for (const id of pickSelection) { 
            const m = fileLibrary.find(f => f.id === id); 
            if (!m) continue;
            
            const url = await getBlobUrl(id); 
            if (!url) continue;
            
            // WICHTIG: Anh√§ngen statt √ºberschreiben!
            let mediaHtml = renderEmbed(m, url);
            
            // Wenn bereits Inhalt vorhanden, f√ºge neue Zeile hinzu
            if (currentContent && currentContent.trim() !== '' && insertedCount === 0) {
              mediaHtml = '<br>' + mediaHtml;
            }
            
                      // Datei einf√ºgen
          ed.insertContent(mediaHtml);
          insertedCount++;
          
          // Datei als "verwendet" markieren
          m.used = true;
        } 
        
        // KORRIGIERT: Sofortige Werkzeugleiste-Wiederherstellung nach dem Einf√ºgen
        try {
          console.log('üîÑ Stelle Werkzeugleiste nach Einf√ºgung wieder her...');
          
          // Sofort pr√ºfen und wiederherstellen (keine Verz√∂gerung)
          if (!ed.ui.registry.getAll().buttons.scaleMinus) {
            console.log('üîÑ Custom-Buttons fehlen - registriere neu...');
            
            // Alle Custom-Buttons sofort neu registrieren
            const buttons = [
              {
                name: 'scaleMinus',
                config: {
                  icon: 'zoom-out', 
                  tooltip: 'Kleiner (‚àí10%)',
                  onAction: () => { 
                    const n = ed.selection.getNode(); 
                    if (n && /^(IMG|VIDEO)$/.test(n.nodeName)) {
                      const currentWidth = parseFloat(n.style.width) || 100;
                      n.style.width = Math.max(10, currentWidth - 10) + '%';
                      n.style.height = 'auto';
                    }
                  }
                }
              },
              {
                name: 'scalePlus',
                config: {
                  icon: 'zoom-in', 
                  tooltip: 'Gr√∂√üer (+10%)',
                  onAction: () => { 
                    const n = ed.selection.getNode(); 
                    if (n && /^(IMG|VIDEO)$/.test(n.nodeName)) {
                      const currentWidth = parseFloat(n.style.width) || 100;
                      n.style.width = Math.min(200, currentWidth + 10) + '%';
                      n.style.height = 'auto';
                    }
                  }
                }
              },
              {
                name: 'scaleReset',
                config: {
                  text: '100%', 
                  tooltip: 'Breite 100%',
                  onAction: () => { 
                    const n = ed.selection.getNode(); 
                    if (n && /^(IMG|VIDEO)$/.test(n.nodeName)) {
                      n.style.width = '100%';
                      n.style.height = 'auto';
                    }
                  }
                }
              },
              {
                name: 'gridToggle',
                config: {
                  icon: 'table', 
                  tooltip: 'Snap-Grid ein/aus (5%)',
                  onAction: () => ed.getBody().classList.toggle('snap-grid'),
                  onSetup(api){
                    const body = ed.getBody();
                    const f = () => api.setActive(body.classList.contains('snap-grid'));
                    ed.on('init', f); 
                    return () => ed.off('init', f);
                  }
                }
              },
              {
                name: 'scaleDialog',
                config: {
                  icon: 'preferences',
                  tooltip: 'Gr√∂√üe exakt einstellen‚Ä¶',
                  onAction: () => {
                    const n = ed.selection.getNode();
                    if (n && /^(IMG|VIDEO)$/.test(n.nodeName)) {
                      const currentWidth = parseFloat(n.style.width) || 100;
                      const newWidth = prompt('Neue Breite in %:', currentWidth);
                      if (newWidth && !isNaN(newWidth)) {
                        n.style.width = Math.max(10, Math.min(200, parseFloat(newWidth))) + '%';
                        n.style.height = 'auto';
                      }
                    }
                  }
                }
              }
            ];
            
            // Alle Buttons sofort registrieren
            buttons.forEach(btn => {
              try {
                if (btn.name === 'gridToggle') {
                  ed.ui.registry.addToggleButton(btn.name, btn.config);
                } else {
                  ed.ui.registry.addButton(btn.name, btn.config);
                }
                console.log(`‚úÖ Button ${btn.name} registriert`);
              } catch (error) {
                console.warn(`‚ö†Ô∏è Button ${btn.name} konnte nicht registriert werden:`, error);
              }
            });
            
            console.log('‚úÖ Werkzeugleiste erfolgreich wiederhergestellt');
          } else {
            console.log('‚úÖ Werkzeugleiste ist bereits vorhanden');
          }
        } catch (error) {
          console.error('‚ùå Fehler beim Wiederherstellen der Werkzeugleiste:', error);
        }
        
        // Modal schlie√üen und Benachrichtigung
        document.querySelector('.modal')?.remove(); 
        showNotification(`${insertedCount} Datei(en) erfolgreich angeh√§ngt!`, 'success');
        
        // Statistiken aktualisieren
        updateStatistics();
        
        console.log(`‚úÖ ${insertedCount} Dateien erfolgreich angeh√§ngt (nicht √ºberschrieben)`);
        }

        // ------- L√∂schen / Suche -------
        async function deleteFile(id){ 
          const meta=fileLibrary.find(f=>f.id===id); if(!meta) return; 
          if(!confirm(`"${meta.name}" wirklich l√∂schen?`)) return; 
          
          // Fallback-Modus: nur aus fileLibrary entfernen
          if(meta.url) { URL.revokeObjectURL(meta.url); }
          fileLibrary = fileLibrary.filter(f=>f.id!==id); 
          renderFileLibrary(); 
          updateStatistics(); 
          showNotification('Datei gel√∂scht.','success'); 
        }
        
        function searchFiles(q){ const s=(q||'').toLowerCase(); const filtered=fileLibrary.filter(f=> f.name.toLowerCase().includes(s) || f.type.toLowerCase().includes(s) || formatFileSize(f.size).toLowerCase().includes(s) ); renderFileLibrary(filtered); }

        // ------- Statistiken (Tippfehler behoben) -------
        function updateStatistics(){ 
          const total=fileLibrary.length; 
          const size=fileLibrary.reduce((a,b)=>a+(b.size||0),0); 
          const img=fileLibrary.filter(f=>f.type==='image').length; 
          const vid=fileLibrary.filter(f=>f.type==='video').length; 
          const pres=fileLibrary.filter(f=>f.type==='presentation').length; 
          
          const $=(id)=>document.getElementById(id); 
          if($('totalFiles')) $('totalFiles').textContent=total; 
          if($('totalSize')) $('totalSize').textContent=formatFileSize(size); 
          if($('imageCount')) $('imageCount').textContent=img; 
          if($('videoCount')) $('videoCount').textContent=vid; // <- Fix: war imageCount
          if($('presentationCount')) $('presentationCount').textContent=pres; 
        }

        // ------- Bulk Delete (Mehrfach) -------
        async function bulkDelete(){ 
          const sel=fileLibrary.filter(f=>f.selected); 
          if(!sel.length){ showNotification('Keine Dateien ausgew√§hlt!','warning'); return; } 
          if(!confirm(`M√∂chtest du ${sel.length} Datei(en) l√∂schen?`)) return; 
          
          for(const f of sel){ 
            // Fallback-Modus: nur aus fileLibrary entfernen
            if(f.url) { URL.revokeObjectURL(f.url); }
          } 
          
          fileLibrary=fileLibrary.filter(f=>!f.selected); 
          renderFileLibrary(); 
          updateStatistics(); 
          showNotification(`${sel.length} Datei(en) gel√∂scht.`,'success'); 
        }

        // ------- Export / Import (ZIP + Fallback JSON) -------
        async function exportFileLibrary(){ 
          try{
            if(!fileLibrary.length){ 
              showNotification('Keine Dateien in der Bibliothek.','warning'); 
              return; 
            }
            
            // Exportiere aktuelle fileLibrary (Fallback-Modus)
            const exportData = fileLibrary.map(f => ({
              id: f.id,
              name: f.name,
              size: f.size,
              type: f.type,
              mime: f.mime || f.file?.type,
              ext: f.ext || f.name.split('.').pop().toLowerCase(),
              added: f.added
            }));
            
            const zip = new JSZip(); 
            zip.file('library.json', JSON.stringify(exportData, null, 2)); 
            
            // F√ºge Dateien hinzu (falls verf√ºgbar)
            const folder = zip.folder('files');
            for(const f of fileLibrary){
              if(f.file) {
                folder.file(`${f.id}__${f.name}`, f.file);
              }
            }
            
            const blob = await zip.generateAsync({type:'blob'}); 
            downloadBlob(blob, 'tel-cms-library.zip'); 
            showNotification('ZIP-Export fertig.','success');
          } catch(e){ 
            console.error(e); 
            showNotification('Export fehlgeschlagen.','error'); 
          }
        }

        function downloadBlob(blob, filename){ 
          const url = URL.createObjectURL(blob); 
          const a = document.createElement('a'); 
          a.href = url; 
          a.download = filename; 
          document.body.appendChild(a); 
          a.click(); 
          a.remove(); 
          setTimeout(() => URL.revokeObjectURL(url), 1000); 
        }

        function importFileLibrary(){ 
          const input = document.createElement('input'); 
          input.type = 'file'; 
          input.accept = '.zip,application/zip'; 
          input.onchange = async(e) => { 
            const f = e.target.files[0]; 
            if(!f) return; 
            try{ 
              if(f.name.toLowerCase().endsWith('.zip')){ 
                await importLibraryZip(f); 
                showNotification('ZIP-Import abgeschlossen.','success'); 
              } else { 
                showNotification('Bitte w√§hle eine ZIP-Datei aus.','warning'); 
                return;
              } 
            } catch(err){ 
              console.error(err); 
              showNotification('Import fehlgeschlagen.','error'); 
            } finally { 
              e.target.value = ''; 
            }
          }; 
          input.click(); 
        }

        async function importLibraryZip(file){ 
          const zip = await JSZip.loadAsync(file); 
          const libFile = zip.file('library.json'); 
          if(!libFile) throw new Error('library.json fehlt in ZIP'); 
          
          const metas = JSON.parse(await libFile.async('string'));
          
          // Lade Dateien aus ZIP
          const fileEntries = Object.values(zip.files).filter(f => f.name.startsWith('files/') && !f.dir);
          
          // Erstelle neue fileLibrary Eintr√§ge
          for(const m of metas){
            const zipFile = fileEntries.find(f => f.name.startsWith(`files/${m.id}__`));
            if(zipFile) {
              const blob = await zipFile.async('blob');
              const newFile = new File([blob], m.name, { type: m.mime || 'application/octet-stream' });
              
              const fallbackFile = {
                id: m.id,
                name: m.name,
                size: m.size,
                type: m.type,
                file: newFile,
                url: URL.createObjectURL(newFile),
                added: new Date(),
                selected: false
              };
              
              fileLibrary.push(fallbackFile);
            }
          }
          
          renderFileLibrary(); 
          updateStatistics(); 
        }

        // JSON-Import entfernt - nur ZIP-Import unterst√ºtzt (mit echten Dateien)

        // ------- Pr√§sentationsmodus -------
        function createPresentation() {
            const editor = tinymce.get('wysiwyg');
            if (!editor) return;
            
            const content = editor.getContent();
            if (!content || content.trim() === '') {
                showNotification('Keine Inhalte f√ºr Pr√§sentation vorhanden!', 'warning');
                return;
            }
            
            // Parse content into slides (split by headers)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            const headers = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');
            if (headers.length === 0) {
                // Create single slide
                slides = [{
                    title: 'Pr√§sentation',
                    content: content
                }];
            } else {
                // Create slides from headers
                slides = [];
                let currentSlideContent = '';
                
                for (let i = 0; i < tempDiv.children.length; i++) {
                    const element = tempDiv.children[i];
                    if (element.tagName.match(/^H[1-6]$/)) {
                        if (currentSlideContent.trim()) {
                            slides.push({
                                title: slides.length > 0 ? slides[slides.length - 1].title : 'Folie 1',
                                content: currentSlideContent.trim()
                            });
                        }
                        currentSlideContent = element.outerHTML;
                        slides.push({
                            title: element.textContent,
                            content: element.outerHTML
                        });
                    } else {
                        currentSlideContent += element.outerHTML;
                    }
                }
                
                if (currentSlideContent.trim()) {
                    slides.push({
                        title: slides.length > 0 ? slides[slides.length - 1].title : 'Folie 1',
                        content: currentSlideContent.trim()
                    });
                }
            }
            
            currentSlide = 0;
            showPresentation();
            showNotification(`Pr√§sentation mit ${slides.length} Folien erstellt!`, 'success');
        }

        function showPresentation() {
            document.getElementById('presentationMode').style.display = 'block';
            document.getElementById('cms').scrollIntoView({ behavior: 'smooth' });
            updateSlideDisplay();
            
            // Add keyboard navigation
            document.addEventListener('keydown', handlePresentationKeys);
        }

        function handlePresentationKeys(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'ArrowUp':
                    e.preventDefault();
                    previousSlide();
                    break;
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'Escape':
                    e.preventDefault();
                    exitPresentation();
                    break;
            }
        }

        function exitPresentation() {
            document.getElementById('presentationMode').style.display = 'none';
            document.removeEventListener('keydown', handlePresentationKeys);
            
            // Stop timer if running
            if (timerRunning) {
                clearInterval(presentationTimer);
                timerRunning = false;
            }
        }

        // Timer Functions
        function toggleTimer() {
            if (timerRunning) {
                clearInterval(presentationTimer);
                timerRunning = false;
                document.getElementById('timerBtn').innerHTML = '‚è±Ô∏è Timer starten';
                document.getElementById('presentationTimer').textContent = '00:00';
            } else {
                timerStartTime = Date.now();
                timerRunning = true;
                document.getElementById('timerBtn').innerHTML = '‚è∏Ô∏è Timer pausieren';
                presentationTimer = setInterval(updateTimer, 1000);
            }
        }

        function updateTimer() {
            if (timerStartTime) {
                const elapsed = Date.now() - timerStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('presentationTimer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Notes Functions
        function toggleNotes() {
            notesVisible = !notesVisible;
            const notesDiv = document.getElementById('presentationNotes');
            const notesBtn = document.getElementById('notesBtn');
            
            if (notesVisible) {
                notesDiv.style.display = 'block';
                notesBtn.innerHTML = 'üìù Notizen verstecken';
                updateNotesContent();
            } else {
                notesDiv.style.display = 'none';
                notesBtn.innerHTML = 'üìù Notizen';
            }
        }

        function updateNotesContent() {
            if (slides.length > 0 && currentSlide < slides.length) {
                const slide = slides[currentSlide];
                const notesContent = document.getElementById('notesContent');
                // Extract text content for notes (remove HTML tags)
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = slide.content;
                const textContent = tempDiv.textContent || tempDiv.innerText || '';
                notesContent.textContent = textContent.substring(0, 200) + (textContent.length > 200 ? '...' : '');
            }
        }

        // Update Slide Display
        function updateSlideDisplay() {
            if (slides.length === 0) return;
            
            const slide = slides[currentSlide];
            document.getElementById('slideContent').innerHTML = slide.content;
            document.getElementById('slideCounter').textContent = `Folie ${currentSlide + 1} von ${slides.length}`;
            
            // Update notes if visible
            if (notesVisible) {
                updateNotesContent();
            }
        }

        // Navigation Functions
        function previousSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlideDisplay();
            }
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateSlideDisplay();
            }
        }

        // Help System
        function showHelp() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000; display: flex;
                align-items: center; justify-content: center; padding: 2rem;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 2rem; border-radius: 1rem; max-width: 800px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 1.5rem; color: var(--primary);">‚ùì Hilfe - TEL CMS</h2>
                    
                    <div style="margin-bottom: 2rem;">
                        <h3 style="color: var(--secondary); margin-bottom: 1rem;">üìÅ Dateiverwaltung</h3>
                        <ul style="line-height: 1.8; padding-left: 1.5rem;">
                            <li><strong>Dateien hochladen:</strong> Ziehe Dateien in den Upload-Bereich oder klicke darauf</li>
                            <li><strong>Unterst√ºtzte Formate:</strong> Bilder (JPG, PNG, GIF), Videos (MP4, AVI), Audio (MP3, WAV), Dokumente (PDF, DOC), Pr√§sentationen (PPT, PPTX)</li>
                            <li><strong>Dateien filtern:</strong> Verwende die Filter-Buttons, um nach Dateitypen zu sortieren</li>
                            <li><strong>Dateien durchsuchen:</strong> Nutze die Suchleiste f√ºr schnelle Suche</li>
                            <li><strong>Bulk-Operationen:</strong> W√§hle mehrere Dateien aus f√ºr Massenl√∂schung</li>
                        </ul>
                    </div>
                    
                    <div style="margin-bottom: 2rem;">
                        <h3 style="color: var(--secondary); margin-bottom: 1rem;">üìù WYSIWYG Editor</h3>
                        <ul style="line-height: 1.8; padding-left: 1.5rem;">
                            <li><strong>Medien einf√ºgen:</strong> Klicke auf "üìé Medien einf√ºgen" um Dateien aus der Bibliothek einzuf√ºgen</li>
                            <li><strong>Auto-Save:</strong> Alle √Ñnderungen werden automatisch gespeichert</li>
                            <li><strong>Export:</strong> Verwende "‚¨áÔ∏é Exportieren" um deine Website zu exportieren</li>
                        </ul>
                    </div>
                    
                    <div style="margin-bottom: 2rem;">
                        <h3 style="color: var(--secondary); margin-bottom: 1rem;">üìä Pr√§sentationsmodus</h3>
                        <ul style="line-height: 1.8; padding-left: 1.5rem;">
                            <li><strong>Pr√§sentation erstellen:</strong> Klicke auf "üìä Pr√§sentation erstellen" nach dem Bearbeiten</li>
                            <li><strong>Navigation:</strong> Pfeiltasten oder Leertaste f√ºr n√§chste Folie, ESC zum Beenden</li>
                            <li><strong>Timer:</strong> Starte einen Timer f√ºr deine Pr√§sentation</li>
                            <li><strong>Notizen:</strong> Zeige Notizen zu jeder Folie an</li>
                        </ul>
                    </div>
                    
                    <div style="margin-bottom: 2rem;">
                        <h3 style="color: var(--secondary); margin-bottom: 1rem;">üíæ Datenverwaltung</h3>
                        <ul style="line-height: 1.8; padding-left: 1.5rem;">
                            <li><strong>Bibliothek exportieren:</strong> Sichere deine Dateibibliothek als ZIP</li>
                            <li><strong>Bibliothek importieren:</strong> Lade eine gespeicherte Bibliothek wieder</li>
                            <li><strong>Lokaler Speicher:</strong> Alle Daten werden lokal im Browser gespeichert</li>
                        </ul>
                    </div>
                    
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove();" 
                            style="background: var(--primary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">Verstanden!</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on escape key
            const closeModal = () => modal.remove();
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeModal();
            });
        }

        // Initialize File Management
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ TEL CMS wird initialisiert...');
            
            // Initiale Section anzeigen (Home)
            showSection('home');
            
            // Load saved language preference
            const savedLang = localStorage.getItem('preferredLanguage');
            if (savedLang) {
                document.getElementById('languageSelect').value = savedLang;
            }
            
            // Setup file upload
            setupFileUpload();
            
            // Load file library
            loadFileLibrary();
            
            // Debug: Bibliothek-Status anzeigen
            setTimeout(() => {
                console.log('üìä Dateibibliothek Status:', {
                    totalFiles: fileLibrary.length,
                    videos: fileLibrary.filter(f => f.type === 'video').length,
                    images: fileLibrary.filter(f => f.type === 'image').length,
                    audio: fileLibrary.filter(f => f.type === 'audio').length
                });
                
                // Zeige alle Videos in der Bibliothek
                const videos = fileLibrary.filter(f => f.type === 'video');
                if (videos.length > 0) {
                    console.log('üé• Videos in Bibliothek:', videos.map(v => ({ name: v.name, id: v.id, size: v.size })));
                } else {
                    console.log('‚ö†Ô∏è Keine Videos in der Bibliothek gefunden');
                }
            }, 1000);
            
            // KORRIGIERT: TinyMCE nach File Management initialisieren
            if (typeof tinymce !== 'undefined') {
                console.log('‚úÖ TinyMCE verf√ºgbar - initialisiere Editor...');
                // initializeTinyMCE(); // ENTFERNT - NEUER PATCH IST AKTIV
            } else {
                console.error('‚ùå TinyMCE nicht verf√ºgbar!');
                showNotification('TinyMCE konnte nicht geladen werden!', 'error');
            }
        });
    </script>



    <script>
    // ===== SAUBERE EXPORT-FUNKTION: Videos werden korrekt eingebettet =====
    async function exportWebsite() {
      try {
        console.log('üöÄ Starte sauberen Export...');
        
        // 1. Editor-Inhalt holen
        const ed = window.tinymce?.get('wysiwyg');
        if (!ed) {
          showNotification('Editor nicht bereit!', 'error');
          return;
        }
        
        const content = ed.getContent();
        if (!content || content.trim() === '') {
          showNotification('Keine Inhalte zum Exportieren!', 'warning');
          return;
        }
        
        console.log('üìù Editor-Inhalt geholt:', content.length, 'Zeichen');
        
        // 2. Wrapper-DIVs entfernen und HTML bereinigen
        const wrap = document.createElement('div');
        wrap.innerHTML = content;
        
        // Container-DIVs um Medien entfernen
        wrap.querySelectorAll('[data-file-id] > img,[data-file-id] > video,[data-file-id] > audio').forEach(el => {
          const host = el.parentElement;
          if (host && host !== wrap && host.childElementCount === 1) {
            host.replaceWith(el);
          }
        });
        
        // 3. Alle Medien-Elemente finden und konvertieren
        const mediaElements = wrap.querySelectorAll('img, audio, video, source');
        console.log('üé¨ Gefundene Medien:', mediaElements.length);
        
        // Debug: Alle gefundenen Elemente anzeigen
        mediaElements.forEach((el, index) => {
          const src = el.getAttribute('src');
          const fileId = el.getAttribute('data-file-id');
          console.log(`üîç Element ${index + 1}:`, el.tagName, 'src:', src, 'fileId:', fileId);
        });
        
        let convertedCount = 0;
        let errorCount = 0;
        
        for (const el of mediaElements) {
          const src = el.getAttribute('src');
          if (!src || !src.startsWith('blob:')) continue;
          
          // Datei-ID finden - verbesserte Suche
          let fileId = el.getAttribute('data-file-id');
          if (!fileId) {
            // Fallback 1: Suche nach data-file-id in √ºbergeordneten Elementen
            const parentWithId = el.closest('[data-file-id]');
            if (parentWithId) {
              fileId = parentWithId.getAttribute('data-file-id');
            }
          }
          
          // Fallback 2: Suche √ºber Blob-URL-Mapping
          if (!fileId && window.urlCache) {
            for (const [id, url] of window.urlCache) {
              if (url === src) {
                fileId = id;
                break;
              }
            }
          }
          
          // Fallback 3: Suche √ºber fileLibrary
          if (!fileId) {
            const entry = window.fileLibrary?.find(f => f.url === src);
            if (entry) {
              fileId = entry.id;
            }
          }
          
          if (!fileId) {
            console.warn('Keine Datei-ID gefunden f√ºr:', el, 'mit src:', src);
            continue;
          }
          
          // Datei in der Bibliothek suchen
          const entry = window.fileLibrary?.find(f => f.id === fileId);
          if (!entry || !entry.file) {
            console.warn('Datei nicht in Bibliothek gefunden:', fileId);
            continue;
          }
          
          try {
            // Datei zu Data-URL konvertieren
            const dataUrl = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(entry.file);
            });
            
            // Je nach Element-Typ behandeln
            if (el.tagName === 'VIDEO') {
              // Video-Element: source hinzuf√ºgen/aktualisieren
              let source = el.querySelector('source');
              if (!source) {
                source = document.createElement('source');
                el.appendChild(source);
              }
              source.setAttribute('src', dataUrl);
              source.setAttribute('type', entry.mime || entry.file.type || 'video/mp4');
              el.removeAttribute('src'); // src vom video-Element entfernen
              
              // Video-Attribute setzen - alle wichtigen Attribute
              el.setAttribute('controls', '');
              el.setAttribute('preload', 'metadata');
              el.setAttribute('playsinline', '');
              el.setAttribute('width', '100%');
              el.setAttribute('height', 'auto');
              el.setAttribute('style', 'width:100%;height:auto;border-radius:8px;margin:1rem 0;');
              
              // Zus√§tzliche Video-spezifische Attribute
              el.setAttribute('crossorigin', 'anonymous');
              el.setAttribute('muted', '');
              
              console.log('‚úÖ Video konvertiert:', entry.name, 'mit MIME-Type:', entry.mime || entry.file.type);
              
            } else if (el.tagName === 'AUDIO') {
              // Audio-Element: source hinzuf√ºgen/aktualisieren
              let source = el.querySelector('source');
              if (!source) {
                source = document.createElement('source');
                el.appendChild(source);
              }
              source.setAttribute('src', dataUrl);
              source.setAttribute('type', entry.mime || entry.file.type || 'audio/mpeg');
              el.removeAttribute('src');
              
              // Audio-Attribute setzen
              el.setAttribute('controls', '');
              el.setAttribute('preload', 'metadata');
              el.setAttribute('width', '100%');
              
            } else if (el.tagName === 'IMG') {
              // Bild: direkt src setzen
              el.setAttribute('src', dataUrl);
              
            } else if (el.tagName === 'SOURCE') {
              // Source-Element: src und type setzen
              el.setAttribute('src', dataUrl);
              el.setAttribute('type', entry.mime || entry.file.type || '');
            }
            
            convertedCount++;
            console.log('‚úÖ', el.tagName, 'konvertiert zu Data-URL');
            
          } catch (error) {
            errorCount++;
            console.error('‚ùå Fehler bei', el.tagName, ':', error);
            
            // Fallback: Element als Fehler anzeigen
            const errorDiv = document.createElement('div');
            errorDiv.innerHTML = `‚ùå Fehler beim Laden von ${entry.name}`;
            errorDiv.style.cssText = 'color: #ef4444; padding: 1rem; border: 1px solid #ef4444; border-radius: 8px; margin: 1rem 0; background: #fef2f2;';
            el.parentNode?.replaceChild(errorDiv, el);
          }
        }
        
        // 4. Sauberes HTML erstellen
        const cleanHTML = wrap.innerHTML;
        const finalHTML = `<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Export - TEL CMS</title>
    <style>
        body { 
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
            line-height: 1.6; 
            margin: 20px; 
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            color: #333;
        }
        img, video, audio { 
            max-width: 100%; 
            height: auto; 
            display: block; 
            margin: 1rem 0; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        video { 
            min-height: 200px; 
            width: 100%;
            background: #000;
        }
        audio { 
            width: 100%; 
        }
        h1, h2, h3, h4, h5, h6 {
            color: #1f2937;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        p {
            margin-bottom: 1rem;
        }
        .file-chip {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
            margin: 1rem 0;
            text-align: center;
        }
    </style>
</head>
<body>
    ${cleanHTML}
</body>
</html>`;
        
        // 5. Download starten
        const blob = new Blob([finalHTML], {type: 'text/html;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'tel-cms-export.html';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        
        // 6. Erfolgsmeldung
        let message = `Export erfolgreich! ${convertedCount} Medien konvertiert.`;
        if (errorCount > 0) {
          message += ` ${errorCount} Fehler aufgetreten.`;
        }
        
        showNotification(message, 'success');
        console.log('‚úÖ Export erfolgreich! Datei: tel-cms-export.html');
        console.log(`üìä Statistiken: ${convertedCount} Medien konvertiert, ${errorCount} Fehler`);
        
        // Debug: Zeige alle konvertierten Medien
        if (convertedCount > 0) {
          console.log('üéâ Erfolgreich konvertierte Medien:');
          const convertedElements = wrap.querySelectorAll('img, audio, video');
          convertedElements.forEach((el, index) => {
            if (el.tagName === 'VIDEO') {
              const source = el.querySelector('source');
              console.log(`  ${index + 1}. Video: ${source?.getAttribute('src')?.substring(0, 50)}...`);
            } else if (el.tagName === 'IMG') {
              console.log(`  ${index + 1}. Bild: ${el.getAttribute('src')?.substring(0, 50)}...`);
            } else if (el.tagName === 'AUDIO') {
              const source = el.querySelector('source');
              console.log(`  ${index + 1}. Audio: ${source?.getAttribute('src')?.substring(0, 50)}...`);
            }
          });
        }
        
      } catch (error) {
        console.error('‚ùå Export fehlgeschlagen:', error);
        showNotification('Export fehlgeschlagen: ' + error.message, 'error');
      }
    }
    </script>

    <!-- ===== KORRIGIERTER CMS-Comfort-Patch: Werkzeugleiste + Scrolling + Video ===== -->
    <script>
    /* ===== KORRIGIERTER CMS-Comfort-Patch (Werkzeugleiste + Scrolling + Video) =====
       F√ºgt dem TinyMCE-Editor (#wysiwyg) Komfort-Features hinzu.
       - Skaliere Bilder/Videos: ‚àí / 100% / +, Slider-Dialog, Presets
       - Shortcuts: Ctrl/‚åò+1/2/3/4 (25/50/75/100%), Ctrl/‚åò+Alt+ . / , (¬±10%)
       - Snap-to-Grid (5%) + optionales Grid-Overlay
       - Bonus: Ctrl/‚åò + Mausrad = ¬±5% (schnelles Skalieren)
       - KORRIGIERT: Werkzeugleiste wird korrekt angezeigt
       - KORRIGIERT: Scrolling funktioniert im CMS-Fenster
    */
    (function () {
      // Sanfter Alias, falls dein Button "Medien einf√ºgen" die alte Funktion nutzt:
      if (!window.insertMedia && typeof window.openInsertModal === 'function') {
        window.insertMedia = function(){ openInsertModal(); };
      }

      function enhanceEditor(editor){
        // KORRIGIERT: Sichere Pr√ºfung der Editor-Eigenschaften
        if (!editor || !editor.settings || editor.settings.__telComfortApplied) return;
        editor.settings.__telComfortApplied = true;

        // --- KORRIGIERTES CSS: Editor + Scrolling + Video-Styling ---
        const css = `
          /* Editor-Body: Scrolling korrigieren */
          .mce-content-body{ 
            overflow: auto !important; 
            max-height: none !important; 
            height: auto !important;
          }
          
          /* Medien: Korrekte Darstellung */
          img,video{ 
            max-width:100%; 
            height:auto; 
            display:block; 
            margin:1rem 0; 
          }
          
          /* Video-spezifisch */
          video{ 
            width: 100%; 
            height: auto; 
            min-height: 200px;
            border-radius: 8px;
          }
          
          /* Snap-Grid */
          .mce-content-body.snap-grid{
            background-image:
              linear-gradient(to right, rgba(99,102,241,.12) 1px, transparent 1px),
              linear-gradient(to bottom, rgba(99,102,241,.12) 1px, transparent 1px);
            background-size:20px 20px;
          }
          
          /* Medien-Auswahl */
          .media-selected{ 
            outline:2px dashed #6366f1; 
            outline-offset:2px; 
          }
          
          /* Utility-Klassen */
          .rounded{ border-radius:12px }
          .shadow{ box-shadow: 0 10px 20px rgba(0,0,0,.15) }
          figure{ margin:1rem 0 }
          
          /* KORRIGIERT: CMS-Fenster Scrolling */
          .tox-edit-area{ 
            overflow: visible !important; 
          }
          .tox-edit-area__iframe{ 
            overflow: auto !important; 
          }
          
          /* KORRIGIERT: Endlos scrollbar Canvas */
          .tox-tinymce {
            height: 100% !important;
            max-height: none !important;
          }
          
          .tox-edit-area {
            height: 100% !important;
            max-height: none !important;
          }
          
          .tox-edit-area__iframe {
            height: 100% !important;
            max-height: none !important;
            overflow: auto !important;
          }
          
          .mce-content-body {
            min-height: 100vh !important;
            height: auto !important;
            max-height: none !important;
            overflow: visible !important;
          }
        `;
        
        try { 
          const s = editor.getDoc().createElement('style'); 
          s.textContent = css; 
          editor.getDoc().head.appendChild(s);
        } catch(_) {}

        const SNAP_STEP = 5; // %
        const isMedia = n => !!n && /^(IMG|VIDEO|AUDIO)$/.test(n.nodeName);
        const bodyWidthPx = () => (editor.getBody().clientWidth || 1);
        const snap = p => Math.max(10, Math.min(200, Math.round(p / SNAP_STEP) * SNAP_STEP));

        function getActiveMedia(){
          let n = editor.selection?.getNode();
          if (!n) return null;
          if (n.nodeType === 3) n = n.parentElement;       // Textnode ‚Üí Element
          if (n && n.nodeName === 'SOURCE') n = n.parentElement; // <source> ‚Üí <video>/<audio>
          if (isMedia(n)) return n;
          return n.closest?.('img,video,audio') || null;    // im Wrapper suchen
        }

        function currentPercent(node){
          const styled = parseFloat(node.style.width);
          if (!Number.isNaN(styled)) return styled;
          const px = node.getBoundingClientRect().width;
          return Math.round((px / bodyWidthPx()) * 100);
        }
        function setPercent(node, percent, {respectGrid=true} = {}){
          let p = Math.round(percent);
          if (respectGrid && editor.getBody().classList.contains('snap-grid')) p = snap(p);
          p = Math.max(10, Math.min(200, p));
          node.style.width = p + '%';
          node.style.height = 'auto';
          if (node.nodeName === 'VIDEO' && !node.style.aspectRatio) node.style.aspectRatio = '16/9';
          editor.nodeChanged();
        }

        // KORRIGIERT: Buttons in der TinyMCE-Init registrieren (global scope)
        window.telComfortButtonsRegistered = true;
        
        editor.ui.registry.addButton('scaleMinus', {
          icon: 'zoom-out', 
          tooltip: 'Kleiner (‚àí10%)',
          onAction: () => { 
            const n = getActiveMedia(); 
            if (n) setPercent(n, currentPercent(n)-10); 
          }
        });
        
        editor.ui.registry.addButton('scalePlus', {
          icon: 'zoom-in', 
          tooltip: 'Gr√∂√üer (+10%)',
          onAction: () => { 
            const n = getActiveMedia(); 
            if (n) setPercent(n, currentPercent(n)+10); 
          }
        });
        
        editor.ui.registry.addButton('scaleReset', {
          text: '100%', 
          tooltip: 'Breite 100%',
          onAction: () => { 
            const n = getActiveMedia(); 
            if (n) setPercent(n, 100, {respectGrid:false}); 
          },
          onSetup(api){
            const refresh = () => {
              const n = getActiveMedia();
              api.setText(n ? (currentPercent(n) + '%') : '‚Äî');
            };
            editor.on('NodeChange', refresh);
            editor.on('ObjectResized', refresh);
            refresh();
            return () => { editor.off('NodeChange', refresh); editor.off('ObjectResized', refresh); };
          }
        });

        // Grid Toggle
        editor.ui.registry.addToggleButton('gridToggle', {
          icon: 'table', 
          tooltip: 'Snap-Grid ein/aus (5%)',
          onAction: () => editor.getBody().classList.toggle('snap-grid'),
          onSetup(api){
            const body = editor.getBody();
            const f = () => api.setActive(body.classList.contains('snap-grid'));
            editor.on('init', f); 
            return () => editor.off('init', f);
          }
        });
        
        // KORRIGIERT: scaleDialog Button hinzuf√ºgen
        editor.ui.registry.addButton('scaleDialog', {
          icon: 'preferences',
          tooltip: 'Gr√∂√üe exakt einstellen‚Ä¶',
          onAction: () => {
            const n = getActiveMedia();
            if (n) {
              const initial = currentPercent(n);
              const newWidth = prompt('Neue Breite in % (10-200):', initial);
              if (newWidth && !isNaN(newWidth)) {
                const finalWidth = Math.max(10, Math.min(200, parseFloat(newWidth)));
                setPercent(n, finalWidth, {respectGrid: false});
              }
            }
          }
        });
        
        console.log('‚úÖ CMS-Comfort-Buttons in enhanceEditor registriert');

        // Slider-Dialog
        function openResizeDialog(node){
          if (!isMedia(node)) return;
          const start = currentPercent(node);
          editor.windowManager.open({
            title: 'Gr√∂√üe anpassen',
            body: { type: 'panel', items: [{ type: 'htmlpanel', html: `
              <div style="display:grid;gap:.75rem">
                <label style="display:flex;align-items:center;gap:.5rem">
                  <span style="min-width:4.5rem;opacity:.8">Breite</span>
                  <input id="tel-num" type="number" min="10" max="200" value="${start}" style="width:6rem"> <span>%</span>
                </label>
                <input id="tel-range" type="range" min="10" max="200" value="${start}" step="1">
                <div style="display:flex;gap:.5rem;flex-wrap:wrap">
                  <button data-p="25" class="tox-button">25%</button>
                  <button data-p="50" class="tox-button">50%</button>
                  <button data-p="75" class="tox-button">75%</button>
                  <button data-p="100" class="tox-button">100%</button>
                </div>
                <label style="display:flex;align-items:center;gap:.5rem">
                  <input id="tel-snap" type="checkbox" ${editor.getBody().classList.contains('snap-grid')?'checked':''}>
                  <span>Im Raster einrasten (5%)</span>
                </label>
              </div>`}]},
            buttons: [{type:'cancel',text:'Abbrechen'},{type:'custom',name:'apply',text:'√úbernehmen',primary:true}],
            onAction(api, d){ if (d.name!=='apply') return;
              const doc = api.getEl().ownerDocument;
              let v = parseFloat(doc.getElementById('tel-num').value||start);
              const useSnap = doc.getElementById('tel-snap')?.checked;
              if (useSnap) v = snap(v);
              setPercent(node, v, {respectGrid:false}); api.close(); },
            onShow(api){
              const doc = api.getEl().ownerDocument;
              const num = doc.getElementById('tel-num');
              const rng = doc.getElementById('tel-range');
              const snapBox = doc.getElementById('tel-snap');
              const sync = from => { const v = parseFloat(from.value||start); num.value=v; rng.value=v; setPercent(node, v, {respectGrid: snapBox?.checked}); };
              num.addEventListener('input', ()=>sync(num));
              rng.addEventListener('input', ()=>sync(rng));
              doc.querySelectorAll('[data-p]').forEach(b=>b.addEventListener('click',ev=>{ num.value = ev.currentTarget.getAttribute('data-p'); sync(num); }));
            }
          });
        }

        // Kontext-Toolbar am Element
        editor.ui.registry.addContextToolbar('mediaTools', {
          predicate: () => !!getActiveMedia(),
          items: 'alignleft aligncenter alignright | scaleMinus scaleReset scalePlus | scaleDialog | remove',
          position: 'node', scope: 'node'
        });

        // Markierung + Auto-Korrekturen
        editor.on('NodeChange', () => {
          editor.getBody().querySelectorAll('.media-selected').forEach(el=>el.classList.remove('media-selected'));
          const n = getActiveMedia(); if (n) n.classList.add('media-selected');
        });
        editor.on('ObjectResized', () => {
          const n = getActiveMedia(); if (!n) return;
          n.style.height='auto';
          if (n.nodeName==='VIDEO' && !n.style.aspectRatio) n.style.aspectRatio = '16/9';
          if (editor.getBody().classList.contains('snap-grid')) setPercent(n, currentPercent(n)); // snap
        });

        // Shortcuts
        editor.addShortcut('meta+alt+.', 'Gr√∂√üer (+10%)', () => {
          const n = getActiveMedia(); if (n) setPercent(n, currentPercent(n)+10);
        });
        editor.addShortcut('meta+alt+,', 'Kleiner (‚àí10%)', () => {
          const n = getActiveMedia(); if (n) setPercent(n, currentPercent(n)-10);
        });
        ['1','2','3','4'].forEach((k,i)=>{
          const val=[25,50,75,100][i];
          editor.addShortcut(`meta+${k}`, `${val}%`, () => {
            const n = getActiveMedia(); if (n) setPercent(n, val);
          });
        });

        // Bonus: Ctrl/‚åò + Mausrad ‚Üí ¬±5%
        editor.on('wheel', (e) => {
          if (!(e.ctrlKey || e.metaKey)) return;
          const n = getActiveMedia(); if (!n) return;
          e.preventDefault();
          setPercent(n, currentPercent(n) + (e.deltaY<0 ? 5 : -5));
        });
      }

      // Editor finden & erweitern
      function attach(){
        if (!window.tinymce) return;
        const ed = tinymce.get('wysiwyg');
        if (ed && ed.initialized) return enhanceEditor(ed);
        if (ed) ed.once('init', ()=>enhanceEditor(ed));
      }
      if (window.tinymce) attach();
      // KORRIGIERT: DOMContentLoaded-Listener entfernt (wird zentral behandelt)
      let tries = 0; const iv = setInterval(() => {
        if (++tries>50) return clearInterval(iv);
        if (window.tinymce && tinymce.get('wysiwyg')) { clearInterval(iv); attach(); }
      }, 200);
    })();
    </script>

    <!-- ===== TINYMCE INITIALISIERUNG: Sauber und funktionsf√§hig ===== -->
    <script>
    // √úberschreibe alle vorherigen TinyMCE-Initialisierungen
    (function() {
      if (window.__TEL_TINYMCE_INIT__) return;
      window.__TEL_TINYMCE_INIT__ = true;
      
      function initializeTinyMCE() {
        try {
          // Entferne alte Instanzen
          if (window.tinymce) {
            try {
              window.tinymce.remove('#wysiwyg');
            } catch (e) {
              console.log('Keine alte TinyMCE-Instanz zu entfernen');
            }
          }
          
          if (typeof tinymce === 'undefined') {
            console.error('TinyMCE nicht verf√ºgbar');
            return;
          }
          
          console.log('üöÄ Initialisiere TinyMCE...');
          
          tinymce.init({
            selector: '#wysiwyg',
            plugins: 'lists link image media table code autolink',
            toolbar: 'undo redo | bold italic underline | alignleft aligncenter alignright | bullist numlist | link image media table | code | scaleMinus scaleReset scalePlus',
            menubar: true,
            toolbar_mode: 'wrap',
            height: '82vh',
            object_resizing: 'img,video',
            valid_elements: '*[*]',
            verify_html: false,
            extended_valid_elements: 'video[*],audio[*],source[*],img[*],track[*]',
            content_style: `
              img, video { 
                max-width: 100%; 
                height: auto; 
                display: block; 
                margin: 1rem 0; 
              }
              audio { 
                width: 100%; 
              }
              .mce-content-body { 
                min-height: 100vh; 
                padding: 20px;
              }
            `,
            setup: function(editor) {
              console.log('‚úÖ TinyMCE Editor eingerichtet');
              
              // Prozent-Scaling f√ºr IMG/VIDEO
              const pick = () => {
                let n = editor.selection.getNode(); 
                if (n?.nodeName === 'SOURCE') n = n.parentElement; 
                return /^(IMG|VIDEO)$/.test(n?.nodeName) ? n : null;
              };
              
              const setPct = (n, p) => {
                p = Math.max(10, Math.min(200, Math.round(p))); 
                n.style.width = p + '%'; 
                n.style.height = 'auto'; 
                editor.nodeChanged(); 
              };
              
              // Custom Buttons registrieren
              editor.ui.registry.addButton('scaleMinus', {
                icon: 'zoom-out',
                tooltip: 'Kleiner (‚àí10%)',
                onAction: () => {
                  const n = pick(); 
                  if (n) setPct(n, (parseFloat(n.style.width) || 100) - 10);
                }
              });
              
              editor.ui.registry.addButton('scalePlus', {
                icon: 'zoom-in',
                tooltip: 'Gr√∂√üer (+10%)',
                onAction: () => {
                  const n = pick(); 
                  if (n) setPct(n, (parseFloat(n.style.width) || 100) + 10);
                }
              });
              
              editor.ui.registry.addButton('scaleReset', {
                text: '100%',
                tooltip: 'Breite 100%',
                onAction: () => {
                  const n = pick(); 
                  if (n) setPct(n, 100);
                }
              });
              
              // Wrapper entfernen nach Init
              editor.on('init', () => {
                console.log('‚úÖ TinyMCE Editor initialisiert');
                
                // Wrapper-DIVs entfernen
                editor.getBody().querySelectorAll('[data-file-id] > img,[data-file-id] > video,[data-file-id] > audio').forEach(el => {
                  const host = el.parentElement; 
                  if (host && host !== editor.getBody() && host.childElementCount === 1) {
                    host.replaceWith(el); 
                  }
                });
              });
            }
          });
          
        } catch (error) {
          console.error('‚ùå Fehler bei TinyMCE-Initialisierung:', error);
        }
      }
      
      // Initialisierung starten
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeTinyMCE);
      } else {
        initializeTinyMCE();
      }
      
      // Fallback: Versuche es nach 1 Sekunde nochmal
      setTimeout(initializeTinyMCE, 1000);
      
    })();
    </script>

    <!-- ===== TOOLBAR-FIX: Werkzeugleiste bleibt immer sichtbar ===== -->
    <script>
    // Stellt sicher, dass die TinyMCE-Werkzeugleiste immer sichtbar bleibt
    (function() {
      const style = document.createElement('style');
      style.textContent = `
        .tox-editor-header { 
          position: sticky !important; 
          top: 0 !important; 
          z-index: 9999 !important; 
        }
        .tox .tox-menubar,
        .tox .tox-toolbar,
        .tox .tox-statusbar { 
          display: flex !important; 
          opacity: 1 !important; 
          visibility: visible !important; 
        }
        .tox .tox-menubar { min-height: 30px !important; }
        .tox .tox-toolbar { min-height: 40px !important; }
        .tox .tox-statusbar { min-height: 25px !important; }
        .tox-editor-container { overflow: visible !important; }
      `;
      document.head.appendChild(style);
      
      // Werkzeugleiste alle 2 Sekunden pr√ºfen und wiederherstellen
      setInterval(() => {
        const menubar = document.querySelector('.tox .tox-menubar');
        const toolbar = document.querySelector('.tox .tox-toolbar');
        const statusbar = document.querySelector('.tox .tox-statusbar');
        
        if (menubar && menubar.style.display === 'none') {
          menubar.style.display = 'flex';
          menubar.style.visibility = 'visible';
          menubar.style.opacity = '1';
        }
        
        if (toolbar && toolbar.style.display === 'none') {
          toolbar.style.display = 'flex';
          toolbar.style.visibility = 'visible';
          toolbar.style.opacity = '1';
        }
        
        if (statusbar && statusbar.style.display === 'none') {
          statusbar.style.display = 'flex';
          statusbar.style.visibility = 'visible';
          statusbar.style.opacity = '1';
        }
      }, 2000);
    })();
    </script>

    <!-- ===== SAUBERER EXPORT-FIX: Videos funktionieren garantiert ===== -->
    <script id="tel-export-fix">
    (() => {
      // Schwellwert ab dem ZIP verwendet wird (in MB)
      const ZIP_THRESHOLD_MB = 500;

      // Hilfsfunktionen
      const getEditorHTML = () => (window.tinymce?.get('wysiwyg')?.getContent({
        format:'html', get_inner:false, get_outer:true, no_events:true, no_selection:true
      }) || '').trim();

      const sanitizeName = (name='file') =>
        name.normalize('NFKD').replace(/[^\w.\-]+/g,'_').replace(/^_+|_+$/g,'');

      const asDataURL = (file) => new Promise((res,rej)=>{
        const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file);
      });

      const findFileEntryFor = (el, lib) => {
        console.log('üîç Suche Datei f√ºr Element:', el.tagName, el.getAttribute('src')?.substring(0, 30) + '...');
        
        // 1) √ºber data-file-id (direkt am Element)
        let fileId = el.getAttribute('data-file-id');
        if (fileId) {
          const hit = lib.find(f => f.id === fileId);
          if (hit) {
            console.log('‚úÖ Gefunden √ºber data-file-id:', hit.name);
            return hit;
          }
        }
        
        // 2) √ºber data-file-id in √ºbergeordneten Elementen
        const host = el.closest?.('[data-file-id]');
        if (host) {
          fileId = host.getAttribute('data-file-id');
          const hit = lib.find(f => f.id === fileId);
          if (hit) {
            console.log('‚úÖ Gefunden √ºber √ºbergeordnetes data-file-id:', hit.name);
            return hit;
          }
        }
        
        // 3) √ºber src == objectURL in fileLibrary
        const src = el.getAttribute('src') || '';
        if (src.startsWith('blob:')) {
          const byUrl = lib.find(f => f.url === src);
          if (byUrl) {
            console.log('‚úÖ Gefunden √ºber Blob-URL:', byUrl.name);
            return byUrl;
          }
          
          // 4) √ºber urlCache Map
          if (window.urlCache instanceof Map) {
            for (const [id, url] of window.urlCache) {
              if (url === src) { 
                const hit = lib.find(f => f.id === id);
                if (hit) {
                  console.log('‚úÖ Gefunden √ºber urlCache:', hit.name);
                  return hit;
                }
              }
            }
          }
        }
        
        console.log('‚ùå Keine Datei gefunden f√ºr Element');
        return null;
      };

      // Kern: Export ausf√ºhren
      window.exportWebsite = async function exportWebsite(){
        const raw = getEditorHTML();
        if (!raw) { (window.showNotification||alert)('Keine Inhalte zum Exportieren!'); return; }

        // DOM vorbereiten
        const wrap = document.createElement('div'); wrap.innerHTML = raw;
        // Aufr√§umen (ohne User-Content zu l√∂schen)
        wrap.querySelectorAll('script,style,iframe').forEach(n=>n.remove());

        // Bibliothek (RAM)
        const lib = Array.isArray(window.fileLibrary) ? window.fileLibrary : [];
        console.log('üìö Dateibibliothek Status:', {
          totalFiles: lib.length,
          videos: lib.filter(f => f.type === 'video').length,
          images: lib.filter(f => f.type === 'image').length,
          audio: lib.filter(f => f.type === 'audio').length
        });
        
        // Zeige alle Dateien in der Bibliothek
        if (lib.length > 0) {
          console.log('üìã Alle Dateien in Bibliothek:');
          lib.forEach((file, index) => {
            console.log(`  ${index + 1}. ${file.name} (${file.type}, ${Math.round(file.size / 1024 / 1024 * 100) / 100}MB, ID: ${file.id})`);
          });
        } else {
          console.log('‚ö†Ô∏è Keine Dateien in der Bibliothek gefunden!');
        }

        // Medien einsammeln - verbesserte Suche
        const medias = [...wrap.querySelectorAll('img, audio, video, source')];
        console.log('üîç Gefundene Medien-Elemente:', medias.length);
        
        // Debug: Alle gefundenen Elemente anzeigen
        medias.forEach((el, index) => {
          const src = el.getAttribute('src') || '';
          const fileId = el.getAttribute('data-file-id');
          const tag = el.tagName.toLowerCase();
          console.log(`  ${index + 1}. ${tag}: src="${src.substring(0, 50)}..." fileId="${fileId}"`);
        });

        // Gr√∂√üe absch√§tzen, um Modus zu w√§hlen
        let maxBytes = 0;
        for (const el of medias) {
          const entry = findFileEntryFor(el, lib);
          if (entry?.file?.size) {
            maxBytes = Math.max(maxBytes, entry.file.size);
            console.log(`üìä Datei: ${entry.name}, Gr√∂√üe: ${Math.round(entry.file.size / 1024 / 1024 * 100) / 100}MB`);
          }
        }
        const useZip = maxBytes > ZIP_THRESHOLD_MB * 1024 * 1024;
        console.log(`üéØ Export-Modus: ${useZip ? 'ZIP' : 'Single-HTML'} (Schwellwert: ${ZIP_THRESHOLD_MB}MB, Max: ${Math.round(maxBytes / 1024 / 1024 * 100) / 100}MB)`);

        // Gemeinsame Videopflege: g√ºltige Attribute, Controls
        const normalizeVideos = (root) => {
          root.querySelectorAll('video').forEach(v=>{
            v.setAttribute('controls','');
            v.setAttribute('preload','metadata');
            v.setAttribute('playsinline','');
            // ung√ºltige HTML-Attribute entfernen; Styling per CSS
            v.removeAttribute('width'); 
            v.removeAttribute('height');
            v.style.width='100%';
            v.style.height='auto';
          });
        };

        if (!useZip) {
          // ========= Single-File-HTML: alles inline als Data-URL =========
          for (const el of medias) {
            // Nur BLOB-Quellen oder Elemente ohne src (z.B. <video> mit <source>) verarbeiten
            const tag = el.tagName.toLowerCase();
            const src = el.getAttribute('src') || '';
            const isBlob = src.startsWith('blob:') || (tag==='video' && !src);

            if (!isBlob) continue;
            const entry = findFileEntryFor(el, lib);
            if (!entry?.file) continue;

            const dataUrl = await asDataURL(entry.file);

            if (tag === 'img' || tag === 'audio') {
              el.setAttribute('src', dataUrl);
              console.log(`‚úÖ ${tag.toUpperCase()} konvertiert: ${entry.name} -> Data-URL (${Math.round(dataUrl.length / 1024)}KB)`);
            } else if (tag === 'video') {
              // Sicherstellen, dass <source> existiert und dort setzen
              let s = el.querySelector('source');
              if (!s) { s = document.createElement('source'); el.appendChild(s); }
              s.setAttribute('src', dataUrl);
              s.setAttribute('type', entry.mime || entry.file.type || 'video/mp4');
              el.removeAttribute('src'); // nicht gleichzeitig video@src + <source>
              console.log(`‚úÖ VIDEO konvertiert: ${entry.name} -> Data-URL (${Math.round(dataUrl.length / 1024)}KB)`);
            } else if (tag === 'source') {
              el.setAttribute('src', dataUrl);
              el.setAttribute('type', entry.mime || entry.file.type || '');
              console.log(`‚úÖ SOURCE konvertiert: ${entry.name} -> Data-URL (${Math.round(dataUrl.length / 1024)}KB)`);
            }
          }

          normalizeVideos(wrap);

          // Sauberes HTML-Dokument bauen
          const html = `<!doctype html>
    <html lang="de">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>Export</title>
      <style>
        body{margin:20px;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#111}
        img,video,audio{max-width:100%;height:auto;display:block;border-radius:8px;margin:1rem 0}
        video{min-height:200px;background:#000}
      </style>
    </head>
    <body>
    ${wrap.innerHTML.trim()}
    </body>
    </html>`;

          const blob = new Blob([html], {type:'text/html;charset=utf-8'});
          const url = URL.createObjectURL(blob);
          const a = Object.assign(document.createElement('a'), {href:url, download:'tel-export.html'});
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1500);
          (window.showNotification||console.log)('Export (Single-Datei) fertig ‚úÖ');

        } else {
          // ========= ZIP-Export: index.html + /assets/* =========
          if (typeof JSZip === 'undefined') { alert('JSZip nicht geladen.'); return; }

          const zip = new JSZip();
          const folder = zip.folder('assets');

          // Pfade setzen & Dateien in ZIP legen
          for (const el of medias) {
            const tag = el.tagName.toLowerCase();
            const entry = findFileEntryFor(el, lib);
            if (!entry?.file) continue;

            const base = sanitizeName(entry.name || (entry.file.name || `${entry.id}`));
            const path = `assets/${entry.id}-${base}`;

            if (tag === 'img' || tag === 'audio') {
              el.setAttribute('src', path);
            } else if (tag === 'video') {
              let s = el.querySelector('source');
              if (!s) { s = document.createElement('source'); el.appendChild(s); }
              s.setAttribute('src', path);
              s.setAttribute('type', entry.mime || entry.file.type || 'video/mp4');
              el.removeAttribute('src');
            } else if (tag === 'source') {
              el.setAttribute('src', path);
              el.setAttribute('type', entry.mime || entry.file.type || '');
            }

            // Datei in ZIP ablegen (roh, nicht als Data-URL)
            folder.file(`${entry.id}-${base}`, entry.file);
          }

          normalizeVideos(wrap);

          const index = `<!doctype html>
    <html lang="de">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>Export</title>
      <style>
        body{margin:20px;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#111}
        img,video,audio{max-width:100%;height;auto;display:block;border-radius:8px;margin:1rem 0}
        video{min-height:200px;background:#000}
      </style>
    </head>
    <body>
    ${wrap.innerHTML.trim()}
    </body>
    </html>`;

          zip.file('index.html', index);
          const zblob = await zip.generateAsync({type:'blob'});
          const url = URL.createObjectURL(zblob);
          const a = Object.assign(document.createElement('a'), {href:url, download:'tel-export.zip'});
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1500);
          (window.showNotification||console.log)('Export (ZIP) fertig ‚úÖ');
        }
      };
    })();
    </script>

<!-- ===== TEL FINAL PATCH: reines HTML + eingebettete Medien (ohne Wrapper) ===== -->
<script>
(function(){
  if (window.__TEL_FINAL_PATCH__) return; window.__TEL_FINAL_PATCH__ = true;
  const EDITOR_ID = 'wysiwyg';

  // Schlanke Einbettung OHNE zus√§tzliche Container-DIVs
  window.TEL_renderEmbed = function(meta, url){
    const t = (meta?.type||'').toLowerCase();
    const idAttr = meta?.id ? ` data-file-id="${meta.id}"` : '';
    const mime = meta?.mime || meta?.file?.type;
    const alt  = (meta?.name||'').replace(/"/g,'&quot;');

    if (t==='image')
      return `<img src="${url}" alt="${alt}" style="width:100%;height:auto;"${idAttr} data-mce-blob-uri="${url}">`;
    if (t==='video')
      return `<video controls preload="metadata" playsinline style="width:100%;height:auto;"${idAttr} data-mce-blob-uri="${url}">
                <source src="${url}" type="${mime||'video/mp4'}">
              </video>`;
    if (t==='audio')
      return `<audio controls preload="metadata" style="width:100%;"${idAttr} data-mce-blob-uri="${url}">
                <source src="${url}" type="${mime||'audio/mpeg'}">
              </audio>`;
    return `<a href="${url}"${idAttr}>${alt||url}</a>`;
  };
  // Alle √§lteren Varianten √ºberschreiben
  window.renderEmbed = window.TEL_renderEmbed;

  // Alte Wrapper (figure/div[data-file-id]/div.media‚Ä¶) entfernen
  function unwrapLegacyMedia(root){
    root.querySelectorAll('div[data-file-id], figure.media, div[class*="media"]').forEach(w=>{
      const c = w.children && w.children.length===1 ? w.children[0] : null;
      if (c && /^(IMG|VIDEO|AUDIO)$/i.test(c.nodeName)) w.replaceWith(c);
    });
  }

  async function fileToDataURL(file){
    return await new Promise((res,rej)=>{
      const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file);
    });
  }

  // Reiner HTML-Export: konvertiert blob: ‚Üí data: (Bilder/Audio/Video)
  window.exportWebsite = async function(){
    const ed = window.tinymce?.get(EDITOR_ID);
    if (!ed) { alert('Editor nicht bereit'); return; }

    const wrap = document.createElement('div');
    wrap.innerHTML = ed.getContent({format:'html'});
    unwrapLegacyMedia(wrap);

    const lib   = Array.isArray(window.fileLibrary) ? window.fileLibrary : [];
    const cache = window.urlCache instanceof Map ? window.urlCache : new Map();

    const nodes = wrap.querySelectorAll('img, video, audio, source');
    for (const el of nodes){
      const tag = el.tagName.toLowerCase();
      const src = el.getAttribute('src'); if (!src || !/^blob:/.test(src)) continue;

      // Datei zuordnen: data-file-id ‚Üí fileLibrary ‚Üí urlCache
      let entry = null;
      const fid = el.getAttribute('data-file-id') || el.closest('[data-file-id]')?.getAttribute('data-file-id');
      if (fid) entry = lib.find(f=>f.id===fid);
      if (!entry) entry = lib.find(f=>f.url===src);
      if (!entry) { for (const [id,url] of cache) { if (url===src) { entry = lib.find(f=>f.id===id); break; } } }
      if (!entry || !entry.file) continue;

      const dataUrl = await fileToDataURL(entry.file);
      el.setAttribute('src', dataUrl);
      // Falls <video> kein <source> hat, erg√§nzen
      if (tag==='video' && !el.querySelector('source')) {
        const s = document.createElement('source');
        s.setAttribute('src', dataUrl);
        s.setAttribute('type', entry.mime || entry.file?.type || 'video/mp4');
        el.appendChild(s);
      }
    }

    // TinyMCE-Artefakte entfernen
    wrap.querySelectorAll('[contenteditable],[data-mce-selected],[data-mce-href]').forEach(n=>{
      n.removeAttribute('contenteditable'); n.removeAttribute('data-mce-selected'); n.removeAttribute('data-mce-href');
    });
    wrap.querySelectorAll('*').forEach(n=>{
      [...n.getAttributeNames()].forEach(a=>{ if(a.startsWith('data-mce-')) n.removeAttribute(a); });
    });

    const html = `<!doctype html><html lang="de"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Export</title>
<style>
  html,body{margin:0;padding:20px;font-family:system-ui;line-height:1.6}
  img,video,audio{max-width:100%;height:auto;display:block;border-radius:8px;margin:1rem 0}
  video{width:100%;min-height:200px}
</style></head><body>${wrap.innerHTML.trim()}</body></html>`;

    const blob = new Blob([html], {type:'text/html;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), {href:url, download:'index.html'});
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  };

  // Toolbar immer sichtbar + Editor hoch
  const css = document.createElement('style');
  css.textContent = '.tox .tox-menubar,.tox .tox-toolbar,.tox .tox-statusbar{display:flex!important;visibility:visible!important;opacity:1!important}.tox-editor-header{position:sticky;top:0;z-index:5}.mce-content-body{min-height:100vh!important}';
  document.head.appendChild(css);
})();
</script>
<!-- ===== /TEL FINAL PATCH ===== -->

<!-- TEL ‚Äì FINAL FIX-PACK: echte <img>/<video>, Prozent-Gr√∂√üe & stabiler Export -->
<script>
(function(){
  if (window.__TEL_FINAL_FIX__) return; window.__TEL_FINAL_FIX__=true;
  
  console.log('üöÄ TEL FINAL FIX-PACK wird geladen...');

  /* 1) renderEmbed: robust f√ºr image/*, video/*, audio/*  */
  window.renderEmbed = function(meta, url){
    const type = (meta?.mime || meta?.type || '').toLowerCase();
    const safeAlt = (meta?.name || '').replace(/"/g,'&quot;');
    const fid = meta?.id ? ` data-file-id="${meta.id}"` : '';

    console.log('üé® renderEmbed aufgerufen:', { type, name: meta?.name, id: meta?.id });

    if (type.startsWith('image')) {
      return `<img src="${url}" alt="${safeAlt}" style="width:100%;height:auto;"${fid}>`;
    }
    if (type.startsWith('video')) {
      const mime = type.includes('/') ? type : (meta?.mime || 'video/mp4');
      return `<video controls preload="metadata" playsinline style="width:100%;height:auto;"${fid}>
                <source src="${url}" type="${mime}">
              </video>`;
    }
    if (type.startsWith('audio')) {
      const mime = type.includes('/') ? type : (meta?.mime || 'audio/mpeg');
      return `<audio controls preload="metadata" style="width:100%;"${fid}>
                <source src="${url}" type="${mime}">
              </audio>`;
    }
    return `<a href="${url}">${safeAlt || url}</a>`;
  };

  /* Wrapper alter Inhalte entfernen (verhindert ‚ÄûDIV-Kachel" im Editor/Export) */
  window.unwrapLegacyMedia = function(root){
    (root||document).querySelectorAll('div[class*="media"],div[data-file-id],figure.media').forEach(node=>{
      if (node.children.length === 1 && /^(IMG|VIDEO|AUDIO)$/i.test(node.children[0].tagName)) {
        node.replaceWith(node.children[0]);
      }
    });
  };

  /* 2) Export: wandelt alle Medien sicher in Data-URLs um (auch <source>) */
  window.exportWebsiteFinal = async function(){
    console.log('üì§ exportWebsiteFinal (GEPATCHT) wird aufgerufen...');
    
    try {
      // NEU: Verwende sichere Editor-Inhalt-Funktion
      const editorHtml = getEditorInnerHtmlSafe();
      
      if (!editorHtml || !editorHtml.trim()) { 
        console.error('‚ùå Keine Inhalte zum Exportieren!');
        (window.showNotification||alert)('Keine Inhalte zum Exportieren!'); 
        return; 
      }

      console.log('üìù Editor-Inhalt (sicher):', editorHtml.substring(0, 200) + '...');
      
      // DOM bauen
      const doc = new DOMParser().parseFromString(editorHtml, 'text/html');
      
      // Scripts/Styles/Iframes entfernen
      doc.querySelectorAll('script,style,iframe').forEach(n=>n.remove());
      
      if (typeof window.unwrapLegacyMedia==='function') {
        console.log('üßπ Entferne Legacy-Wrapper...');
        window.unwrapLegacyMedia(doc.body);
      }

      // NEU: Konvertiere alle Blob-URLs zu Data-URLs VOR dem Patchen
      console.log('üîÑ Konvertiere Blob-URLs zu Data-URLs...');
      try {
        await inlineAllMediaToDataURLs(doc);
        console.log('‚úÖ Alle Medien erfolgreich inline konvertiert!');
      } catch (e) {
        console.warn('‚ö†Ô∏è Media-Inlining fehlgeschlagen:', e);
        // Trotzdem weitermachen - vielleicht sind keine Blobs vorhanden
      }

      // NEU: Verwende buildPatchedExport f√ºr bessere Page-View Kompatibilit√§t
      console.log('üîß Wende Page-View Patches an...');
      const staticOnly = document.getElementById('ckStaticExport')?.checked || false;
      const finalHtml = buildPatchedExport(doc.body.innerHTML, { 
        title: "TEL Export - Gepatcht", 
        staticOnly: staticOnly 
      });

      // Datei speichern
      console.log('üíæ Erstelle gepatchte Export-Datei...');
      const blob = new Blob([finalHtml], {type:'text/html;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'export_patched.html';
      a.click();
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Gepatchter Export abgeschlossen!');
      (window.showNotification||alert)('Gepatchter Export erfolgreich! Alle Page-View Patches angewendet.');
      
    } catch (e) {
      console.error('‚ùå Export-Fehler:', e);
      (window.showNotification||alert)('Export fehlgeschlagen: ' + e.message);
    }
  };

  /* 3) ZIP Export: F√ºr gro√üe Medien-Dateien (HTML + Assets-Ordner) */
  window.exportWebsiteZIP = async function(){
    console.log('üì¶ ZIP Export wird aufgerufen...');
    
    try {
      // NEU: Verwende sichere Editor-Inhalt-Funktion
      const editorHtml = getEditorInnerHtmlSafe();
      
      if (!editorHtml || !editorHtml.trim()) { 
        console.error('‚ùå Keine Inhalte zum Exportieren!');
        (window.showNotification||alert)('Keine Inhalte zum Exportieren!'); 
        return; 
      }

      const lib = Array.isArray(window.fileLibrary) ? window.fileLibrary : [];
      console.log('üìö Dateibibliothek f√ºr ZIP:', lib.length, 'Dateien gefunden');
      
      if (lib.length === 0) {
        console.warn('‚ö†Ô∏è Keine Dateien in der Bibliothek - verwende normalen Export');
        return exportWebsiteFinal();
      }

      // Erstelle ZIP mit HTML + Assets-Ordner
      const zip = new JSZip();
      
      // 1) HTML-Datei (mit relativen Pfaden)
      const htmlDoc = new DOMParser().parseFromString(editorHtml, 'text/html');
      
      // Scripts/Styles/Iframes entfernen
      htmlDoc.querySelectorAll('script,style,iframe').forEach(n=>n.remove());
      
      if (typeof window.unwrapLegacyMedia==='function') {
        console.log('üßπ Entferne Legacy-Wrapper...');
        window.unwrapLegacyMedia(htmlDoc.body);
      }
      
      // 2) Alle Medien in Assets-Ordner verschieben und Pfade anpassen
      const mediaElements = htmlDoc.querySelectorAll('img[src], video[src], audio[src], source[src], video[poster]');
      console.log(`üîÑ Verarbeite ${mediaElements.length} Medien-Elemente f√ºr ZIP...`);
      
      let assetCounter = 0;
      for (const el of mediaElements) {
        const src = el.getAttribute('src') || el.getAttribute('poster');
        if (!src) continue;
        
        try {
          let file = null;
          
          // Versuche Datei √ºber verschiedene Wege zu finden
          if (src.startsWith('blob:')) {
            // √úber fetch
            try {
              const response = await fetch(src);
              if (response.ok) {
                file = await response.blob();
              }
            } catch (e) {
              // √úber data-file-id
              const fileId = el.getAttribute('data-file-id');
              if (fileId && lib.length > 0) {
                const item = lib.find(f => f.id === fileId);
                if (item?.file) file = item.file;
              }
            }
          }
          
          if (file) {
            assetCounter++;
            const ext = getFileExtension(file.name || 'file');
            const assetName = `asset_${assetCounter}.${ext}`;
            const assetPath = `assets/${assetName}`;
            
            // F√ºge Datei zum ZIP hinzu
            zip.file(assetPath, file);
            
            // Passe HTML-Pfad an
            if (el.hasAttribute('src')) {
              el.setAttribute('src', assetPath);
            }
            if (el.hasAttribute('poster')) {
              el.setAttribute('poster', assetPath);
            }
            
            console.log(`‚úÖ ${assetName} hinzugef√ºgt`);
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Fehler beim Verarbeiten von:', src, e);
        }
      }
      
      // 3) Finales HTML mit Page-View Patches
      const staticOnly = document.getElementById('ckStaticExport')?.checked || false;
      const finalHtml = buildPatchedExport(htmlDoc.body.innerHTML, {
        title: "TEL Export - ZIP (Gepatcht)",
        staticOnly: staticOnly
      });
      
      zip.file('index.html', finalHtml);
      
      // 4) ZIP erstellen und herunterladen
      console.log('üíæ Erstelle ZIP-Archiv...');
      const zipBlob = await zip.generateAsync({type: 'blob'});
      
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tel-export-${new Date().toISOString().slice(0,10)}.zip`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ ZIP Export abgeschlossen!', assetCounter, 'Assets verpackt');
      (window.showNotification||alert)(`ZIP Export erfolgreich! ${assetCounter} Medien-Dateien + HTML verpackt.`);
      
    } catch (e) {
      console.error('‚ùå ZIP Export fehlgeschlagen:', e);
      (window.showNotification||alert)('ZIP Export fehlgeschlagen: ' + e.message);
    }
  };

  // Hilfsfunktion f√ºr Dateiendungen
  function getFileExtension(filename) {
    return filename.split('.').pop().toLowerCase() || 'bin';
  }

  /* 4) Debug-Funktion: Diagnose der Media Library und Blob-URLs */
  window.debugMediaLibrary = function(){
    console.log('üîç Debug: Media Library Status');
    console.log('================================');
    
    // 1) fileLibrary Status
    const lib = window.fileLibrary || [];
    console.log(`üìö fileLibrary: ${lib.length} Eintr√§ge`);
    if (lib.length > 0) {
      lib.forEach((item, i) => {
        console.log(`  ${i+1}. ${item.name || 'Unbekannt'} (${item.id || 'keine ID'})`);
        console.log(`     Typ: ${item.type || 'unbekannt'}, Gr√∂√üe: ${item.size || 'unbekannt'}`);
        console.log(`     File: ${item.file ? '‚úÖ' : '‚ùå'}, URL: ${item.url ? '‚úÖ' : '‚ùå'}`);
        if (item.url) console.log(`     URL-Typ: ${item.url.startsWith('blob:') ? 'blob:' : 'anders'}`);
      });
    } else {
      console.log('  ‚ùå fileLibrary ist leer!');
    }
    
    // 2) urlCache Status
    const urlCache = window.urlCache;
    if (urlCache && urlCache instanceof Map) {
      console.log(`üîó urlCache: ${urlCache.size} Eintr√§ge`);
      for (const [key, url] of urlCache.entries()) {
        console.log(`  ${key} ‚Üí ${url.substring(0, 50)}...`);
      }
    } else {
      console.log('  ‚ùå urlCache nicht verf√ºgbar oder kein Map');
    }
    
    // 3) Editor-Inhalt analysieren
    const ed = window.tinymce?.get('wysiwyg');
    if (ed) {
      const content = ed.getContent();
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      
      const images = tempDiv.querySelectorAll('img');
      const videos = tempDiv.querySelectorAll('video');
      const audios = tempDiv.querySelectorAll('audio');
      const sources = tempDiv.querySelectorAll('source');
      
      console.log(`üìù Editor-Inhalt: ${images.length} Bilder, ${videos.length} Videos, ${audios.length} Audio, ${sources.length} Sources`);
      
      // Blob-URLs im Editor finden
      const blobUrls = [];
      const allMedia = [...images, ...videos, ...audios, ...sources];
      allMedia.forEach(el => {
        const src = el.getAttribute('src') || el.getAttribute('poster');
        if (src && src.startsWith('blob:')) {
          blobUrls.push({
            element: el.tagName,
            src: src,
            dataFileId: el.getAttribute('data-file-id')
          });
        }
      });
      
      if (blobUrls.length > 0) {
        console.log(`‚ö†Ô∏è ${blobUrls.length} Blob-URLs im Editor gefunden:`);
        blobUrls.forEach((item, i) => {
          console.log(`  ${i+1}. <${item.element}> src="${item.src.substring(0, 30)}..." data-file-id="${item.dataFileId || 'keine'}"`);
        });
      } else {
        console.log('  ‚úÖ Keine Blob-URLs im Editor gefunden');
      }
    } else {
      console.log('  ‚ùå TinyMCE Editor nicht verf√ºgbar');
    }
    
    // 4) Speicher-Status
    try {
      const localStorageSize = JSON.stringify(localStorage).length;
      console.log(`üíæ LocalStorage: ${(localStorageSize / 1024).toFixed(2)} KB`);
    } catch (e) {
      console.log('  ‚ùå LocalStorage blockiert:', e.message);
    }
    
    try {
      const sessionStorageSize = JSON.stringify(sessionStorage).length;
      console.log(`üíæ SessionStorage: ${(sessionStorageSize / 1024).toFixed(2)} KB`);
    } catch (e) {
      console.log('  ‚ùå SessionStorage blockiert:', e.message);
    }
    
    console.log('================================');
    console.log('üí° Tipps:');
    console.log('  - Wenn fileLibrary leer ist: Dateien neu hochladen');
    console.log('  - Wenn Blob-URLs vorhanden: Export funktioniert nur in derselben Session');
    console.log('  - ZIP Export ist robuster f√ºr gro√üe Medien-Dateien');
    
    // Benachrichtigung anzeigen
    (window.showNotification||alert)(`Debug abgeschlossen! Siehe Console f√ºr Details.`);
  };

    /* 5) Page View: Echte Vorschau im neuen Tab (ohne Download) */
  /* === OPEN PAGE VIEW (SINGLE SOURCE OF TRUTH) === */
  window.openPageView = async function({ title = "TEL Page View - Vorschau", staticOnly = false } = {}){
    try {
      console.log('üëÅÔ∏è Page View wird ge√∂ffnet...');

      // 1) Editor-Inhalt sicher holen
      const editorHtml = (typeof getEditorInnerHtmlSafe === 'function')
        ? getEditorInnerHtmlSafe()
        : (document.querySelector('#cms .cms-editor')?.innerHTML || '');
      if (!editorHtml || !editorHtml.trim()) {
        (window.showNotification||alert)('Keine Inhalte f√ºr Page View!');
        return;
      }

      // 2) OPTIONAL: aggressives Aufr√§umen (nur wenn gew√ºnscht)
      const doc = new DOMParser().parseFromString(editorHtml, 'text/html');
      // Falls du Iframes behalten willst -> die n√§chste Zeile AUSKOMMENTIEREN:
      // doc.querySelectorAll('iframe').forEach(n => n.remove());
      // Skripte entfernen, um Preview ‚Äûruhig" zu halten:
      doc.querySelectorAll('script').forEach(n => n.remove());
      // Styles nur entfernen, wenn wirklich n√∂tig:
      // doc.querySelectorAll('style:not(#force-visible)').forEach(n => n.remove());

      // 3) Medien inline konvertieren (blob: ‚Üí data:)
      console.log('üîÑ Konvertiere Blob-URLs zu Data-URLs (Page View)‚Ä¶');
      try { await inlineAllMediaToDataURLs(doc); } catch(e){ console.warn('‚ö†Ô∏è Media-Inlining:', e); }

      // 4) Patches/CSP anwenden und finales HTML bauen
      const inner = doc.body ? doc.body.innerHTML : doc.documentElement.innerHTML;
      const finalHtml = buildPatchedExport(inner, { title, staticOnly: !!staticOnly });

      // 5) Robust √∂ffnen (Tab/Link/Same-Tab/Overlay)
      openPreviewRobust(finalHtml);

      console.log('‚úÖ Page View ge√∂ffnet.');
    } catch (e) {
      console.error('‚ùå Page View Fehler:', e);
      (window.showNotification||alert)('Page View fehlgeschlagen: ' + (e && e.message ? e.message : e));
    }
  };

  /* 6) Full Site View: Komplette aktuelle Seite (ohne Editor-UI) in neuem Tab */
  /* === OPEN FULL SITE VIEW (SINGLE SOURCE OF TRUTH) === */
  window.openFullSiteView = async function(){
    try {
      console.log('üåê Full Site View wird ge√∂ffnet...');

      // 1) Aktuelle Seite klonen (ohne CMS-UI)
      const clone = document.cloneNode(true);

      // 2) CMS-/Editor-UI entfernen
      const selectors = [
        '#cms','.cms-editor','.file-management-panel','.presentation-mode',
        'script[src*="tinymce"]','script[src*="jszip"]',
        // Entferne NUR Scripts, die Preview st√∂ren:
        'script:not([id*="PAGEVIEW_BOOTSTRAP"])'
        // 'style:not([id="force-visible"])' // nur wenn gewollt
      ];
      selectors.forEach(sel => clone.querySelectorAll(sel).forEach(n => n.remove()));

      // 3) Medien inline konvertieren (blob: ‚Üí data:)
      console.log('üîÑ Konvertiere Blob-URLs zu Data-URLs (Full Site)‚Ä¶');
      try { await inlineAllMediaToDataURLs(clone); } catch(e){ console.warn('‚ö†Ô∏è Media-Inlining:', e); }

      // 4) Finales HTML bauen (CSP/Meta/Head via buildPatchedExport)
      const inner = clone.body ? clone.body.innerHTML : clone.documentElement.innerHTML;
      const finalHtml = buildPatchedExport(inner, {
        title: 'TEL & Gently Overdone - Full Site View',
        staticOnly: false
      });

      // 5) Robust √∂ffnen
      openPreviewRobust(finalHtml);

      console.log('‚úÖ Full Site View ge√∂ffnet.');
    } catch (e) {
      console.error('‚ùå Full Site View Fehler:', e);
      (window.showNotification||alert)('Full Site View fehlgeschlagen: ' + (e && e.message ? e.message : e));
    }
  };

  /* 3) Toolbar & Editor-H√∂he stabil halten */
  const css=document.createElement('style');
  css.textContent = `
    .tox .tox-menubar,.tox .tox-toolbar,.tox .tox-statusbar{display:flex!important;visibility:visible!important;opacity:1!important}
    .tox-editor-header{position:sticky;top:0;z-index:9999}
    .mce-content-body{min-height:100vh!important}
  `;
  document.head.appendChild(css);
  
  console.log('‚úÖ TEL FINAL FIX-PACK geladen!');
})();

/* === PREVIEW HELPERS START === */
/** In-Page Overlay (Fallback), falls neue Tabs blockiert sind */
function openInPageOverlay(finalHtml){
  const wrap  = document.createElement('div');
  wrap.style  = 'position:fixed;inset:0;z-index:999999;background:#fff';
  const close = document.createElement('button');
  close.textContent = '√ó schlie√üen';
  close.style = 'position:fixed;right:12px;top:12px;z-index:1000000;padding:.5rem 1rem';
  const frame = document.createElement('iframe');
  frame.setAttribute('sandbox','allow-same-origin allow-scripts allow-popups allow-forms allow-pointer-lock');
  frame.style = 'width:100%;height:100%;border:0';
  frame.srcdoc = "<!doctype html>\n" + finalHtml;
  close.onclick = () => wrap.remove();
  wrap.append(frame, close);
  document.body.appendChild(wrap);
}

/** Robuster √ñffnen-Flow: New-Tab ‚Üí Link-Fallback ‚Üí Same-Tab ‚Üí Overlay */
function openPreviewRobust(finalHtml){
  // 1) Blob-URL vorbereiten
  const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
  const url  = URL.createObjectURL(blob);

  // 2) Prim√§r: direktes New-Tab
  const win = window.open(url, '_blank', 'noopener,noreferrer');
  if (win) { setTimeout(() => URL.revokeObjectURL(url), 60_000); return; }

  // 3) Fallback A: programmatischer Link-Klick (oft nicht als Popup gewertet)
  const a = document.createElement('a');
  a.href = url; a.target = '_blank'; a.rel = 'noopener';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 60_000);

  // 4) Fallback B: Same-Tab Navigation (nie Popup)
  try { location.assign(url); return; } catch(_) {}

  // 5) Fallback C: In-Page Overlay
  openInPageOverlay(finalHtml);
}
/* === PREVIEW HELPERS END === */
</script>

    </body>
</html>
