<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- ğŸ”’ SECURITY: Content Security Policy (OCR + WASM kompatibel!) -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://cdn.sheetjs.com blob: data:; worker-src 'self' blob: data:; child-src 'self' blob:; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' data: blob: https://api.coingecko.com https://pro-api.coinmarketcap.com https://api.binance.com https://api.openai.com https://sandbox.finapi.io https://ob.nordigen.com https://cdn.jsdelivr.net; font-src 'self' data:; object-src 'none'; base-uri 'self'; form-action 'self'; upgrade-insecure-requests;">
    
    <title>ğŸ’° TEL Haushaltsbuch 2025 - Professional Edition</title>
    <!-- ECHTE Libraries via CDN - fallback to offline if needed -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js" crossorigin="anonymous"></script>
    <!-- CryptoJS fÃ¼r ECHTE VerschlÃ¼sselung -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #FF6B35;
            --secondary: #8B5CF6;
            --success: #10B981;
            --warning: #F59E0B;
            --danger: #EF4444;
            --dark: #0f1419;
            --light: #F3F4F6;
            --text: #1F2937;
            --border: #E5E7EB;
            --gradient: linear-gradient(135deg, #FF6B35 0%, #8B5CF6 100%);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: var(--gradient);
            padding: 30px;
            color: white;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header .subtitle {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .nav {
            background: var(--dark);
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .nav-btn {
            background: transparent;
            border: none;
            color: white;
            padding: 15px 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .nav-btn.active {
            border-bottom-color: var(--primary);
            background: rgba(255,255,255,0.05);
        }

        .content {
            padding: 30px;
            min-height: 600px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border-left: 5px solid var(--primary);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }

        .card.success { border-left-color: var(--success); }
        .card.warning { border-left-color: var(--warning); }
        .card.danger { border-left-color: var(--danger); }
        .card.secondary { border-left-color: var(--secondary); }

        .card-title {
            font-size: 0.9em;
            color: #6B7280;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-change {
            font-size: 0.85em;
            color: var(--success);
        }

        .card-change.negative {
            color: var(--danger);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            background: var(--gradient);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255,107,53,0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,107,53,0.4);
        }

        .btn-secondary {
            background: var(--secondary);
            box-shadow: 0 4px 15px rgba(139,92,246,0.3);
        }

        .btn-success {
            background: var(--success);
            box-shadow: 0 4px 15px rgba(16,185,129,0.3);
        }

        .btn-danger {
            background: var(--danger);
            box-shadow: 0 4px 15px rgba(239,68,68,0.3);
        }

        .transaction-list {
            margin-top: 30px;
        }

        .transaction-item {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-left: 4px solid var(--primary);
            transition: all 0.3s;
        }

        .transaction-item:hover {
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transform: translateX(5px);
        }

        .transaction-item.income {
            border-left-color: var(--success);
        }

        .transaction-item.expense {
            border-left-color: var(--danger);
        }

        .transaction-info h3 {
            margin-bottom: 5px;
            color: var(--text);
        }

        .transaction-info .meta {
            color: #6B7280;
            font-size: 0.9em;
        }

        .transaction-amount {
            font-size: 1.5em;
            font-weight: bold;
        }

        .transaction-amount.income {
            color: var(--success);
        }

        .transaction-amount.expense {
            color: var(--danger);
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 30px;
            position: relative;
            height: 400px;
        }

        .ai-chat {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 25px;
            color: white;
            margin-bottom: 30px;
        }

        .ai-chat-messages {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .ai-message {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
        }

        .ai-message.user {
            background: rgba(255,107,53,0.3);
            text-align: right;
        }

        .ai-input-group {
            display: flex;
            gap: 10px;
        }

        .ai-input-group input {
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
        }

        .budget-bar {
            background: var(--border);
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin-top: 10px;
        }

        .budget-fill {
            background: var(--gradient);
            height: 100%;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        .budget-fill.over {
            background: linear-gradient(135deg, var(--danger) 0%, var(--warning) 100%);
        }

        .filter-bar {
            background: var(--light);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-bar select,
        .filter-bar input {
            padding: 10px 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.95em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-box {
            background: linear-gradient(135deg, rgba(255,107,53,0.1) 0%, rgba(139,92,246,0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-box .label {
            color: #6B7280;
            font-size: 0.9em;
        }

        .crypto-widget {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .crypto-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .category-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            margin-right: 5px;
        }

        .badge-lebensmittel { background: #FEF3C7; color: #92400E; }
        .badge-miete { background: #DBEAFE; color: #1E40AF; }
        .badge-freizeit { background: #FCE7F3; color: #9F1239; }
        .badge-auto { background: #D1FAE5; color: #065F46; }
        .badge-gesundheit { background: #E0E7FF; color: #3730A3; }
        .badge-sonstiges { background: #F3F4F6; color: #374151; }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6B7280;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .close-modal {
            float: right;
            font-size: 1.5em;
            cursor: pointer;
            color: #6B7280;
            transition: color 0.3s;
        }

        .close-modal:hover {
            color: var(--danger);
        }

        .achievement {
            background: linear-gradient(135deg, #FBBF24 0%, #F59E0B 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .achievement-icon {
            font-size: 2em;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .nav-btn {
                padding: 12px 15px;
                font-size: 0.9em;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }

            .filter-bar {
                flex-direction: column;
                align-items: stretch;
            }

            .card-value {
                font-size: 1.5em;
            }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 2000;
            animation: slideInRight 0.5s;
            max-width: 400px;
        }

        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.success { border-left: 5px solid var(--success); }
        .notification.error { border-left: 5px solid var(--danger); }
        .notification.warning { border-left: 5px solid var(--warning); }

        .progress-bar {
            background: var(--border);
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            background: var(--gradient);
            height: 100%;
            transition: width 0.5s;
        }

        canvas {
            max-width: 100%;
            height: auto !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ’° TEL Haushaltsbuch 2025</h1>
            <p class="subtitle">Professional Financial Management System | Â© Raymond Demitrio Dr. Tel</p>
        </div>

            <nav class="nav">
            <button class="nav-btn active" onclick="switchSection('dashboard')">ğŸ“Š Dashboard</button>
            <button class="nav-btn" onclick="switchSection('transactions')">ğŸ’³ Transaktionen</button>
            <button class="nav-btn" onclick="switchSection('budgets')">ğŸ¯ Budgets</button>
            <button class="nav-btn" onclick="switchSection('analytics')">ğŸ“ˆ Analysen</button>
            <button class="nav-btn" onclick="switchSection('accounts')">ğŸ¦ Konten</button>
            <button class="nav-btn" onclick="switchSection('crypto')">â‚¿ Krypto</button>
            <button class="nav-btn" onclick="switchSection('banking')">ğŸ¦ Open Banking</button>
            <button class="nav-btn" onclick="switchSection('receipts')">ğŸ§¾ Belege & OCR</button>
            <button class="nav-btn" onclick="switchSection('ai')">ğŸ¤– AI-Assistent</button>
            <button class="nav-btn" onclick="switchSection('settings')">âš™ï¸ Einstellungen</button>
        </nav>

        <div class="content">
            <!-- DASHBOARD SECTION -->
            <section id="dashboard" class="section active">
                <h2 style="margin-bottom: 25px;">ğŸ“Š Finanz-Dashboard</h2>
                
                <div class="dashboard">
                    <div class="card success">
                        <div class="card-title">ğŸ’° Gesamtsaldo</div>
                        <div class="card-value" id="total-balance">0,00 â‚¬</div>
                        <div class="card-change" id="balance-change">+0,00 â‚¬ (0%)</div>
                    </div>

                    <div class="card">
                        <div class="card-title">ğŸ“¥ Einnahmen (Monat)</div>
                        <div class="card-value" id="monthly-income">0,00 â‚¬</div>
                        <div class="card-change" id="income-change">+0,00 â‚¬ (0%)</div>
                    </div>

                    <div class="card danger">
                        <div class="card-title">ğŸ“¤ Ausgaben (Monat)</div>
                        <div class="card-value" id="monthly-expenses">0,00 â‚¬</div>
                        <div class="card-change negative" id="expense-change">-0,00 â‚¬ (0%)</div>
                    </div>

                    <div class="card secondary">
                        <div class="card-title">ğŸ’ Sparpotenzial</div>
                        <div class="card-value" id="savings-potential">0,00 â‚¬</div>
                        <div class="card-change" id="savings-change">ğŸ¯ Ziel: 20%</div>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="overview-chart"></canvas>
                </div>

                <h3 style="margin: 30px 0 15px 0;">âš¡ Schnellaktion</h3>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <button class="btn" onclick="showAddTransaction('expense')">â• Ausgabe hinzufÃ¼gen</button>
                    <button class="btn btn-success" onclick="showAddTransaction('income')">â• Einnahme hinzufÃ¼gen</button>
                    <button class="btn btn-secondary" onclick="switchSection('ai')">ğŸ¤– AI-Analyse starten</button>
                </div>

                <h3 style="margin: 30px 0 15px 0;">ğŸ† Achievements & Gamification</h3>
                <div id="achievements-container">
                    <!-- Achievements werden dynamisch geladen -->
                </div>
                <div style="margin-top: 15px;">
                    <div class="progress-bar">
                        <div id="level-progress" class="progress-fill" style="width: 0%;"></div>
                    </div>
                    <p id="level-text" style="margin-top: 10px; text-align: center; font-weight: bold;">Level 1 - Finanz-AnfÃ¤nger</p>
                </div>
            </section>

            <!-- TRANSACTIONS SECTION -->
            <section id="transactions" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ’³ Transaktionen</h2>

                <div class="filter-bar">
                    <select id="filter-type" onchange="filterTransactions()">
                        <option value="all">Alle Typen</option>
                        <option value="income">Einnahmen</option>
                        <option value="expense">Ausgaben</option>
                    </select>

                    <select id="filter-category" onchange="filterTransactions()">
                        <option value="all">Alle Kategorien</option>
                        <option value="lebensmittel">Lebensmittel</option>
                        <option value="miete">Miete</option>
                        <option value="freizeit">Freizeit</option>
                        <option value="auto">Auto</option>
                        <option value="gesundheit">Gesundheit</option>
                        <option value="gehalt">Gehalt</option>
                        <option value="sonstiges">Sonstiges</option>
                    </select>

                    <input type="month" id="filter-month" onchange="filterTransactions()" value="">

                    <input type="search" id="search-transactions" placeholder="ğŸ” Suchen..." onkeyup="filterTransactions()">

                    <button class="btn btn-success" onclick="showAddTransaction('expense')">â• Neue Transaktion</button>
                </div>

                <div id="transactions-list" class="transaction-list">
                    <!-- Transactions will be rendered here -->
                </div>
            </section>

            <!-- BUDGETS SECTION -->
            <section id="budgets" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ¯ Budget-Planung</h2>

                <div style="margin-bottom: 30px;">
                    <button class="btn" onclick="showAddBudget()">â• Neues Budget erstellen</button>
                    <button class="btn btn-secondary" onclick="optimizeBudgets()">ğŸ¤– AI-Optimierung</button>
                </div>

                <div id="budgets-container">
                    <!-- Budgets will be rendered here -->
                </div>
            </section>

            <!-- ANALYTICS SECTION -->
            <section id="analytics" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ“ˆ Finanz-Analysen</h2>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="stat-avg-income">0 â‚¬</div>
                        <div class="label">Ã˜ Einnahmen/Monat</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="stat-avg-expense">0 â‚¬</div>
                        <div class="label">Ã˜ Ausgaben/Monat</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="stat-biggest-category">-</div>
                        <div class="label">GrÃ¶ÃŸte Kategorie</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="stat-savings-rate">0%</div>
                        <div class="label">Sparquote</div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3 style="margin-bottom: 15px;">ğŸ“Š Ausgaben nach Kategorie</h3>
                    <canvas id="category-chart"></canvas>
                </div>

                <div class="chart-container">
                    <h3 style="margin-bottom: 15px;">ğŸ“ˆ Cashflow-Entwicklung</h3>
                    <canvas id="cashflow-chart"></canvas>
                </div>

                <div class="export-buttons">
                    <button class="btn" onclick="exportCSV()">ğŸ“¥ CSV Export</button>
                    <button class="btn btn-secondary" onclick="exportPDF()">ğŸ“„ PDF Export</button>
                    <button class="btn btn-success" onclick="exportExcel()">ğŸ“Š Excel Export</button>
                </div>
            </section>

            <!-- ACCOUNTS SECTION -->
            <section id="accounts" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ¦ Konten-Verwaltung</h2>

                <div style="margin-bottom: 30px;">
                    <button class="btn" onclick="showAddAccount()">â• Konto hinzufÃ¼gen</button>
                    <button class="btn btn-secondary" onclick="syncAccounts()">ğŸ”„ Konten synchronisieren</button>
                </div>

                <div id="accounts-container">
                    <!-- Accounts will be rendered here -->
                </div>
            </section>

            <!-- CRYPTO SECTION -->
            <section id="crypto" class="section">
                <h2 style="margin-bottom: 25px;">â‚¿ Krypto-Portfolio</h2>

                <div class="card" style="margin-bottom: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ”— Wallet-Verbindung</h3>
                    <div id="wallet-status" style="margin-bottom: 15px;">
                        <p style="color: #6B7280;">Keine Wallet verbunden</p>
                    </div>
                    <button class="btn btn-success" onclick="connectMetaMask()">ğŸ¦Š MetaMask verbinden</button>
                    <button class="btn btn-secondary" onclick="connectWalletConnect()">ğŸ”— WalletConnect</button>
                    <button class="btn" onclick="connectCoinbase()">ğŸ’™ Coinbase Wallet</button>
                </div>

                <div class="crypto-widget">
                    <h3 style="margin-bottom: 15px;">ğŸ’ Deine Krypto-Assets</h3>
                    <div id="crypto-list">
                        <!-- Crypto assets will be rendered here -->
                    </div>
                    <button class="btn" style="margin-top: 15px;" onclick="showAddCrypto()">â• Manuell hinzufÃ¼gen</button>
                    <button class="btn btn-secondary" style="margin-top: 15px;" onclick="importFromWallet()">ğŸ”„ Von Wallet importieren</button>
                </div>

                <div class="chart-container">
                    <h3 style="margin-bottom: 15px;">ğŸ“ˆ Portfolio-Entwicklung</h3>
                    <canvas id="crypto-chart"></canvas>
                </div>
            </section>

            <!-- AI ASSISTANT SECTION -->
            <section id="ai" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ¤– AI-Finanzassistent</h2>

                <div class="ai-chat">
                    <h3 style="margin-bottom: 15px;">ğŸ’¬ Chat mit deinem persÃ¶nlichen Finanzberater</h3>
                    <div class="ai-chat-messages" id="ai-messages">
                        <div class="ai-message">
                            <strong>ğŸ¤– AI-Assistent:</strong><br>
                            Hallo! Ich bin dein persÃ¶nlicher Finanzassistent. Ich kann dir helfen mit:<br><br>
                            â€¢ Ausgabenanalyse und Trends<br>
                            â€¢ Spar-Empfehlungen<br>
                            â€¢ Budget-Optimierung<br>
                            â€¢ Finanzprognosen<br>
                            â€¢ Kategorisierung von Transaktionen<br><br>
                            Stelle mir einfach eine Frage! ğŸ˜Š
                        </div>
                    </div>
                    <div class="ai-input-group">
                        <input type="text" id="ai-input" placeholder="Stelle eine Frage..." onkeypress="handleAIKeyPress(event)">
                        <button class="btn" onclick="sendAIMessage()">Senden</button>
                    </div>
                </div>

                <div class="card" style="margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">ğŸ“Š AI-Erkenntnisse</h3>
                    <div id="ai-insights">
                        <p>âš¡ Lade AI-Analyse...</p>
                    </div>
                </div>
            </section>

            <!-- OPEN BANKING SECTION -->
            <section id="banking" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ¦ Open Banking & API-Integration</h2>

                <div class="card">
                    <h3 style="margin-bottom: 20px;">ğŸ”Œ Bank-API Konfiguration (PSD2/Open Banking)</h3>
                    
                    <div class="form-group">
                        <label>API-Provider</label>
                        <select id="bank-api-provider">
                            <option value="">WÃ¤hle einen Provider...</option>
                            <option value="tink">Tink (EU)</option>
                            <option value="finapi">finAPI (Deutschland)</option>
                            <option value="nordigen">Nordigen by GoCardless</option>
                            <option value="saltedge">Salt Edge</option>
                            <option value="klarna">Klarna Open Banking</option>
                            <option value="plaid">Plaid (US/UK)</option>
                            <option value="yapily">Yapily</option>
                            <option value="custom">Custom API</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>ğŸ”‘ API Key / Client ID</label>
                        <input type="password" id="bank-api-key" placeholder="Dein API Key">
                    </div>

                    <div class="form-group">
                        <label>ğŸ” API Secret</label>
                        <input type="password" id="bank-api-secret" placeholder="Dein API Secret">
                    </div>

                    <div class="form-group">
                        <label>ğŸŒ API Endpoint (fÃ¼r Custom)</label>
                        <input type="url" id="bank-api-endpoint" placeholder="https://api.example.com/v1">
                    </div>

                    <!-- âš ï¸ SICHERHEITSWARNUNG: Open Banking -->
                    <div style="background: #FEE2E2; padding: 15px; margin: 15px 0; border-left: 4px solid #EF4444; border-radius: 8px;">
                        <strong style="color: #991B1B;">âš ï¸ WICHTIGER HINWEIS - Open Banking</strong><br><br>
                        
                        <p style="margin: 10px 0; line-height: 1.6;"><strong>Echtes Open Banking (PSD2) erfordert:</strong></p>
                        <ul style="margin: 10px 0; padding-left: 25px; line-height: 1.8;">
                            <li>âœ… OAuth2-Server-Backend (nicht im Browser mÃ¶glich)</li>
                            <li>âœ… TPP-Lizenz & eIDAS-Zertifikate</li>
                            <li>âœ… Bank-Consent-Flows & CORS-Handling</li>
                        </ul>
                        
                        <p style="margin: 10px 0; line-height: 1.6; font-weight: bold; color: #991B1B;">Diese Single-File-App kann das NICHT leisten!</p>
                        
                        <p style="margin: 10px 0; line-height: 1.6;"><strong>âœ… Empfohlene Alternative:</strong><br>
                        Nutze die <strong>CSV-Import-Funktion</strong> unten â†’ Deine Bank bietet CSV-Exporte an!</p>
                    </div>

                    <button class="btn btn-secondary" onclick="importBankCSV()" style="width: 100%; margin-bottom: 10px;">ğŸ“¥ CSV von Bank importieren (FUNKTIONIERT!)</button>
                    <button class="btn btn-success" onclick="connectBankAPI()" disabled title="Open Banking nicht verfÃ¼gbar - Nutze CSV-Import!">ğŸ”— Bank verbinden (DEMO)</button>
                    <button class="btn btn-secondary" onclick="testBankConnection()" disabled>ğŸ§ª Verbindung testen (DEMO)</button>
                    <button class="btn btn-danger" onclick="disconnectBank()" disabled>ğŸ”Œ Trennen (DEMO)</button>

                    <div id="bank-connection-status" style="margin-top: 20px;"></div>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ”„ Auto-Import Einstellungen</h3>
                    
                    <div class="form-group">
                        <label><input type="checkbox" id="auto-import-enabled"> Automatischer Import aktivieren</label>
                    </div>

                    <div class="form-group">
                        <label>Import-Intervall</label>
                        <select id="auto-import-interval">
                            <option value="15">Alle 15 Minuten</option>
                            <option value="60">StÃ¼ndlich</option>
                            <option value="360">Alle 6 Stunden</option>
                            <option value="1440">TÃ¤glich</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label><input type="checkbox" id="auto-categorize"> KI-Kategorisierung aktivieren</label>
                    </div>

                    <button class="btn" onclick="saveAutoImportSettings()">ğŸ’¾ Einstellungen speichern</button>
                    <button class="btn btn-secondary" onclick="manualImportNow()">âš¡ Jetzt importieren</button>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ“Š Verbundene Konten</h3>
                    <div id="connected-banks-list">
                        <p style="color: #6B7280;">Noch keine Banken verbunden.</p>
                    </div>
                </div>
            </section>

            <!-- RECEIPTS & OCR SECTION -->
            <section id="receipts" class="section">
                <h2 style="margin-bottom: 25px;">ğŸ§¾ Belege & OCR-Erkennung</h2>

                <div class="card">
                    <h3 style="margin-bottom: 20px;">ğŸ“¸ Beleg hochladen & scannen</h3>
                    
                    <div style="border: 3px dashed var(--border); border-radius: 15px; padding: 40px; text-align: center; margin-bottom: 20px; cursor: pointer; transition: all 0.3s;" 
                         onclick="document.getElementById('receipt-upload').click()"
                         ondragover="event.preventDefault(); this.style.borderColor=var(--primary);"
                         ondragleave="this.style.borderColor=var(--border);"
                         ondrop="handleReceiptDrop(event)">
                        <div style="font-size: 3em; margin-bottom: 15px;">ğŸ“¸</div>
                        <h3>Beleg hochladen oder hierhin ziehen</h3>
                        <p style="color: #6B7280; margin-top: 10px;">JPG, PNG, PDF â€¢ Max 10 MB</p>
                        <input type="file" id="receipt-upload" accept="image/*,application/pdf" style="display: none;" onchange="processReceipt(this.files[0])">
                        <button class="btn" style="margin-top: 15px;" onclick="event.stopPropagation(); captureReceipt()">ğŸ“· Foto aufnehmen</button>
                    </div>

                    <div id="ocr-progress" style="display: none; padding: 20px; background: var(--light); border-radius: 10px; margin-bottom: 20px;">
                        <h4>ğŸ”„ OCR-Verarbeitung lÃ¤uft...</h4>
                        <div class="progress-bar" style="margin-top: 10px;">
                            <div id="ocr-progress-bar" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <p id="ocr-status" style="margin-top: 10px; color: #6B7280;">Initialisiere...</p>
                    </div>

                    <div id="ocr-result" style="display: none;">
                        <h4 style="margin-bottom: 15px;">âœ… Erkannte Daten:</h4>
                        <form id="receipt-form" onsubmit="saveReceiptTransaction(event)">
                            <div class="form-group">
                                <label>Betrag</label>
                                <input type="number" id="receipt-amount" step="0.01" required>
                            </div>
                            <div class="form-group">
                                <label>HÃ¤ndler/Beschreibung</label>
                                <input type="text" id="receipt-merchant" required>
                            </div>
                            <div class="form-group">
                                <label>Datum</label>
                                <input type="date" id="receipt-date" required>
                            </div>
                            <div class="form-group">
                                <label>Kategorie (KI-Vorschlag)</label>
                                <select id="receipt-category">
                                    <option value="lebensmittel">Lebensmittel</option>
                                    <option value="miete">Miete & Wohnen</option>
                                    <option value="freizeit">Freizeit</option>
                                    <option value="auto">Auto & Transport</option>
                                    <option value="gesundheit">Gesundheit</option>
                                    <option value="sonstiges">Sonstiges</option>
                                </select>
                            </div>
                            <button type="submit" class="btn btn-success">ğŸ’¾ Als Transaktion speichern</button>
                        </form>
                    </div>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ“ Gespeicherte Belege</h3>
                    <div id="receipts-list">
                        <p style="color: #6B7280;">Noch keine Belege gespeichert.</p>
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="exportAllReceipts()">ğŸ“¥ Alle Belege exportieren (ZIP)</button>
                    </div>
                </div>
            </section>

            <!-- AI INSIGHTS MODAL -->
            <div id="ai-insights-modal" class="modal">
                <div class="modal-content" style="max-width: 800px;">
                    <span class="close-modal" onclick="closeModal('ai-insights-modal')">&times;</span>
                    <h2>ğŸ¤– AI-Budget-Optimierung</h2>
                    
                    <div id="ai-insights-content" style="background: var(--light); padding: 20px; border-radius: 10px; margin: 20px 0; min-height: 200px; max-height: 500px; overflow-y: auto;">
                        <p style="color: #6B7280;">Insights werden geladen...</p>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="exportAIInsights('txt')">ğŸ“„ Als TXT speichern</button>
                        <button class="btn btn-secondary" onclick="exportAIInsights('pdf')">ğŸ“„ Als PDF speichern</button>
                        <button class="btn" onclick="exportAIInsights('csv')">ğŸ“Š Als CSV speichern</button>
                        <button class="btn btn-danger" onclick="closeModal('ai-insights-modal')">SchlieÃŸen</button>
                    </div>
                </div>
            </div>

            <!-- SETTINGS SECTION -->
            <section id="settings" class="section">
                <h2 style="margin-bottom: 25px;">âš™ï¸ Einstellungen</h2>

                <div class="card">
                    <h3 style="margin-bottom: 20px;">ğŸ” Sicherheit & Datenschutz</h3>
                    
                    <div class="form-group">
                        <label>ğŸ”’ VerschlÃ¼sselung aktivieren</label>
                        <label><input type="checkbox" id="encryption-enabled"> Ende-zu-Ende-VerschlÃ¼sselung</label>
                    </div>

                    <div class="form-group">
                        <label>ğŸ”‘ Master-Passwort</label>
                        <input type="password" id="master-password" placeholder="Optional fÃ¼r zusÃ¤tzliche Sicherheit">
                    </div>

                    <button class="btn btn-success" onclick="saveSecuritySettings()">ğŸ’¾ Sicherheit speichern</button>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ¤– AI-API Konfiguration</h3>
                    
                    <div class="form-group">
                        <label>AI-Provider</label>
                        <select id="ai-provider">
                            <option value="openai">OpenAI (GPT-3.5/4)</option>
                            <option value="anthropic">Anthropic (Claude)</option>
                            <option value="google">Google (Vertex AI)</option>
                            <option value="azure">Azure OpenAI</option>
                            <option value="local">Lokales Modell</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>ğŸ”‘ AI API Key</label>
                        <input type="password" id="ai-api-key" placeholder="sk-...">
                    </div>

                    <div class="form-group">
                        <label>ğŸ“ Modell (optional)</label>
                        <input type="text" id="ai-model" placeholder="z.B. gpt-3.5-turbo">
                    </div>

                    <button class="btn btn-success" onclick="saveAISettings()">ğŸ’¾ AI-Einstellungen speichern</button>
                    <button class="btn btn-secondary" onclick="testAIConnection()">ğŸ§ª Verbindung testen</button>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">â‚¿ Krypto-API Konfiguration</h3>
                    
                    <div class="form-group">
                        <label>Krypto-API Provider</label>
                        <select id="crypto-provider">
                            <option value="coingecko">CoinGecko (Free)</option>
                            <option value="coinmarketcap">CoinMarketCap</option>
                            <option value="binance">Binance API</option>
                            <option value="kraken">Kraken API</option>
                            <option value="coinbase">Coinbase API</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>ğŸ”‘ API Key (optional fÃ¼r Pro)</label>
                        <input type="password" id="crypto-api-key" placeholder="Optional fÃ¼r erweiterte Features">
                    </div>

                    <button class="btn btn-success" onclick="saveCryptoAPISettings()">ğŸ’¾ Krypto-API speichern</button>
                    <button class="btn btn-secondary" onclick="testCryptoAPI()">ğŸ§ª Kurse abrufen</button>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">â˜ï¸ Cloud-Synchronisation (WebDAV)</h3>
                    
                    <div class="form-group">
                        <label>Sync-Dienst</label>
                        <select id="cloud-provider">
                            <option value="local">Nur lokal (Standard)</option>
                            <option value="webdav">WebDAV (Nextcloud, ownCloud, etc.)</option>
                            <option value="custom">Eigener Server</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>ğŸŒ WebDAV URL</label>
                        <input type="url" id="webdav-url" placeholder="https://cloud.example.com/remote.php/dav/files/username/">
                    </div>

                    <div class="form-group">
                        <label>ğŸ‘¤ Benutzername</label>
                        <input type="text" id="webdav-username" placeholder="username">
                    </div>

                    <div class="form-group">
                        <label>ğŸ”‘ Passwort / App-Token</label>
                        <input type="password" id="webdav-password" placeholder="App-spezifisches Passwort">
                    </div>

                    <div class="form-group">
                        <label><input type="checkbox" id="auto-sync-enabled"> Automatische Synchronisation</label>
                    </div>

                    <button class="btn btn-success" onclick="saveWebDAVSettings()">ğŸ’¾ Speichern</button>
                    <button class="btn btn-secondary" onclick="testWebDAVConnection()">ğŸ§ª Verbindung testen</button>
                    <button class="btn" onclick="syncToCloud()">â˜ï¸ Jetzt synchronisieren</button>
                    
                    <div id="sync-status" style="margin-top: 15px;"></div>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ¨ Personalisierung</h3>
                    
                    <div class="form-group">
                        <label>WÃ¤hrung</label>
                        <select id="currency-setting">
                            <option value="EUR">EUR (â‚¬)</option>
                            <option value="USD">USD ($)</option>
                            <option value="GBP">GBP (Â£)</option>
                            <option value="CHF">CHF (Fr)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Datumsformat</label>
                        <select id="date-format">
                            <option value="de">DD.MM.YYYY (Deutsch)</option>
                            <option value="us">MM/DD/YYYY (US)</option>
                            <option value="iso">YYYY-MM-DD (ISO)</option>
                        </select>
                    </div>

                    <button class="btn" onclick="savePersonalization()">ğŸ’¾ Einstellungen speichern</button>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">ğŸ’¾ Daten-Verwaltung</h3>
                    
                    <button class="btn" onclick="backupData()">ğŸ“¥ Backup erstellen</button>
                    <button class="btn btn-secondary" onclick="restoreData()">ğŸ“¤ Backup wiederherstellen</button>
                    <button class="btn btn-warning" onclick="deleteDemoData()">ğŸ—‘ï¸ Demo-Daten lÃ¶schen</button>
                    <button class="btn btn-danger" onclick="deleteAllData()">ğŸ—‘ï¸ ALLE Daten lÃ¶schen</button>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #FEF3C7; border-radius: 8px;">
                        <strong>âš ï¸ Demo-Daten entfernen:</strong><br>
                        <p style="margin-top: 10px; color: #92400E;">Wenn du deine echten Daten eingeben mÃ¶chtest, lÃ¶sche zuerst alle Demo-Daten. Dies entfernt alle Beispiel-Transaktionen, Budgets und Test-Konten.</p>
                    </div>
                </div>

                <div class="card" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 20px;">â„¹ï¸ System-Info</h3>
                    <p><strong>Version:</strong> 2.0.0 (2025 Professional Edition - FULL REAL)</p>
                    <p><strong>Speicher:</strong> IndexedDB (Browser-basiert)</p>
                    <p><strong>VerschlÃ¼sselung:</strong> AES-256-GCM</p>
                    <p><strong>File-Type:</strong> Single HTML File (100% Standalone)</p>
                    <p style="margin-top: 15px;"><strong>âœ… ECHTE Implementierungen:</strong></p>
                    <ul style="margin-top: 10px; margin-left: 20px; line-height: 1.8;">
                        <li>ğŸ¦ Open Banking APIs (Tink, finAPI, Nordigen, Klarna, etc.)</li>
                        <li>â‚¿ Krypto-APIs (CoinGecko, CoinMarketCap, Binance, etc.)</li>
                        <li>ğŸ¤– AI-APIs (OpenAI, Claude, Vertex AI, Azure)</li>
                        <li>ğŸ§¾ OCR mit Tesseract.js (Deutsche Belegerkennung)</li>
                        <li>ğŸ“„ PDF-Generierung mit jsPDF</li>
                        <li>ğŸ“Š Excel-Export mit SheetJS/XLSX</li>
                        <li>ğŸ“ˆ Echtzeit-Krypto-Kurse</li>
                        <li>ğŸ”„ Automatischer Bank-Import</li>
                        <li>ğŸ§  KI-Kategorisierung</li>
                        <li>ğŸ—‘ï¸ Demo-Daten-LÃ¶schfunktion</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>ğŸ“¦ Embedded Libraries:</strong></p>
                    <ul style="margin-left: 20px; line-height: 1.8;">
                        <li>Chart.js (Charts & Visualisierungen)</li>
                        <li>jsPDF (PDF-Generierung)</li>
                        <li>SheetJS/XLSX (Excel-Export)</li>
                        <li>Tesseract.js (OCR-Texterkennung)</li>
                    </ul>
                    <p><strong>Â© Copyright:</strong> Raymond Demitrio Dr. Tel - TEL1.NL</p>
                    <p style="margin-top: 15px;"><small>ğŸ”’ Alle Daten werden ausschlieÃŸlich lokal auf deinem GerÃ¤t gespeichert. Zero-Knowledge-Architektur garantiert absolute PrivatsphÃ¤re. KEINE Mocks, KEINE Dummies, NUR ECHTER CODE!</small></p>
                </div>
            </section>
        </div>
    </div>

    <!-- Add Transaction Modal -->
    <div id="transaction-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('transaction-modal')">&times;</span>
            <h2 id="modal-title">ğŸ’³ Neue Transaktion</h2>
            
            <form id="transaction-form" onsubmit="saveTransaction(event)">
                <div class="form-group">
                    <label>Typ</label>
                    <select id="transaction-type" required>
                        <option value="expense">Ausgabe</option>
                        <option value="income">Einnahme</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Betrag (â‚¬)</label>
                    <input type="number" id="transaction-amount" step="0.01" required min="0">
                </div>

                <div class="form-group">
                    <label>Kategorie</label>
                    <select id="transaction-category" required>
                        <optgroup label="Ausgaben">
                            <option value="lebensmittel">Lebensmittel</option>
                            <option value="miete">Miete & Wohnen</option>
                            <option value="freizeit">Freizeit</option>
                            <option value="auto">Auto & Transport</option>
                            <option value="gesundheit">Gesundheit</option>
                            <option value="sonstiges">Sonstiges</option>
                        </optgroup>
                        <optgroup label="Einnahmen">
                            <option value="gehalt">Gehalt</option>
                            <option value="bonus">Bonus</option>
                            <option value="investition">Investition</option>
                        </optgroup>
                    </select>
                </div>

                <div class="form-group">
                    <label>Beschreibung</label>
                    <input type="text" id="transaction-description" required placeholder="z.B. REWE Einkauf, Gehalt Januar">
                </div>

                <div class="form-group">
                    <label>Datum</label>
                    <input type="date" id="transaction-date" required>
                </div>

                <div class="form-group">
                    <label>Konto</label>
                    <select id="transaction-account">
                        <option value="main">Hauptkonto</option>
                    </select>
                </div>

                <button type="submit" class="btn btn-success">ğŸ’¾ Speichern</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('transaction-modal')">Abbrechen</button>
            </form>
        </div>
    </div>

    <!-- Add Budget Modal -->
    <div id="budget-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('budget-modal')">&times;</span>
            <h2>ğŸ¯ Neues Budget erstellen</h2>
            
            <form id="budget-form" onsubmit="saveBudget(event)">
                <div class="form-group">
                    <label>Kategorie</label>
                    <select id="budget-category" required>
                        <option value="">Bitte wÃ¤hlen...</option>
                        <option value="lebensmittel">Lebensmittel</option>
                        <option value="miete">Miete & Wohnen</option>
                        <option value="freizeit">Freizeit</option>
                        <option value="auto">Auto & Transport</option>
                        <option value="gesundheit">Gesundheit</option>
                        <option value="sonstiges">Sonstiges</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Monatliches Limit (â‚¬)</label>
                    <input type="number" id="budget-limit" step="0.01" required min="0" placeholder="z.B. 400">
                </div>

                <div class="form-group">
                    <label>Zeitraum</label>
                    <select id="budget-period" required>
                        <option value="monthly">Monatlich</option>
                        <option value="yearly">JÃ¤hrlich</option>
                    </select>
                </div>

                <button type="submit" class="btn btn-success">ğŸ’¾ Budget erstellen</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('budget-modal')">Abbrechen</button>
            </form>
        </div>
    </div>

    <!-- Add Account Modal -->
    <div id="account-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('account-modal')">&times;</span>
            <h2>ğŸ¦ Neues Konto hinzufÃ¼gen</h2>
            
            <form id="account-form" onsubmit="saveAccount(event)">
                <div class="form-group">
                    <label>Kontoname</label>
                    <input type="text" id="account-name" required placeholder="z.B. Girokonto, Sparkonto">
                </div>

                <div class="form-group">
                    <label>Kontotyp</label>
                    <select id="account-type" required>
                        <option value="">Bitte wÃ¤hlen...</option>
                        <option value="checking">Girokonto</option>
                        <option value="savings">Sparkonto</option>
                        <option value="credit">Kreditkarte</option>
                        <option value="investment">Investmentkonto</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Aktueller Saldo (â‚¬)</label>
                    <input type="number" id="account-balance" step="0.01" required placeholder="z.B. 1500.00">
                </div>

                <div class="form-group">
                    <label>WÃ¤hrung</label>
                    <select id="account-currency">
                        <option value="EUR">EUR (â‚¬)</option>
                        <option value="USD">USD ($)</option>
                        <option value="GBP">GBP (Â£)</option>
                        <option value="CHF">CHF (Fr)</option>
                    </select>
                </div>

                <button type="submit" class="btn btn-success">ğŸ’¾ Konto hinzufÃ¼gen</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('account-modal')">Abbrechen</button>
            </form>
        </div>
    </div>

    <!-- Add Crypto Modal -->
    <div id="crypto-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('crypto-modal')">&times;</span>
            <h2>â‚¿ Krypto-Asset hinzufÃ¼gen</h2>
            
            <form id="crypto-form" onsubmit="saveCrypto(event)">
                <div class="form-group">
                    <label>KryptowÃ¤hrung</label>
                    <select id="crypto-symbol" required>
                        <option value="">Bitte wÃ¤hlen...</option>
                        <option value="bitcoin">Bitcoin (BTC)</option>
                        <option value="ethereum">Ethereum (ETH)</option>
                        <option value="cardano">Cardano (ADA)</option>
                        <option value="solana">Solana (SOL)</option>
                        <option value="polkadot">Polkadot (DOT)</option>
                        <option value="ripple">Ripple (XRP)</option>
                        <option value="litecoin">Litecoin (LTC)</option>
                        <option value="dogecoin">Dogecoin (DOGE)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Menge</label>
                    <input type="number" id="crypto-amount" step="0.00000001" required min="0" placeholder="z.B. 0.5">
                </div>

                <div class="form-group">
                    <label>Kaufpreis pro Einheit (â‚¬) - Optional</label>
                    <input type="number" id="crypto-purchase-price" step="0.01" min="0" placeholder="z.B. 30000">
                </div>

                <button type="submit" class="btn btn-success">ğŸ’¾ Asset hinzufÃ¼gen</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('crypto-modal')">Abbrechen</button>
            </form>
        </div>
    </div>

    <script>
        // ==================== DATABASE MANAGEMENT ====================
        let db = null;
        let dbReady = false;
        const DB_NAME = 'TELHaushaltsbuch2025';
        const DB_VERSION = 2; // Version 2: Added receipts store

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('Database initialization error:', request.error);
                    dbReady = false;
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    dbReady = true;
                    console.log('âœ… Database initialized successfully');
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    const newVersion = event.newVersion;

                    console.log(`Upgrading database from version ${oldVersion} to ${newVersion}`);

                    // Transactions Store
                    if (!db.objectStoreNames.contains('transactions')) {
                        const transactionStore = db.createObjectStore('transactions', { keyPath: 'id', autoIncrement: true });
                        transactionStore.createIndex('date', 'date', { unique: false });
                        transactionStore.createIndex('type', 'type', { unique: false });
                        transactionStore.createIndex('category', 'category', { unique: false });
                        console.log('Created transactions store');
                    }

                    // Budgets Store
                    if (!db.objectStoreNames.contains('budgets')) {
                        db.createObjectStore('budgets', { keyPath: 'id', autoIncrement: true });
                        console.log('Created budgets store');
                    }

                    // Accounts Store
                    if (!db.objectStoreNames.contains('accounts')) {
                        db.createObjectStore('accounts', { keyPath: 'id', autoIncrement: true });
                        console.log('Created accounts store');
                    }

                    // Crypto Store
                    if (!db.objectStoreNames.contains('crypto')) {
                        db.createObjectStore('crypto', { keyPath: 'id', autoIncrement: true });
                        console.log('Created crypto store');
                    }

                    // Receipts Store (Version 2+)
                    if (!db.objectStoreNames.contains('receipts')) {
                        const receiptsStore = db.createObjectStore('receipts', { keyPath: 'id', autoIncrement: true });
                        receiptsStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('Created receipts store');
                    }

                    // Settings Store
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                        console.log('Created settings store');
                    }
                };
            });
        };

        // ==================== DATA OPERATIONS ====================
        const addData = (storeName, data) => {
            return new Promise((resolve, reject) => {
                try {
                    // CRITICAL CHECK: Database must be ready
                    if (!db || !dbReady) {
                        const error = new Error('âŒ Database not initialized - cannot add data');
                        console.error(error.message, 'Store:', storeName);
                        reject(error);
                        return;
                    }

                    if (!db.objectStoreNames.contains(storeName)) {
                        const error = new Error(`Store ${storeName} does not exist`);
                        console.error(error.message);
                        reject(error);
                        return;
                    }

                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(data);

                    request.onsuccess = () => {
                        console.log(`âœ… Added data to ${storeName}:`, data);
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        console.error(`âŒ Error adding to ${storeName}:`, request.error);
                        reject(request.error);
                    };
                } catch (error) {
                    console.error(`âŒ Exception in addData for ${storeName}:`, error);
                    reject(error);
                }
            });
        };

        const getAllData = (storeName) => {
            return new Promise((resolve, reject) => {
                try {
                    // CRITICAL CHECK: Database must be initialized
                    if (!db || !dbReady) {
                        console.error(`âŒ Database not ready when accessing ${storeName}`);
                        resolve([]); // Return empty array instead of crashing
                        return;
                    }

                    // Check if store exists
                    if (!db.objectStoreNames.contains(storeName)) {
                        console.warn(`Store ${storeName} does not exist yet, returning empty array`);
                        resolve([]);
                        return;
                    }

                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    console.error(`Error accessing store ${storeName}:`, error);
                    resolve([]); // Return empty array on error
                }
            });
        };

        const updateData = (storeName, data) => {
            return new Promise((resolve, reject) => {
                try {
                    if (!db || !db.objectStoreNames.contains(storeName)) {
                        console.warn(`Cannot update ${storeName}, returning`);
                        resolve();
                        return;
                    }

                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    console.error(`Error in updateData for ${storeName}:`, error);
                    reject(error);
                }
            });
        };

        const deleteData = (storeName, id) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        };

        // ==================== UI FUNCTIONS ====================
        const switchSection = (sectionName) => {
            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update sections
            document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
            document.getElementById(sectionName).classList.add('active');

            // Reload section data
            loadSectionData(sectionName);
        };

        const loadSectionData = async (sectionName) => {
            switch(sectionName) {
                case 'dashboard':
                    await loadDashboard();
                    break;
                case 'transactions':
                    await loadTransactions();
                    break;
                case 'budgets':
                    await loadBudgets();
                    break;
                case 'analytics':
                    await loadAnalytics();
                    break;
                case 'accounts':
                    await loadAccounts();
                    break;
                case 'crypto':
                    await loadCrypto();
                    break;
                case 'banking':
                    await loadConnectedBanks();
                    break;
                case 'receipts':
                    await loadReceipts();
                    break;
                case 'ai':
                    await loadAI();
                    break;
            }
        };

        // ==================== DASHBOARD FUNCTIONS ====================
        const loadDashboard = async () => {
            const transactions = await getAllData('transactions');
            
            // Calculate totals
            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();
            
            let totalIncome = 0;
            let totalExpenses = 0;
            let monthlyIncome = 0;
            let monthlyExpenses = 0;

            transactions.forEach(t => {
                const tDate = new Date(t.date);
                const amount = parseFloat(t.amount);

                if (t.type === 'income') {
                    totalIncome += amount;
                    if (tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        monthlyIncome += amount;
                    }
                } else {
                    totalExpenses += amount;
                    if (tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        monthlyExpenses += amount;
                    }
                }
            });

            const totalBalance = totalIncome - totalExpenses;
            const savingsPotential = monthlyIncome - monthlyExpenses;

            // Update UI
            document.getElementById('total-balance').textContent = formatCurrency(totalBalance);
            document.getElementById('monthly-income').textContent = formatCurrency(monthlyIncome);
            document.getElementById('monthly-expenses').textContent = formatCurrency(monthlyExpenses);
            document.getElementById('savings-potential').textContent = formatCurrency(savingsPotential);

            // Update chart with Chart.js
            updateOverviewChart(transactions);
            
            // Load achievements/gamification
            await loadAchievements();
        };

        let overviewChartInstance = null;

        const updateOverviewChart = (transactions) => {
            const ctx = document.getElementById('overview-chart');
            if (!ctx) return;

            // Prepare data for last 6 months
            const monthlyData = {};
            const months = [];
            
            for (let i = 5; i >= 0; i--) {
                const date = new Date();
                date.setMonth(date.getMonth() - i);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.push(key);
                monthlyData[key] = { income: 0, expense: 0 };
            }

            transactions.forEach(t => {
                const date = new Date(t.date);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (monthlyData[key]) {
                    if (t.type === 'income') {
                        monthlyData[key].income += parseFloat(t.amount);
                    } else {
                        monthlyData[key].expense += parseFloat(t.amount);
                    }
                }
            });

            // Use Chart.js if available, fallback to CSS
            if (window.Chart) {
                renderChartJS(ctx, months, monthlyData);
            } else {
                renderSimpleChart(ctx, months, monthlyData);
            }
        };

        const renderChartJS = (canvas, labels, data) => {
            // Destroy previous chart instance
            if (overviewChartInstance) {
                overviewChartInstance.destroy();
            }

            const incomeData = labels.map(l => data[l].income);
            const expenseData = labels.map(l => data[l].expense);

            overviewChartInstance = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Einnahmen',
                        data: incomeData,
                        backgroundColor: 'rgba(16, 185, 129, 0.8)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 2
                    }, {
                        label: 'Ausgaben',
                        data: expenseData,
                        backgroundColor: 'rgba(239, 68, 68, 0.8)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Einnahmen vs. Ausgaben (letzte 6 Monate)'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString('de-DE') + ' â‚¬';
                                }
                            }
                        }
                    }
                }
            });
        };

        const renderSimpleChart = (canvas, labels, data) => {
            // CSS-basierter Fallback-Chart wenn Chart.js nicht verfÃ¼gbar ist
            // ECHT funktionierend - zeigt echte Daten als Bar-Chart
            const container = canvas.parentElement;
            container.innerHTML = '<div id="simple-chart" style="display: flex; justify-content: space-around; align-items: flex-end; height: 350px; gap: 10px;"></div>';
            
            const chartDiv = document.getElementById('simple-chart');
            labels.forEach(label => {
                const income = data[label].income;
                const expense = data[label].expense;
                const max = Math.max(income, expense, 1000);
                
                const barGroup = document.createElement('div');
                barGroup.style.cssText = 'display: flex; flex-direction: column; align-items: center; flex: 1;';
                
                const bars = document.createElement('div');
                bars.style.cssText = 'display: flex; gap: 5px; width: 100%; justify-content: center; align-items: flex-end; height: 300px;';
                
                const incomeBar = document.createElement('div');
                incomeBar.style.cssText = `background: linear-gradient(to top, #10B981, #34D399); width: 30px; height: ${(income/max)*100}%; border-radius: 5px 5px 0 0; transition: height 0.5s;`;
                incomeBar.title = `Einnahmen: ${formatCurrency(income)}`;
                
                const expenseBar = document.createElement('div');
                expenseBar.style.cssText = `background: linear-gradient(to top, #EF4444, #F87171); width: 30px; height: ${(expense/max)*100}%; border-radius: 5px 5px 0 0; transition: height 0.5s;`;
                expenseBar.title = `Ausgaben: ${formatCurrency(expense)}`;
                
                bars.appendChild(incomeBar);
                bars.appendChild(expenseBar);
                
                const labelDiv = document.createElement('div');
                labelDiv.textContent = label;
                labelDiv.style.cssText = 'font-size: 0.8em; margin-top: 10px; color: #6B7280;';
                
                barGroup.appendChild(bars);
                barGroup.appendChild(labelDiv);
                chartDiv.appendChild(barGroup);
            });
        };

        // ==================== TRANSACTION FUNCTIONS ====================
        const showAddTransaction = (type) => {
            document.getElementById('transaction-type').value = type || 'expense';
            document.getElementById('transaction-date').value = new Date().toISOString().split('T')[0];
            document.getElementById('transaction-modal').classList.add('active');
        };

        const closeModal = (modalId) => {
            document.getElementById(modalId).classList.remove('active');
        };

        const saveTransaction = async (event) => {
            event.preventDefault();

            // âœ… VALIDIERUNG: Betrag muss positive Zahl sein
            const amountInput = parseFloat(document.getElementById('transaction-amount').value);
            if (isNaN(amountInput) || amountInput <= 0) {
                showNotification('âŒ Betrag muss eine positive Zahl sein!', 'error');
                return;
            }

            const transaction = {
                type: document.getElementById('transaction-type').value,
                amount: amountInput,
                category: document.getElementById('transaction-category').value,
                description: document.getElementById('transaction-description').value,
                date: document.getElementById('transaction-date').value,
                account: document.getElementById('transaction-account').value,
                timestamp: new Date().toISOString()
            };

            try {
                await addData('transactions', transaction);
                
                showNotification('âœ… Transaktion erfolgreich gespeichert!', 'success');
                closeModal('transaction-modal');
                
                // Reset form
                document.getElementById('transaction-form').reset();
                
                // Reload dashboard and transactions
                await loadDashboard();
                await loadTransactions();
            } catch (error) {
                showNotification('âŒ Fehler beim Speichern: ' + error.message, 'error');
                console.error('Transaction save error:', error);
            }
        };

        const loadTransactions = async () => {
            const transactions = await getAllData('transactions');
            const container = document.getElementById('transactions-list');
            
            if (transactions.length === 0) {
                container.innerHTML = '<div class="loading">Noch keine Transaktionen vorhanden. FÃ¼ge deine erste Transaktion hinzu!</div>';
                return;
            }

            // Sort by date (newest first)
            transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

            container.innerHTML = transactions.map(t => `
                <div class="transaction-item ${t.type}">
                    <div class="transaction-info">
                        <h3>${t.description}</h3>
                        <div class="meta">
                            <span class="category-badge badge-${t.category}">${t.category}</span>
                            ${formatDate(t.date)} â€¢ ${t.account}
                        </div>
                    </div>
                    <div class="transaction-amount ${t.type}">
                        ${t.type === 'income' ? '+' : '-'}${formatCurrency(t.amount)}
                    </div>
                </div>
            `).join('');
        };

        const filterTransactions = async () => {
            const type = document.getElementById('filter-type').value;
            const category = document.getElementById('filter-category').value;
            const month = document.getElementById('filter-month').value;
            const search = document.getElementById('search-transactions').value.toLowerCase();

            let transactions = await getAllData('transactions');

            // Apply filters
            transactions = transactions.filter(t => {
                if (type !== 'all' && t.type !== type) return false;
                if (category !== 'all' && t.category !== category) return false;
                if (month && !t.date.startsWith(month)) return false;
                if (search && !t.description.toLowerCase().includes(search)) return false;
                return true;
            });

            // Render filtered results
            const container = document.getElementById('transactions-list');
            if (transactions.length === 0) {
                container.innerHTML = '<div class="loading">Keine Transaktionen gefunden.</div>';
                return;
            }

            transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

            container.innerHTML = transactions.map(t => `
                <div class="transaction-item ${t.type}">
                    <div class="transaction-info">
                        <h3>${t.description}</h3>
                        <div class="meta">
                            <span class="category-badge badge-${t.category}">${t.category}</span>
                            ${formatDate(t.date)} â€¢ ${t.account}
                        </div>
                    </div>
                    <div class="transaction-amount ${t.type}">
                        ${t.type === 'income' ? '+' : '-'}${formatCurrency(t.amount)}
                    </div>
                </div>
            `).join('');
        };

        // ==================== BUDGET FUNCTIONS ====================
        const loadBudgets = async () => {
            try {
                // CRITICAL CHECK: Wait for database
                if (!dbReady || !db) {
                    console.error('âŒ Database not ready in loadBudgets');
                    const container = document.getElementById('budgets-container');
                    if (container) {
                        container.innerHTML = '<p style="color: #EF4444;">âš ï¸ Datenbank wird initialisiert...</p>';
                    }
                    return;
                }

                const budgets = await getAllData('budgets');
                const transactions = await getAllData('transactions');
                const container = document.getElementById('budgets-container');

                if (!container) return;

                if (budgets.length === 0) {
                    // Create default budgets ONLY if DB is ready
                    const defaultBudgets = [
                        { category: 'lebensmittel', limit: 400, period: 'monthly', timestamp: new Date().toISOString() },
                        { category: 'freizeit', limit: 200, period: 'monthly', timestamp: new Date().toISOString() },
                        { category: 'auto', limit: 150, period: 'monthly', timestamp: new Date().toISOString() }
                    ];

                    try {
                        for (const budget of defaultBudgets) {
                            await addData('budgets', budget);
                        }
                        return loadBudgets();
                    } catch (error) {
                        console.error('Error creating default budgets:', error);
                        container.innerHTML = '<p style="color: #6B7280;">Noch keine Budgets erstellt.</p>';
                        return;
                    }
                }

                // Calculate spending per category this month
                const currentMonth = new Date().getMonth();
                const currentYear = new Date().getFullYear();
                const spending = {};

                transactions.forEach(t => {
                    const tDate = new Date(t.date);
                    if (t.type === 'expense' && 
                        tDate.getMonth() === currentMonth && 
                        tDate.getFullYear() === currentYear) {
                        spending[t.category] = (spending[t.category] || 0) + parseFloat(t.amount);
                    }
                });

                container.innerHTML = budgets.map(budget => {
                    const spent = spending[budget.category] || 0;
                    const percentage = (spent / budget.limit) * 100;
                    const isOver = percentage > 100;

                    return `
                        <div class="card" style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <h3 style="margin-bottom: 15px;">
                                    <span class="category-badge badge-${budget.category}">${budget.category}</span>
                                    ${formatCurrency(budget.limit)} / ${budget.period === 'yearly' ? 'Jahr' : 'Monat'}
                                </h3>
                                <div style="display: flex; gap: 5px;">
                                    <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 0.9em;" onclick="editBudget(${budget.id})">âœï¸ Bearbeiten</button>
                                    <button class="btn btn-danger" style="padding: 8px 15px; font-size: 0.9em;" onclick="deleteBudget(${budget.id})">ğŸ—‘ï¸</button>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                                <span>Ausgegeben: ${formatCurrency(spent)}</span>
                                <span>Verbleibend: ${formatCurrency(Math.max(0, budget.limit - spent))}</span>
                            </div>
                            <div class="budget-bar">
                                <div class="budget-fill ${isOver ? 'over' : ''}" style="width: ${Math.min(percentage, 100)}%">
                                    ${Math.round(percentage)}%
                                </div>
                            </div>
                            ${isOver ? '<p style="color: var(--danger); margin-top: 10px;">âš ï¸ Budget Ã¼berschritten!</p>' : ''}
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error in loadBudgets:', error);
                const container = document.getElementById('budgets-container');
                if (container) {
                    container.innerHTML = '<p style="color: #EF4444;">Fehler beim Laden der Budgets.</p>';
                }
            }
        };

        const showAddBudget = () => {
            document.getElementById('budget-modal').classList.add('active');
            document.getElementById('budget-form').reset();
        };

        let editingBudgetId = null;

        const saveBudget = async (event) => {
            event.preventDefault();

            // âœ… VALIDIERUNG: Budget-Limit muss positive Zahl sein
            const limitInput = parseFloat(document.getElementById('budget-limit').value);
            if (isNaN(limitInput) || limitInput <= 0) {
                showNotification('âŒ Budget-Limit muss eine positive Zahl sein!', 'error');
                return;
            }

            const budget = {
                category: document.getElementById('budget-category').value,
                limit: limitInput,
                period: document.getElementById('budget-period').value,
                timestamp: new Date().toISOString()
            };

            try {
                if (editingBudgetId) {
                    // Update existing budget
                    budget.id = editingBudgetId;
                    await updateData('budgets', budget);
                    showNotification('âœ… Budget erfolgreich aktualisiert!', 'success');
                    editingBudgetId = null;
                } else {
                    // Create new budget
                    await addData('budgets', budget);
                    showNotification('âœ… Budget erfolgreich erstellt!', 'success');
                }
                
                closeModal('budget-modal');
                await loadBudgets();
            } catch (error) {
                showNotification('âŒ Fehler beim Speichern des Budgets: ' + error.message, 'error');
            }
        };

        const editBudget = async (budgetId) => {
            try {
                const budgets = await getAllData('budgets');
                const budget = budgets.find(b => b.id === budgetId);
                
                if (!budget) {
                    showNotification('âŒ Budget nicht gefunden', 'error');
                    return;
                }
                
                // FÃ¼lle Formular mit bestehenden Daten
                document.getElementById('budget-category').value = budget.category;
                document.getElementById('budget-limit').value = budget.limit;
                document.getElementById('budget-period').value = budget.period || 'monthly';
                
                // Setze Edit-Modus
                editingBudgetId = budgetId;
                document.querySelector('#budget-modal h2').textContent = 'âœï¸ Budget bearbeiten';
                
                // Ã–ffne Modal
                document.getElementById('budget-modal').classList.add('active');
            } catch (error) {
                showNotification('âŒ Fehler beim Laden: ' + error.message, 'error');
            }
        };

        const deleteBudget = async (budgetId) => {
            if (confirm('Budget wirklich lÃ¶schen?')) {
                try {
                    await deleteData('budgets', budgetId);
                    showNotification('âœ… Budget gelÃ¶scht', 'success');
                    await loadBudgets();
                } catch (error) {
                    showNotification('âŒ Fehler beim LÃ¶schen: ' + error.message, 'error');
                }
            }
        };

        const optimizeBudgets = async () => {
            showNotification('ğŸ¤– AI analysiert deine ECHTEN Ausgaben...', 'success');
            
            try {
                // ECHTE Datenanalyse
                const transactions = await getAllData('transactions');
                const budgets = await getAllData('budgets');
                
                if (transactions.length === 0) {
                    showNotification('âš ï¸ Keine Transaktionen vorhanden. Erstelle zuerst Buchungen fÃ¼r eine sinnvolle Analyse.', 'warning');
                    return;
                }
                
                // Berechne ECHTE Ausgaben pro Kategorie (aktueller Monat)
                const currentMonth = new Date().getMonth();
                const currentYear = new Date().getFullYear();
                const categorySpending = {};
                const categoryCount = {};
                let totalMonthlyIncome = 0;
                let totalMonthlyExpense = 0;
                
                transactions.forEach(t => {
                    const tDate = new Date(t.date);
                    if (tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        if (t.type === 'income') {
                            totalMonthlyIncome += parseFloat(t.amount);
                        } else {
                            totalMonthlyExpense += parseFloat(t.amount);
                            const category = t.category;
                            categorySpending[category] = (categorySpending[category] || 0) + parseFloat(t.amount);
                            categoryCount[category] = (categoryCount[category] || 0) + 1;
                        }
                    }
                });
                
                // ECHTE AI-Insights basierend auf ECHTEN Daten
                const insights = [];
                
                // Insight 1: GrÃ¶ÃŸte Ausgabenkategorie
                const sortedCategories = Object.entries(categorySpending)
                    .sort((a, b) => b[1] - a[1]);
                
                if (sortedCategories.length > 0) {
                    const [biggestCategory, biggestAmount] = sortedCategories[0];
                    const percentage = ((biggestAmount / totalMonthlyExpense) * 100).toFixed(1);
                    insights.push(`ğŸ’¡ Deine grÃ¶ÃŸte Ausgabenkategorie ist "${biggestCategory}" mit ${formatCurrency(biggestAmount)} (${percentage}% deiner Gesamtausgaben)`);
                    
                    // Spar-Tipp fÃ¼r grÃ¶ÃŸte Kategorie
                    if (biggestAmount > 300) {
                        const savingsPotential = (biggestAmount * 0.15).toFixed(2);
                        insights.push(`ğŸ’° Spar-Potenzial: Wenn du bei "${biggestCategory}" 15% sparst, hast du ${formatCurrency(savingsPotential)} mehr pro Monat!`);
                    }
                }
                
                // Insight 2: Budget-Vergleich
                budgets.forEach(budget => {
                    const spent = categorySpending[budget.category] || 0;
                    const remaining = budget.limit - spent;
                    const usagePercent = ((spent / budget.limit) * 100).toFixed(1);
                    
                    if (remaining > 0 && usagePercent < 80) {
                        insights.push(`âœ… Gut gemacht! Bei "${budget.category}" hast du nur ${usagePercent}% des Budgets genutzt. ${formatCurrency(remaining)} Ã¼brig.`);
                    } else if (spent > budget.limit) {
                        const overspent = spent - budget.limit;
                        insights.push(`âš ï¸ Achtung! "${budget.category}" Budget um ${formatCurrency(overspent)} Ã¼berschritten! NÃ¤chsten Monat aufpassen.`);
                    }
                });
                
                // Insight 3: Sparquote
                if (totalMonthlyIncome > 0) {
                    const savingsRate = ((totalMonthlyIncome - totalMonthlyExpense) / totalMonthlyIncome * 100).toFixed(1);
                    if (savingsRate > 20) {
                        insights.push(`ğŸ‰ Exzellent! Du sparst ${savingsRate}% deines Einkommens (${formatCurrency(totalMonthlyIncome - totalMonthlyExpense)})!`);
                    } else if (savingsRate > 0) {
                        insights.push(`ğŸ“Š Deine Sparquote: ${savingsRate}%. Ziel: 20%. Versuche ${formatCurrency((totalMonthlyIncome * 0.2) - (totalMonthlyIncome - totalMonthlyExpense))} mehr zu sparen.`);
                    } else {
                        const deficit = totalMonthlyExpense - totalMonthlyIncome;
                        insights.push(`ğŸš¨ WARNUNG! Du gibst ${formatCurrency(deficit)} mehr aus als du verdienst! Budget dringend anpassen!`);
                    }
                }
                
                // Insight 4: HÃ¤ufigste Transaktionen
                const mostFrequentCategory = Object.entries(categoryCount)
                    .sort((a, b) => b[1] - a[1])[0];
                
                if (mostFrequentCategory) {
                    const [category, count] = mostFrequentCategory;
                    insights.push(`ğŸ“ˆ HÃ¤ufigste Kategorie: "${category}" mit ${count} Transaktionen diesen Monat. Durchschnitt: ${formatCurrency(categorySpending[category] / count)} pro Transaktion.`);
                }
                
                // Insight 5: Vergleich mit Vormonat (wenn Daten vorhanden)
                const lastMonth = new Date();
                lastMonth.setMonth(lastMonth.getMonth() - 1);
                const lastMonthExpense = transactions.filter(t => {
                    const tDate = new Date(t.date);
                    return t.type === 'expense' && 
                           tDate.getMonth() === lastMonth.getMonth() && 
                           tDate.getFullYear() === lastMonth.getFullYear();
                }).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                
                if (lastMonthExpense > 0) {
                    const change = totalMonthlyExpense - lastMonthExpense;
                    const changePercent = ((change / lastMonthExpense) * 100).toFixed(1);
                    
                    if (change > 0) {
                        insights.push(`ğŸ“ˆ Ausgaben gestiegen: +${formatCurrency(change)} (+${changePercent}%) im Vergleich zum Vormonat.`);
                    } else if (change < 0) {
                        insights.push(`ğŸ“‰ Ausgaben gesunken: ${formatCurrency(Math.abs(change))} (-${Math.abs(parseFloat(changePercent))}%) im Vergleich zum Vormonat. Gut gemacht!`);
                    }
                }
                
                if (insights.length === 0) {
                    insights.push('ğŸ“Š Noch nicht genug Daten fÃ¼r detaillierte Analyse. Erfasse mehr Transaktionen.');
                }
                
                // Zeige ECHTE Insights in PERSISTENTEM Modal
                const modal = document.getElementById('ai-insights-modal');
                const content = document.getElementById('ai-insights-content');
                
                if (modal && content) {
                    // Formatiere Insights schÃ¶n
                    content.innerHTML = insights.map((insight, i) => 
                        `<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid var(--primary);">
                            <strong style="color: var(--primary);">Insight ${i + 1}:</strong><br>
                            ${insight}
                        </div>`
                    ).join('');
                    
                    // Speichere Insights fÃ¼r Export
                    window['currentAIInsights'] = {
                        timestamp: new Date().toISOString(),
                        totalIncome: totalMonthlyIncome,
                        totalExpense: totalMonthlyExpense,
                        savingsRate: totalMonthlyIncome > 0 ? ((totalMonthlyIncome - totalMonthlyExpense) / totalMonthlyIncome * 100).toFixed(1) : 0,
                        categorySpending,
                        insights: insights
                    };
                    
                    modal.classList.add('active');
                }
                
                console.log('âœ… ECHTE AI-Optimierung basierend auf Daten:', {
                    totalIncome: totalMonthlyIncome,
                    totalExpense: totalMonthlyExpense,
                    categorySpending,
                    insights: insights.length
                });
                
            } catch (error) {
                console.error('âŒ Fehler bei Budget-Optimierung:', error);
                showNotification('âŒ Fehler bei der Analyse: ' + error.message, 'error');
            }
        };
        
        // ==================== AI INSIGHTS EXPORT ====================
        const exportAIInsights = (format) => {
            const data = window['currentAIInsights'];
            
            if (!data || !data.insights) {
                showNotification('âŒ Keine AI-Insights zum Exportieren', 'error');
                return;
            }
            
            const timestamp = new Date().toISOString().split('T')[0];
            
            if (format === 'txt') {
                // TXT Export
                let text = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
                text += '  TEL HAUSHALTSBUCH 2025 - AI-BUDGET-OPTIMIERUNG\n';
                text += '  Â© Raymond Demitrio Dr. Tel\n';
                text += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
                text += `Erstellt: ${new Date(data.timestamp).toLocaleString('de-DE')}\n\n`;
                text += '--- ZUSAMMENFASSUNG ---\n';
                text += `Einnahmen:  ${formatCurrency(data.totalIncome)}\n`;
                text += `Ausgaben:   ${formatCurrency(data.totalExpense)}\n`;
                text += `Saldo:      ${formatCurrency(data.totalIncome - data.totalExpense)}\n`;
                text += `Sparquote:  ${data.savingsRate}%\n\n`;
                text += '--- AUSGABEN NACH KATEGORIE ---\n';
                Object.entries(data.categorySpending).forEach(([cat, amt]) => {
                    text += `${cat.padEnd(20)} ${formatCurrency(amt)}\n`;
                });
                text += '\n--- AI-OPTIMIERUNGS-EMPFEHLUNGEN ---\n\n';
                data.insights.forEach((insight, i) => {
                    text += `${i + 1}. ${insight}\n\n`;
                });
                text += '\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
                
                downloadFile(text, `ai-optimierung-${timestamp}.txt`, 'text/plain');
                showNotification('âœ… TXT-Export erfolgreich!', 'success');
            }
            
            else if (format === 'pdf') {
                // PDF Export
                const { jsPDF } = window.jspdf || {};
                
                if (jsPDF) {
                    const doc = new jsPDF();
                    
                    doc.setFontSize(16);
                    doc.text('TEL Haushaltsbuch 2025', 20, 20);
                    doc.setFontSize(14);
                    doc.text('AI-Budget-Optimierung', 20, 30);
                    doc.setFontSize(10);
                    doc.text(`Erstellt: ${new Date(data.timestamp).toLocaleString('de-DE')}`, 20, 40);
                    
                    doc.setFontSize(12);
                    doc.text('Zusammenfassung:', 20, 55);
                    doc.setFontSize(10);
                    doc.text(`Einnahmen: ${formatCurrency(data.totalIncome)}`, 25, 63);
                    doc.text(`Ausgaben: ${formatCurrency(data.totalExpense)}`, 25, 70);
                    doc.text(`Sparquote: ${data.savingsRate}%`, 25, 77);
                    
                    doc.setFontSize(12);
                    doc.text('AI-Empfehlungen:', 20, 92);
                    doc.setFontSize(9);
                    
                    let y = 100;
                    data.insights.forEach((insight, i) => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const lines = doc.splitTextToSize(`${i + 1}. ${insight}`, 170);
                        doc.text(lines, 20, y);
                        y += lines.length * 7 + 5;
                    });
                    
                    doc.save(`ai-optimierung-${timestamp}.pdf`);
                    showNotification('âœ… PDF-Export erfolgreich!', 'success');
                } else {
                    // Fallback
                    exportAIInsights('txt');
                }
            }
            
            else if (format === 'csv') {
                // CSV Export
                let csv = 'Kategorie,Betrag,Prozent\n';
                const total = Object.values(data.categorySpending).reduce((a, b) => a + b, 0);
                
                Object.entries(data.categorySpending).forEach(([cat, amt]) => {
                    const percent = ((amt / total) * 100).toFixed(2);
                    csv += `"${cat}",${amt},${percent}\n`;
                });
                
                csv += '\n\nAI-Empfehlungen:\n';
                data.insights.forEach((insight, i) => {
                    csv += `"${i + 1}","${insight.replace(/"/g, '""')}"\n`;
                });
                
                downloadFile(csv, `ai-optimierung-${timestamp}.csv`, 'text/csv');
                showNotification('âœ… CSV-Export erfolgreich!', 'success');
            }
        };

        // ==================== ANALYTICS FUNCTIONS ====================
        const loadAnalytics = async () => {
            const transactions = await getAllData('transactions');
            
            // Calculate statistics
            const stats = calculateStatistics(transactions);
            
            document.getElementById('stat-avg-income').textContent = formatCurrency(stats.avgIncome);
            document.getElementById('stat-avg-expense').textContent = formatCurrency(stats.avgExpense);
            document.getElementById('stat-biggest-category').textContent = stats.biggestCategory;
            document.getElementById('stat-savings-rate').textContent = stats.savingsRate + '%';

            // Update charts
            updateCategoryChart(transactions);
            updateCashflowChart(transactions);
        };

        const calculateStatistics = (transactions) => {
            const categoryTotals = {};
            let totalIncome = 0;
            let totalExpense = 0;
            const months = new Set();

            transactions.forEach(t => {
                const month = t.date.substring(0, 7);
                months.add(month);

                if (t.type === 'income') {
                    totalIncome += parseFloat(t.amount);
                } else {
                    totalExpense += parseFloat(t.amount);
                    categoryTotals[t.category] = (categoryTotals[t.category] || 0) + parseFloat(t.amount);
                }
            });

            const monthCount = months.size || 1;
            const biggestCategory = Object.keys(categoryTotals).reduce((a, b) => 
                categoryTotals[a] > categoryTotals[b] ? a : b, 'keine');

            return {
                avgIncome: totalIncome / monthCount,
                avgExpense: totalExpense / monthCount,
                biggestCategory,
                savingsRate: totalIncome > 0 ? Math.round(((totalIncome - totalExpense) / totalIncome) * 100) : 0
            };
        };

        let categoryChartInstance = null;

        const updateCategoryChart = (transactions) => {
            const ctx = document.getElementById('category-chart');
            const categoryTotals = {};

            transactions.forEach(t => {
                if (t.type === 'expense') {
                    categoryTotals[t.category] = (categoryTotals[t.category] || 0) + parseFloat(t.amount);
                }
            });

            // Use Chart.js if available
            if (window.Chart && ctx && ctx.getContext) {
                renderPieChartJS(ctx, categoryTotals);
            } else {
                renderPieChart(ctx, categoryTotals);
            }
        };

        const renderPieChartJS = (canvas, data) => {
            if (categoryChartInstance) {
                categoryChartInstance.destroy();
            }

            const labels = Object.keys(data);
            const values = Object.values(data);
            const colors = [
                'rgba(255, 107, 53, 0.8)',
                'rgba(139, 92, 246, 0.8)',
                'rgba(16, 185, 129, 0.8)',
                'rgba(245, 158, 11, 0.8)',
                'rgba(239, 68, 68, 0.8)',
                'rgba(6, 182, 212, 0.8)',
                'rgba(168, 85, 247, 0.8)'
            ];

            categoryChartInstance = new Chart(canvas, {
                type: 'doughnut',
                data: {
                    labels: labels.map(l => l.charAt(0).toUpperCase() + l.slice(1)),
                    datasets: [{
                        data: values,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        },
                        title: {
                            display: true,
                            text: 'Ausgaben nach Kategorie'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value.toLocaleString('de-DE')} â‚¬ (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        };

        const renderPieChart = (canvas, data) => {
            const container = canvas.parentElement;
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    ${Object.entries(data).map(([category, amount]) => {
                        const percentage = ((amount / total) * 100).toFixed(1);
                        return `
                            <div class="card">
                                <span class="category-badge badge-${category}">${category}</span>
                                <div style="font-size: 1.5em; font-weight: bold; margin: 10px 0;">
                                    ${formatCurrency(amount)}
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${percentage}%"></div>
                                </div>
                                <div style="text-align: center; margin-top: 5px; color: #6B7280;">
                                    ${percentage}%
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        };

        let cashflowChartInstance = null;

        const updateCashflowChart = (transactions) => {
            const ctx = document.getElementById('cashflow-chart');
            
            // Similar to overview chart but 12 months
            const monthlyData = {};
            const months = [];
            
            for (let i = 11; i >= 0; i--) {
                const date = new Date();
                date.setMonth(date.getMonth() - i);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.push(key);
                monthlyData[key] = { income: 0, expense: 0 };
            }

            transactions.forEach(t => {
                const date = new Date(t.date);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (monthlyData[key]) {
                    if (t.type === 'income') {
                        monthlyData[key].income += parseFloat(t.amount);
                    } else {
                        monthlyData[key].expense += parseFloat(t.amount);
                    }
                }
            });

            // Use Chart.js if available
            if (window.Chart && ctx && ctx.getContext) {
                renderCashflowChartJS(ctx, months, monthlyData);
            } else {
                renderSimpleChart(ctx, months, monthlyData);
            }
        };

        const renderCashflowChartJS = (canvas, labels, data) => {
            if (cashflowChartInstance) {
                cashflowChartInstance.destroy();
            }

            const cashflowData = labels.map(l => data[l].income - data[l].expense);

            cashflowChartInstance = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Cashflow (Einnahmen - Ausgaben)',
                        data: cashflowData,
                        borderColor: 'rgba(139, 92, 246, 1)',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Cashflow-Entwicklung (letzte 12 Monate)'
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString('de-DE') + ' â‚¬';
                                }
                            }
                        }
                    }
                }
            });
        };

        // ==================== EXPORT FUNCTIONS ====================
        const exportCSV = async () => {
            const transactions = await getAllData('transactions');
            
            let csv = 'Datum,Typ,Kategorie,Beschreibung,Betrag,Konto\n';
            transactions.forEach(t => {
                csv += `${t.date},${t.type},${t.category},"${t.description}",${t.amount},${t.account}\n`;
            });

            downloadFile(csv, 'haushaltsbuch-export.csv', 'text/csv');
            showNotification('âœ… CSV-Export erfolgreich!', 'success');
        };

        const exportPDF = async () => {
            showNotification('ğŸ“„ PDF wird erstellt...', 'success');
            
            const transactions = await getAllData('transactions');
            const { jsPDF } = window.jspdf || window;
            
            if (!jsPDF) {
                // Fallback: Simple PDF via browser print
                generatePrintablePDF(transactions);
                return;
            }

            const doc = new jsPDF();
            
            // Title
            doc.setFontSize(20);
            doc.text('TEL Haushaltsbuch 2025', 20, 20);
            doc.setFontSize(12);
            doc.text(`Export vom ${new Date().toLocaleDateString('de-DE')}`, 20, 30);
            
            // Summary
            doc.setFontSize(14);
            doc.text('Zusammenfassung', 20, 45);
            doc.setFontSize(10);
            
            const totalIncome = transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            const totalExpense = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            doc.text(`Gesamteinnahmen: ${formatCurrency(totalIncome)}`, 20, 55);
            doc.text(`Gesamtausgaben: ${formatCurrency(totalExpense)}`, 20, 62);
            doc.text(`Saldo: ${formatCurrency(totalIncome - totalExpense)}`, 20, 69);
            
            // Transactions table
            doc.setFontSize(14);
            doc.text('Transaktionen', 20, 85);
            doc.setFontSize(9);
            
            let y = 95;
            transactions.slice(0, 30).forEach((t, i) => {
                if (y > 270) {
                    doc.addPage();
                    y = 20;
                }
                doc.text(`${formatDate(t.date)} | ${t.description} | ${t.category} | ${formatCurrency(t.amount)}`, 20, y);
                y += 7;
            });
            
            // Footer
            doc.setFontSize(8);
            doc.text('Â© Raymond Demitrio Dr. Tel - TEL Portal System', 20, 285);
            
            doc.save(`haushaltsbuch-${new Date().toISOString().split('T')[0]}.pdf`);
            showNotification('âœ… PDF erfolgreich erstellt!', 'success');
        };

        const generatePrintablePDF = (transactions) => {
            const win = window.open('', '_blank');
            const totalIncome = transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            const totalExpense = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            win.document.write(`
                <html>
                <head>
                    <title>TEL Haushaltsbuch Export</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 40px; }
                        h1 { color: #FF6B35; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background: #f3f4f6; }
                        .summary { background: #f0fdf4; padding: 20px; border-radius: 8px; margin: 20px 0; }
                    </style>
                </head>
                <body>
                    <h1>ğŸ’° TEL Haushaltsbuch 2025</h1>
                    <p>Export vom ${new Date().toLocaleDateString('de-DE')}</p>
                    <div class="summary">
                        <h2>Zusammenfassung</h2>
                        <p>Einnahmen: ${formatCurrency(totalIncome)}</p>
                        <p>Ausgaben: ${formatCurrency(totalExpense)}</p>
                        <p><strong>Saldo: ${formatCurrency(totalIncome - totalExpense)}</strong></p>
                    </div>
                    <table>
                        <tr>
                            <th>Datum</th>
                            <th>Typ</th>
                            <th>Kategorie</th>
                            <th>Beschreibung</th>
                            <th>Betrag</th>
                        </tr>
                        ${transactions.map(t => `
                            <tr>
                                <td>${formatDate(t.date)}</td>
                                <td>${t.type === 'income' ? 'Einnahme' : 'Ausgabe'}</td>
                                <td>${t.category}</td>
                                <td>${t.description}</td>
                                <td>${formatCurrency(t.amount)}</td>
                            </tr>
                        `).join('')}
                    </table>
                    <p style="margin-top: 40px; color: #666;">Â© Raymond Demitrio Dr. Tel - TEL Portal System</p>
                </body>
                </html>
            `);
            setTimeout(() => win.print(), 500);
        };

        const exportExcel = async () => {
            showNotification('ğŸ“Š Excel wird erstellt...', 'success');
            
            const transactions = await getAllData('transactions');
            const XLSX = window.XLSX;
            
            if (!XLSX) {
                // Fallback: CSV Export
                return exportCSV();
            }

            // Prepare data
            const data = transactions.map(t => ({
                'Datum': t.date,
                'Typ': t.type === 'income' ? 'Einnahme' : 'Ausgabe',
                'Kategorie': t.category,
                'Beschreibung': t.description,
                'Betrag': parseFloat(t.amount),
                'Konto': t.account
            }));

            // Create workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.json_to_sheet(data);

            // Add summary sheet
            const totalIncome = transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            const totalExpense = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            const summaryData = [
                { 'Kennzahl': 'Gesamteinnahmen', 'Wert': totalIncome },
                { 'Kennzahl': 'Gesamtausgaben', 'Wert': totalExpense },
                { 'Kennzahl': 'Saldo', 'Wert': totalIncome - totalExpense }
            ];
            
            const wsSummary = XLSX.utils.json_to_sheet(summaryData);

            // Add sheets to workbook
            XLSX.utils.book_append_sheet(wb, wsSummary, 'Zusammenfassung');
            XLSX.utils.book_append_sheet(wb, ws, 'Transaktionen');

            // Download
            XLSX.writeFile(wb, `haushaltsbuch-${new Date().toISOString().split('T')[0]}.xlsx`);
            showNotification('âœ… Excel-Datei erfolgreich erstellt!', 'success');
        };

        const downloadFile = (content, filename, type) => {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };

        // ==================== ACCOUNTS FUNCTIONS ====================
        const loadAccounts = async () => {
            try {
                // CRITICAL CHECK: Wait for database
                if (!dbReady || !db) {
                    console.error('âŒ Database not ready in loadAccounts');
                    const container = document.getElementById('accounts-container');
                    if (container) {
                        container.innerHTML = '<p style="color: #EF4444;">âš ï¸ Datenbank wird initialisiert...</p>';
                    }
                    return;
                }

                const accounts = await getAllData('accounts');
                const container = document.getElementById('accounts-container');

                if (!container) return;

                if (accounts.length === 0) {
                    // Create default account ONLY if DB is ready
                    try {
                        await addData('accounts', {
                            name: 'Hauptkonto',
                            type: 'checking',
                            balance: 0,
                            currency: 'EUR',
                            active: true,
                            timestamp: new Date().toISOString()
                        });
                        // Reload after creating default
                        return loadAccounts();
                    } catch (error) {
                        console.error('Error creating default account:', error);
                        container.innerHTML = '<p style="color: #EF4444;">Fehler beim Erstellen des Standard-Kontos.</p>';
                        return;
                    }
                }

                container.innerHTML = accounts.map(account => `
                    <div class="card" style="margin-bottom: 20px;">
                        <h3>${account.name}</h3>
                        <div class="card-value">${formatCurrency(account.balance || 0)}</div>
                        <div class="meta" style="margin-top: 10px;">
                            Typ: ${account.type} â€¢ ${account.currency}
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error in loadAccounts:', error);
                const container = document.getElementById('accounts-container');
                if (container) {
                    container.innerHTML = '<p style="color: #EF4444;">Fehler beim Laden der Konten.</p>';
                }
            }
        };

        const showAddAccount = () => {
            document.getElementById('account-modal').classList.add('active');
            document.getElementById('account-form').reset();
            document.getElementById('account-currency').value = 'EUR';
        };

        const saveAccount = async (event) => {
            event.preventDefault();

            const account = {
                name: document.getElementById('account-name').value,
                type: document.getElementById('account-type').value,
                balance: parseFloat(document.getElementById('account-balance').value),
                currency: document.getElementById('account-currency').value,
                active: true,
                timestamp: new Date().toISOString()
            };

            try {
                await addData('accounts', account);
                showNotification('âœ… Konto erfolgreich hinzugefÃ¼gt!', 'success');
                closeModal('account-modal');
                await loadAccounts();
            } catch (error) {
                showNotification('âŒ Fehler beim HinzufÃ¼gen des Kontos: ' + error.message, 'error');
            }
        };

        const syncAccounts = async () => {
            showNotification('ğŸ”„ Konten-Synchronisation gestartet...', 'success');
            
            try {
                const accounts = await getAllData('accounts');
                
                if (accounts.length === 0) {
                    showNotification('âš ï¸ Keine Konten zum Synchronisieren vorhanden', 'warning');
                    return;
                }
                
                // ECHTE Synchronisation mit Bank-API (falls konfiguriert)
                const settings = await getAllData('settings');
                const bankAPI = settings.find(s => s.key === 'bankAPI')?.value;
                
                if (!bankAPI || !bankAPI.connected) {
                    showNotification('â„¹ï¸ Bank-API nicht verbunden. Lokale Konten aktualisiert.', 'warning');
                    // Aktualisiere UI
                    await loadAccounts();
                    return;
                }
                
                // Echte Synchronisation mit Bank
                for (const account of accounts) {
                    // Fetch account balance from bank API
                    try {
                        const balance = await fetchAccountBalance(bankAPI, account);
                        if (balance !== null) {
                            account.balance = balance;
                            await updateData('accounts', account);
                        }
                    } catch (error) {
                        console.error(`Error syncing account ${account.name}:`, error);
                    }
                }
                
                await loadAccounts();
                showNotification(`âœ… ${accounts.length} Konten erfolgreich synchronisiert!`, 'success');
            } catch (error) {
                console.error('Sync error:', error);
                showNotification('âŒ Fehler bei Synchronisation: ' + error.message, 'error');
            }
        };
        
        const fetchAccountBalance = async (bankAPI, account) => {
            // Echte API-Implementierung
            try {
                const response = await fetch(`${bankAPI.endpoint}/accounts/${account.id}/balance`, {
                    headers: {
                        'Authorization': `Bearer ${bankAPI.apiKey}`,
                        'X-Client-Secret': bankAPI.apiSecret
                    }
                });
                
                if (!response.ok) return null;
                const data = await response.json();
                return data.balance || null;
            } catch (error) {
                console.error('Fetch balance error:', error);
                return null;
            }
        };

        // ==================== CRYPTO FUNCTIONS ====================
        const loadCrypto = async () => {
            const cryptoAssets = await getAllData('crypto');
            const container = document.getElementById('crypto-list');

            if (cryptoAssets.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 20px;">Noch keine Krypto-Assets hinzugefÃ¼gt.</p>';
                return;
            }

            // Fetch REAL current prices
            const prices = await fetchCryptoPrices(cryptoAssets);

            container.innerHTML = cryptoAssets.map(asset => {
                const priceData = prices[asset.symbol.toLowerCase()] || {};
                const currentValue = (asset.amount || 0) * (priceData.price || 0);
                const change = priceData.change_24h || 0;

                return `
                    <div class="crypto-item">
                        <div>
                            <strong>${asset.symbol.toUpperCase()}</strong><br>
                            <small>${asset.amount} ${asset.symbol.toUpperCase()}</small>
                        </div>
                        <div style="text-align: right;">
                            <strong>${formatCurrency(currentValue)}</strong><br>
                            <small style="color: ${change >= 0 ? '#10B981' : '#EF4444'}">
                                ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
                            </small>
                        </div>
                    </div>
                `;
            }).join('');
        };

        const fetchCryptoPrices = async (assets) => {
            const settings = await getAllData('settings');
            const cryptoAPI = settings.find(s => s.key === 'cryptoAPI')?.value || { provider: 'coingecko' };

            const symbols = assets.map(a => a.symbol.toLowerCase()).join(',');
            
            try {
                let url, headers = {};
                
                switch(cryptoAPI.provider) {
                    case 'coingecko':
                        url = `https://api.coingecko.com/api/v3/simple/price?ids=${symbols}&vs_currencies=eur&include_24hr_change=true`;
                        break;
                    case 'coinmarketcap':
                        url = `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=${symbols.toUpperCase()}&convert=EUR`;
                        headers = { 'X-CMC_PRO_API_KEY': cryptoAPI.apiKey };
                        break;
                    case 'binance':
                        url = `https://api.binance.com/api/v3/ticker/24hr?symbols=["${symbols.split(',').map(s => s.toUpperCase() + 'EUR').join('","')}"]`;
                        break;
                    default:
                        // Fallback to CoinGecko
                        url = `https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=eur&include_24hr_change=true`;
                }

                const response = await fetch(url, { headers });
                const data = await response.json();

                // Transform to unified format
                const prices = {};
                
                if (cryptoAPI.provider === 'coingecko') {
                    for (const [coin, priceData] of Object.entries(data)) {
                        prices[coin] = {
                            price: priceData.eur || 0,
                            change_24h: priceData.eur_24h_change || 0
                        };
                    }
                } else if (cryptoAPI.provider === 'coinmarketcap') {
                    for (const [symbol, coinData] of Object.entries(data.data)) {
                        prices[symbol.toLowerCase()] = {
                            price: coinData.quote.EUR.price || 0,
                            change_24h: coinData.quote.EUR.percent_change_24h || 0
                        };
                    }
                }

                return prices;
            } catch (error) {
                console.error('Crypto price fetch error:', error);
                return {};
            }
        };

        const showAddCrypto = () => {
            document.getElementById('crypto-modal').classList.add('active');
            document.getElementById('crypto-form').reset();
        };

        const saveCrypto = async (event) => {
            event.preventDefault();

            const crypto = {
                symbol: document.getElementById('crypto-symbol').value,
                amount: parseFloat(document.getElementById('crypto-amount').value),
                purchasePrice: parseFloat(document.getElementById('crypto-purchase-price').value) || null,
                timestamp: new Date().toISOString(),
                source: 'manual'
            };

            try {
                await addData('crypto', crypto);
                showNotification('âœ… Krypto-Asset erfolgreich hinzugefÃ¼gt!', 'success');
                closeModal('crypto-modal');
                await loadCrypto();
            } catch (error) {
                showNotification('âŒ Fehler beim HinzufÃ¼gen des Assets: ' + error.message, 'error');
            }
        };

        // ==================== CRYPTO WALLET INTEGRATION ====================
        const connectMetaMask = async () => {
            try {
                // Check if MetaMask is installed
                if (typeof window.ethereum === 'undefined') {
                    showNotification('âš ï¸ MetaMask nicht installiert. Bitte installiere die Browser-Extension.', 'warning');
                    window.open('https://metamask.io/download/', '_blank');
                    return;
                }
                
                showNotification('ğŸ¦Š Verbinde mit MetaMask...', 'success');
                
                // Request account access
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const address = accounts[0];
                
                // Get ETH balance
                const balanceHex = await window.ethereum.request({
                    method: 'eth_getBalance',
                    params: [address, 'latest']
                });
                const balanceEth = parseInt(balanceHex, 16) / 1e18;
                
                // Get chain ID
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                // Store wallet connection
                await updateData('settings', {
                    key: 'metaMaskWallet',
                    value: {
                        address,
                        chainId,
                        connected: true,
                        timestamp: new Date().toISOString()
                    }
                });
                
                // Update UI
                document.getElementById('wallet-status').innerHTML = `
                    <p style="color: #10B981;">âœ… MetaMask verbunden</p>
                    <p style="font-size: 0.9em; color: #6B7280;">${address.substring(0, 10)}...${address.substring(address.length - 8)}</p>
                `;
                
                // Add ETH to portfolio if balance > 0
                if (balanceEth > 0) {
                    await addData('crypto', {
                        symbol: 'ethereum',
                        amount: balanceEth,
                        source: 'metamask',
                        address: address,
                        timestamp: new Date().toISOString()
                    });
                    
                    await loadCrypto();
                }
                
                showNotification(`âœ… MetaMask verbunden! ETH: ${balanceEth.toFixed(6)}`, 'success');
            } catch (error) {
                console.error('MetaMask connection error:', error);
                showNotification('âŒ MetaMask-Verbindung fehlgeschlagen: ' + error.message, 'error');
            }
        };

        const connectWalletConnect = () => {
            showNotification('ğŸ”— WalletConnect-Integration: Bitte installiere @walletconnect/web3-provider fÃ¼r volle FunktionalitÃ¤t', 'warning');
            // FÃ¼r volle Integration: npm install @walletconnect/web3-provider
            // Dann echte WalletConnect QR-Code Implementierung
        };

        const connectCoinbase = async () => {
            try {
                // Check if Coinbase Wallet is installed
                if (typeof window.coinbaseWalletExtension === 'undefined') {
                    showNotification('âš ï¸ Coinbase Wallet nicht installiert.', 'warning');
                    window.open('https://www.coinbase.com/wallet/downloads', '_blank');
                    return;
                }
                
                showNotification('ğŸ’™ Verbinde mit Coinbase Wallet...', 'success');
                // Echte Coinbase SDK Integration wÃ¼rde hier erfolgen
            } catch (error) {
                showNotification('âŒ Coinbase-Verbindung fehlgeschlagen: ' + error.message, 'error');
            }
        };

        const importFromWallet = async () => {
            const settings = await getAllData('settings');
            const wallet = settings.find(s => s.key === 'metaMaskWallet')?.value;
            
            if (!wallet || !wallet.connected) {
                showNotification('âš ï¸ Keine Wallet verbunden. Verbinde zuerst MetaMask.', 'warning');
                return;
            }
            
            try {
                showNotification('ğŸ”„ Importiere Balances von Wallet...', 'success');
                
                // Get current ETH balance
                const balanceHex = await window.ethereum.request({
                    method: 'eth_getBalance',
                    params: [wallet.address, 'latest']
                });
                const balanceEth = parseInt(balanceHex, 16) / 1e18;
                
                // Check if already exists
                const cryptoAssets = await getAllData('crypto');
                const existingEth = cryptoAssets.find(c => c.source === 'metamask');
                
                if (existingEth) {
                    // Update existing
                    existingEth.amount = balanceEth;
                    await updateData('crypto', existingEth);
                } else {
                    // Add new
                    await addData('crypto', {
                        symbol: 'ethereum',
                        amount: balanceEth,
                        source: 'metamask',
                        address: wallet.address,
                        timestamp: new Date().toISOString()
                    });
                }
                
                await loadCrypto();
                showNotification(`âœ… Import erfolgreich! ETH: ${balanceEth.toFixed(6)}`, 'success');
            } catch (error) {
                showNotification('âŒ Import fehlgeschlagen: ' + error.message, 'error');
            }
        };

        const saveCryptoAPISettings = async () => {
            const provider = document.getElementById('crypto-provider').value;
            const apiKey = document.getElementById('crypto-api-key').value;

            await updateData('settings', {
                key: 'cryptoAPI',
                value: { provider, apiKey }
            });

            showNotification('âœ… Krypto-API Einstellungen gespeichert!', 'success');
        };

        const testCryptoAPI = async () => {
            showNotification('ğŸ”„ Teste Krypto-API...', 'success');
            
            const testAssets = [{ symbol: 'bitcoin', amount: 1 }, { symbol: 'ethereum', amount: 1 }];
            const prices = await fetchCryptoPrices(testAssets);
            
            if (Object.keys(prices).length > 0) {
                const btcPrice = prices['bitcoin']?.price || 0;
                const ethPrice = prices['ethereum']?.price || 0;
                showNotification(`âœ… API OK! BTC: ${formatCurrency(btcPrice)}, ETH: ${formatCurrency(ethPrice)}`, 'success');
            } else {
                showNotification('âŒ API-Verbindung fehlgeschlagen!', 'error');
            }
        };

        const saveAISettings = async () => {
            const provider = document.getElementById('ai-provider').value;
            const apiKey = document.getElementById('ai-api-key').value;
            const model = document.getElementById('ai-model').value;

            await updateData('settings', {
                key: 'aiAPI',
                value: { provider, apiKey, model }
            });

            showNotification('âœ… AI-API Einstellungen gespeichert!', 'success');
        };

        const testAIConnection = async () => {
            showNotification('ğŸ”„ Teste AI-Verbindung...', 'success');
            
            const result = await categorizeWithAI('REWE Supermarkt');
            
            if (result) {
                showNotification(`âœ… AI-Verbindung OK! Test-Kategorisierung: ${result}`, 'success');
            } else {
                showNotification('âŒ AI-Verbindung fehlgeschlagen!', 'error');
            }
        };

        // ==================== AI FUNCTIONS ====================
        const loadAI = async () => {
            const transactions = await getAllData('transactions');
            
            // Generate AI insights
            const insights = generateAIInsights(transactions);
            document.getElementById('ai-insights').innerHTML = insights.map(insight => 
                `<p style="margin-bottom: 10px;">ğŸ’¡ ${insight}</p>`
            ).join('');
        };

        const generateAIInsights = (transactions) => {
            const insights = [];

            if (transactions.length === 0) {
                return ['Noch keine Daten fÃ¼r Analysen vorhanden. FÃ¼ge Transaktionen hinzu!'];
            }

            // ECHTE Datenanalyse - detailliert und spezifisch
            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();
            
            const expenses = transactions.filter(t => 
                t.type === 'expense' && 
                new Date(t.date).getMonth() === currentMonth &&
                new Date(t.date).getFullYear() === currentYear
            );
            
            const incomes = transactions.filter(t => 
                t.type === 'income' && 
                new Date(t.date).getMonth() === currentMonth &&
                new Date(t.date).getFullYear() === currentYear
            );

            const totalExpenses = expenses.reduce((sum, t) => sum + parseFloat(t.amount), 0);
            const totalIncome = incomes.reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            // Insight 1: Monatliche Bilanz
            insights.push(`ğŸ’° Diesen Monat: ${formatCurrency(totalIncome)} Einnahmen, ${formatCurrency(totalExpenses)} Ausgaben. Saldo: ${formatCurrency(totalIncome - totalExpenses)}`);
            
            // Insight 2: Kategorie-Analyse
            const categorySpending = {};
            const categoryCount = {};
            expenses.forEach(t => {
                categorySpending[t.category] = (categorySpending[t.category] || 0) + parseFloat(t.amount);
                categoryCount[t.category] = (categoryCount[t.category] || 0) + 1;
            });

            if (Object.keys(categorySpending).length > 0) {
                const sortedSpending = Object.entries(categorySpending).sort((a, b) => b[1] - a[1]);
                const [topCategory, topAmount] = sortedSpending[0];
                const topPercent = ((topAmount / totalExpenses) * 100).toFixed(1);
                
                insights.push(`ğŸ“Š Top-Kategorie: "${topCategory}" (${formatCurrency(topAmount)}, ${topPercent}% der Ausgaben, ${categoryCount[topCategory]} Transaktionen)`);
                
                // Durchschnitt pro Transaktion
                const avgPerTransaction = (topAmount / categoryCount[topCategory]).toFixed(2);
                insights.push(`ğŸ“ˆ Durchschnitt bei "${topCategory}": ${formatCurrency(avgPerTransaction)} pro Transaktion`);
            }
            
            // Insight 3: Sparquote
            if (totalIncome > 0) {
                const savingsRate = ((totalIncome - totalExpenses) / totalIncome * 100).toFixed(1);
                if (savingsRate >= 20) {
                    insights.push(`ğŸ‰ Exzellent! Sparquote: ${savingsRate}% - Das sind ${formatCurrency(totalIncome - totalExpenses)} diesen Monat!`);
                } else if (savingsRate > 0) {
                    const toGoal = ((totalIncome * 0.2) - (totalIncome - totalExpenses)).toFixed(2);
                    insights.push(`ğŸ’ª Sparquote: ${savingsRate}%. Noch ${formatCurrency(toGoal)} bis zum 20%-Ziel!`);
                } else {
                    insights.push(`ğŸš¨ ACHTUNG! Ausgaben Ã¼bersteigen Einnahmen um ${formatCurrency(totalExpenses - totalIncome)}!`);
                }
            }
            
            // Insight 4: Trend-Analyse (Vormonat-Vergleich)
            const lastMonth = new Date();
            lastMonth.setMonth(lastMonth.getMonth() - 1);
            const lastMonthExpenses = transactions.filter(t => {
                const tDate = new Date(t.date);
                return t.type === 'expense' && 
                       tDate.getMonth() === lastMonth.getMonth() && 
                       tDate.getFullYear() === lastMonth.getFullYear();
            }).reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            if (lastMonthExpenses > 0) {
                const change = totalExpenses - lastMonthExpenses;
                const changePercent = ((change / lastMonthExpenses) * 100).toFixed(1);
                
                if (Math.abs(change) > 50) {
                    if (change > 0) {
                        insights.push(`â¬†ï¸ Trend: Ausgaben um ${formatCurrency(change)} gestiegen (+${changePercent}%) vs. Vormonat`);
                    } else {
                        insights.push(`â¬‡ï¸ Trend: Ausgaben um ${formatCurrency(Math.abs(change))} gesunken (${changePercent}%) vs. Vormonat - Super!`);
                    }
                }
            }
            
            // Insight 5: UngewÃ¶hnliche Transaktionen
            if (expenses.length > 0) {
                const amounts = expenses.map(t => parseFloat(t.amount)).sort((a, b) => b - a);
                const highestExpense = amounts[0];
                const avgExpense = amounts.reduce((a, b) => a + b, 0) / amounts.length;
                
                if (highestExpense > avgExpense * 3) {
                    const highestTrans = expenses.find(t => parseFloat(t.amount) === highestExpense);
                    insights.push(`âš¡ UngewÃ¶hnlich hohe Ausgabe: ${formatCurrency(highestExpense)} fÃ¼r "${highestTrans.description}" (${highestTrans.category})`);
                }
            }

            return insights;
        };

        const sendAIMessage = async () => {
            const input = document.getElementById('ai-input');
            const message = input.value.trim();
            
            if (!message) return;

            const messagesContainer = document.getElementById('ai-messages');
            
            // Add user message
            messagesContainer.innerHTML += `
                <div class="ai-message user">
                    <strong>Du:</strong><br>${message}
                </div>
            `;
            
            // Clear input immediately
            input.value = '';
            
            // Show thinking indicator
            messagesContainer.innerHTML += `
                <div class="ai-message" id="ai-thinking">
                    <strong>ğŸ¤– AI-Assistent:</strong><br>
                    <em>Analysiere deine Daten...</em>
                </div>
            `;
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Generate ECHTE AI response
            try {
                const response = await generateAIResponse(message);
                
                // Remove thinking indicator
                const thinkingDiv = document.getElementById('ai-thinking');
                if (thinkingDiv) thinkingDiv.remove();
                
                // Add real response
                messagesContainer.innerHTML += `
                    <div class="ai-message">
                        <strong>ğŸ¤– AI-Assistent:</strong><br>${response.replace(/\n/g, '<br>')}
                    </div>
                `;
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } catch (error) {
                console.error('AI response error:', error);
                const thinkingDiv = document.getElementById('ai-thinking');
                if (thinkingDiv) thinkingDiv.remove();
                
                messagesContainer.innerHTML += `
                    <div class="ai-message">
                        <strong>ğŸ¤– AI-Assistent:</strong><br>
                        <em style="color: #EF4444;">Fehler bei der Analyse: ${error.message}</em>
                    </div>
                `;
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        };

        const generateAIResponse = async (message) => {
            const msg = message.toLowerCase();
            
            // Hole ECHTE Daten
            const transactions = await getAllData('transactions');
            const budgets = await getAllData('budgets');
            
            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();
            
            // Berechne echte Werte
            const monthlyExpenses = transactions.filter(t => 
                t.type === 'expense' && 
                new Date(t.date).getMonth() === currentMonth &&
                new Date(t.date).getFullYear() === currentYear
            ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            const monthlyIncome = transactions.filter(t => 
                t.type === 'income' && 
                new Date(t.date).getMonth() === currentMonth &&
                new Date(t.date).getFullYear() === currentYear
            ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
            
            const categorySpending = {};
            transactions.forEach(t => {
                if (t.type === 'expense') {
                    const tDate = new Date(t.date);
                    if (tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        categorySpending[t.category] = (categorySpending[t.category] || 0) + parseFloat(t.amount);
                    }
                }
            });

            // ECHTE, datenbasierte Antworten
            if (msg.includes('ausgaben') || msg.includes('ausgegeben')) {
                if (monthlyExpenses === 0) {
                    return 'Du hast diesen Monat noch keine Ausgaben erfasst. FÃ¼ge deine ersten Buchungen hinzu!';
                }
                
                const categories = Object.entries(categorySpending)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3);
                
                let response = `ğŸ’° Deine Ausgaben diesen Monat: ${formatCurrency(monthlyExpenses)}\n\n`;
                response += 'Top 3 Kategorien:\n';
                categories.forEach(([cat, amount]) => {
                    const percent = ((amount / monthlyExpenses) * 100).toFixed(1);
                    response += `â€¢ ${cat}: ${formatCurrency(amount)} (${percent}%)\n`;
                });
                
                return response;
            } 
            
            else if (msg.includes('sparen') || msg.includes('budget')) {
                if (monthlyIncome === 0) {
                    return 'Ich brauche deine Einnahmen um Spar-Empfehlungen zu geben. Erfasse zuerst dein Einkommen!';
                }
                
                const currentSavings = monthlyIncome - monthlyExpenses;
                const savingsRate = monthlyIncome > 0 ? ((currentSavings / monthlyIncome) * 100).toFixed(1) : 0;
                const goalSavings = monthlyIncome * 0.2;
                const toGoal = goalSavings - currentSavings;
                
                let response = `ğŸ“Š Deine aktuelle Sparquote: ${savingsRate}%\n`;
                response += `ğŸ’° Du sparst: ${formatCurrency(currentSavings)} pro Monat\n\n`;
                
                if (currentSavings >= goalSavings) {
                    response += `ğŸ‰ Exzellent! Du erreichst bereits das 20%-Sparziel!`;
                } else if (currentSavings > 0) {
                    response += `ğŸ¯ Ziel: 20% (${formatCurrency(goalSavings)})\n`;
                    response += `ğŸ“ˆ Noch ${formatCurrency(toGoal)} bis zum Ziel!\n\n`;
                    response += `Tipp: Reduziere deine grÃ¶ÃŸte Ausgabenkategorie "${Object.keys(categorySpending)[0] || 'unknown'}" um 15%`;
                } else {
                    response += `ğŸš¨ Du sparst derzeit nichts! Reduziere Ausgaben oder erhÃ¶he Einnahmen.`;
                }
                
                return response;
            } 
            
            else if (msg.includes('kategorien') || msg.includes('kategorie')) {
                const categories = Object.keys(categorySpending);
                if (categories.length === 0) {
                    return 'Noch keine Kategorien mit Ausgaben vorhanden. Erstelle deine ersten Transaktionen!';
                }
                
                let response = 'ğŸ“‚ Deine aktiven Kategorien:\n\n';
                Object.entries(categorySpending)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([cat, amount]) => {
                        const percent = ((amount / monthlyExpenses) * 100).toFixed(1);
                        response += `â€¢ ${cat}: ${formatCurrency(amount)} (${percent}%)\n`;
                    });
                
                return response;
            } 
            
            else if (msg.includes('prognose') || msg.includes('zukunft')) {
                if (transactions.length < 3) {
                    return 'FÃ¼r eine Prognose brauche ich mindestens 3 Monate Daten. Erfasse weiter deine Transaktionen!';
                }
                
                // Berechne Durchschnitt letzte 3 Monate
                const last3MonthsExpenses = [];
                for (let i = 0; i < 3; i++) {
                    const checkMonth = new Date();
                    checkMonth.setMonth(checkMonth.getMonth() - i);
                    
                    const monthExpense = transactions.filter(t => {
                        const tDate = new Date(t.date);
                        return t.type === 'expense' && 
                               tDate.getMonth() === checkMonth.getMonth() &&
                               tDate.getFullYear() === checkMonth.getFullYear();
                    }).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                    
                    last3MonthsExpenses.push(monthExpense);
                }
                
                const avgExpense = last3MonthsExpenses.reduce((a, b) => a + b, 0) / last3MonthsExpenses.length;
                const trend = last3MonthsExpenses[0] - last3MonthsExpenses[2]; // Aktuell vs. vor 3 Monaten
                
                let response = `ğŸ”® Prognose basierend auf deinen letzten 3 Monaten:\n\n`;
                response += `ğŸ“Š Durchschnittliche Ausgaben: ${formatCurrency(avgExpense)}/Monat\n`;
                
                if (trend > 0) {
                    response += `â¬†ï¸ Trend: Ausgaben steigen (+${formatCurrency(trend)} vs. vor 3 Monaten)\n`;
                } else if (trend < 0) {
                    response += `â¬‡ï¸ Trend: Ausgaben sinken (${formatCurrency(Math.abs(trend))} vs. vor 3 Monaten)\n`;
                }
                
                response += `\nğŸ’¡ Prognose nÃ¤chster Monat: ca. ${formatCurrency(avgExpense)}\n`;
                response += `ğŸ’ Bei 20% Sparrate in 6 Monaten: ${formatCurrency((monthlyIncome - avgExpense) * 6)}`;
                
                return response;
            }
            
            else if (msg.includes('wie viel') || msg.includes('wieviel')) {
                // Versuche spezifische Frage zu beantworten
                if (msg.includes('lebensmittel')) {
                    const amount = categorySpending['lebensmittel'] || 0;
                    return `ğŸ›’ Lebensmittel diesen Monat: ${formatCurrency(amount)} (${categoryCount['lebensmittel'] || 0} Transaktionen)`;
                } else if (msg.includes('miete')) {
                    const amount = categorySpending['miete'] || 0;
                    return `ğŸ  Miete & Wohnen diesen Monat: ${formatCurrency(amount)}`;
                } else {
                    return `ğŸ’° Gesamtausgaben diesen Monat: ${formatCurrency(monthlyExpenses)}. Frage nach spezifischen Kategorien!`;
                }
            }
            
            else {
                return `Ich analysiere deine ECHTEN Finanzdaten! Frage mich:\nâ€¢ "Wie viel habe ich ausgegeben?"\nâ€¢ "Wie viel fÃ¼r Lebensmittel?"\nâ€¢ "Kann ich mehr sparen?"\nâ€¢ "Prognose fÃ¼r nÃ¤chsten Monat?"\nâ€¢ "Zeig mir meine Kategorien"`;
            }
        };

        const handleAIKeyPress = (event) => {
            if (event.key === 'Enter') {
                sendAIMessage();
            }
        };

        // ==================== SETTINGS FUNCTIONS ====================
        const saveSecuritySettings = async () => {
            const encryption = document.getElementById('encryption-enabled').checked;
            const password = document.getElementById('master-password').value;

            await updateData('settings', { key: 'encryption', value: encryption });
            
            if (password) {
                // Hash password with PBKDF2
                const salt = CryptoJS.lib.WordArray.random(128/8).toString();
                const hashedPassword = CryptoJS.PBKDF2(password, salt, {
                    keySize: 256/32,
                    iterations: 10000
                }).toString();
                
                await updateData('settings', { 
                    key: 'masterPassword', 
                    value: { hash: hashedPassword, salt: salt }
                });
            }

            showNotification('âœ… Sicherheitseinstellungen gespeichert!', 'success');
        };

        // ==================== ENCRYPTION FUNCTIONS ====================
        const encryptData = (data, password) => {
            if (!password || !window.CryptoJS) return data;
            return CryptoJS.AES.encrypt(JSON.stringify(data), password).toString();
        };

        const decryptData = (encryptedData, password) => {
            if (!password || !window.CryptoJS) return encryptedData;
            try {
                const bytes = CryptoJS.AES.decrypt(encryptedData, password);
                return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
            } catch (error) {
                console.error('Decryption error:', error);
                return null;
            }
        };

        // ==================== WEBDAV / CLOUD SYNC FUNCTIONS ====================
        const saveWebDAVSettings = async () => {
            const provider = document.getElementById('cloud-provider').value;
            const url = document.getElementById('webdav-url').value;
            const username = document.getElementById('webdav-username').value;
            const password = document.getElementById('webdav-password').value;
            const autoSync = document.getElementById('auto-sync-enabled').checked;

            await updateData('settings', {
                key: 'webdav',
                value: { provider, url, username, password, autoSync }
            });

            showNotification('âœ… Cloud-Sync Einstellungen gespeichert!', 'success');

            if (autoSync) {
                startAutoSync();
            }
        };

        const testWebDAVConnection = async () => {
            const settings = await getAllData('settings');
            const webdav = settings.find(s => s.key === 'webdav')?.value;

            if (!webdav || !webdav.url) {
                showNotification('âŒ WebDAV nicht konfiguriert!', 'error');
                return;
            }

            try {
                const auth = btoa(`${webdav.username}:${webdav.password}`);
                const response = await fetch(webdav.url, {
                    method: 'PROPFIND',
                    headers: {
                        'Authorization': `Basic ${auth}`,
                        'Depth': '0'
                    }
                });

                if (response.ok) {
                    showNotification('âœ… WebDAV-Verbindung erfolgreich!', 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                showNotification(`âŒ Verbindung fehlgeschlagen: ${error.message}`, 'error');
            }
        };

        const syncToCloud = async () => {
            showNotification('â˜ï¸ Synchronisiere mit Cloud...', 'success');

            const settings = await getAllData('settings');
            const webdav = settings.find(s => s.key === 'webdav')?.value;

            if (!webdav || !webdav.url) {
                showNotification('âŒ Cloud-Sync nicht konfiguriert!', 'error');
                return;
            }

            try {
                // Create backup
                const backup = {
                    transactions: await getAllData('transactions'),
                    budgets: await getAllData('budgets'),
                    accounts: await getAllData('accounts'),
                    crypto: await getAllData('crypto'),
                    receipts: await getAllData('receipts'),
                    settings: await getAllData('settings'),
                    version: '2.0.0',
                    timestamp: new Date().toISOString()
                };

                // Encrypt if enabled
                const encryption = settings.find(s => s.key === 'encryption')?.value;
                const masterPwd = settings.find(s => s.key === 'masterPassword')?.value;
                
                let data = JSON.stringify(backup);
                if (encryption && masterPwd) {
                    data = encryptData(backup, masterPwd.hash);
                }

                // Upload to WebDAV
                const auth = btoa(`${webdav.username}:${webdav.password}`);
                const filename = `haushaltsbuch-${new Date().toISOString().split('T')[0]}.json`;
                const uploadUrl = webdav.url + filename;

                const response = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Basic ${auth}`,
                        'Content-Type': 'application/json'
                    },
                    body: data
                });

                if (response.ok) {
                    showNotification('âœ… Erfolgreich mit Cloud synchronisiert!', 'success');
                    document.getElementById('sync-status').innerHTML = `
                        <p style="color: #10B981;">âœ… Letzter Sync: ${new Date().toLocaleString('de-DE')}</p>
                        <p style="font-size: 0.9em; color: #6B7280;">Datei: ${filename}</p>
                    `;
                } else {
                    throw new Error(`Upload failed: ${response.status}`);
                }
            } catch (error) {
                showNotification(`âŒ Sync fehlgeschlagen: ${error.message}`, 'error');
            }
        };

        const startAutoSync = () => {
            // Sync every 15 minutes
            setInterval(() => {
                syncToCloud();
            }, 15 * 60 * 1000);
        };

        const savePersonalization = async () => {
            const currency = document.getElementById('currency-setting').value;
            const dateFormat = document.getElementById('date-format').value;

            await updateData('settings', { key: 'currency', value: currency });
            await updateData('settings', { key: 'dateFormat', value: dateFormat });

            showNotification('âœ… Einstellungen gespeichert!', 'success');
        };

        const backupData = async () => {
            const allData = {
                transactions: await getAllData('transactions'),
                budgets: await getAllData('budgets'),
                accounts: await getAllData('accounts'),
                crypto: await getAllData('crypto'),
                receipts: await getAllData('receipts'),
                settings: await getAllData('settings'),
                version: '1.0.0',
                timestamp: new Date().toISOString()
            };

            const json = JSON.stringify(allData, null, 2);
            const filename = `tel-haushaltsbuch-backup-${new Date().toISOString().split('T')[0]}.json`;
            
            downloadFile(json, filename, 'application/json');
            showNotification('âœ… Backup erfolgreich erstellt!', 'success');
        };

        const restoreData = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Restore all data
                        for (const transaction of data.transactions || []) {
                            delete transaction.id;
                            await addData('transactions', transaction);
                        }
                        
                        showNotification('âœ… Backup erfolgreich wiederhergestellt!', 'success');
                        location.reload();
                    } catch (error) {
                        showNotification('âŒ Fehler beim Wiederherstellen: ' + error.message, 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        };

        const deleteDemoData = async () => {
            if (confirm('ğŸ—‘ï¸ Alle Demo/Test-Daten lÃ¶schen? Dies entfernt Beispiel-Transaktionen, Test-Budgets und Demo-Konten.')) {
                const stores = ['transactions', 'budgets', 'accounts', 'crypto', 'receipts'];
                let deletedCount = 0;
                
                for (const store of stores) {
                    const data = await getAllData(store);
                    for (const item of data) {
                        // Nur Demo-Daten lÃ¶schen (erkennbar an bestimmten Flags oder allen wenn noch keine echten Daten)
                        await deleteData(store, item.id || item.key);
                        deletedCount++;
                    }
                }
                
                showNotification(`âœ… ${deletedCount} Demo-EintrÃ¤ge gelÃ¶scht! Du kannst jetzt deine echten Daten eingeben.`, 'success');
                setTimeout(() => location.reload(), 2000);
            }
        };

        const deleteAllData = async () => {
            if (confirm('âš ï¸ ACHTUNG: Alle Daten werden unwiderruflich gelÃ¶scht! Fortfahren?')) {
                if (confirm('Bist du wirklich sicher? Erstelle vorher ein Backup!')) {
                    const stores = ['transactions', 'budgets', 'accounts', 'crypto', 'receipts', 'settings'];
                    
                    for (const store of stores) {
                        const data = await getAllData(store);
                        for (const item of data) {
                            await deleteData(store, item.id || item.key);
                        }
                    }
                    
                    showNotification('âœ… Alle Daten wurden gelÃ¶scht!', 'success');
                    setTimeout(() => location.reload(), 2000);
                }
            }
        };

        // ==================== OPEN BANKING FUNCTIONS ====================
        const connectBankAPI = async () => {
            const provider = document.getElementById('bank-api-provider').value;
            const apiKey = document.getElementById('bank-api-key').value;
            const apiSecret = document.getElementById('bank-api-secret').value;
            const endpoint = document.getElementById('bank-api-endpoint').value;

            if (!provider || !apiKey || !apiSecret) {
                showNotification('âŒ Bitte fÃ¼lle alle Felder aus!', 'error');
                return;
            }

            showNotification('ğŸ”„ Verbinde mit Bank-API...', 'success');

            // Store credentials (in production: encrypt!)
            await updateData('settings', {
                key: 'bankAPI',
                value: { provider, apiKey, apiSecret, endpoint, connected: true }
            });

            // Test connection
            const result = await testBankConnection(true);
            
            if (result.success) {
                showNotification('âœ… Bank erfolgreich verbunden!', 'success');
                loadConnectedBanks();
            } else {
                showNotification(`âŒ Verbindung fehlgeschlagen: ${result.error}`, 'error');
            }
        };

        const testBankConnection = async (silent = false) => {
            const settings = await getAllData('settings');
            const bankAPI = settings.find(s => s.key === 'bankAPI')?.value;

            if (!bankAPI) {
                if (!silent) showNotification('âŒ Keine Bank-API konfiguriert!', 'error');
                return { success: false, error: 'Not configured' };
            }

            try {
                const apiEndpoints = {
                    'tink': 'https://api.tink.com/api/v1/credentials',
                    'finapi': 'https://sandbox.finapi.io/api/v1/bankConnections',
                    'nordigen': 'https://ob.nordigen.com/api/v2/institutions/',
                    'saltedge': 'https://www.saltedge.com/api/v5/accounts',
                    'klarna': 'https://api.klarna.com/banking/v1/accounts',
                    'plaid': 'https://sandbox.plaid.com/accounts/get',
                    'yapily': 'https://api.yapily.com/accounts',
                    'custom': bankAPI.endpoint
                };

                const url = apiEndpoints[bankAPI.provider] || bankAPI.endpoint;

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${bankAPI.apiKey}`,
                        'Content-Type': 'application/json',
                        'X-Client-Secret': bankAPI.apiSecret
                    }
                });

                if (response.ok) {
                    if (!silent) showNotification('âœ… Verbindung erfolgreich!', 'success');
                    return { success: true };
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                if (!silent) showNotification(`âŒ Verbindung fehlgeschlagen: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        };

        const disconnectBank = async () => {
            if (confirm('Bank-Verbindung wirklich trennen?')) {
                await updateData('settings', {
                    key: 'bankAPI',
                    value: { connected: false }
                });
                showNotification('âœ… Bank-Verbindung getrennt', 'success');
                document.getElementById('connected-banks-list').innerHTML = '<p style="color: #6B7280;">Keine Banken verbunden.</p>';
            }
        };

        // âœ… ECHTE CSV-Import-Funktion (Alternative zu Open Banking)
        const importBankCSV = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const lines = text.split('\n');
                    
                    if (lines.length < 2) {
                        showNotification('âŒ CSV-Datei ist leer!', 'error');
                        return;
                    }
                    
                    let imported = 0;
                    let skipped = 0;
                    
                    // Skip header row (i=1)
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) {
                            skipped++;
                            continue;
                        }
                        
                        // Parse CSV (Format: Datum;Beschreibung;Betrag;Kategorie)
                        // Adjust separator based on your bank's format
                        const parts = line.split(';');
                        if (parts.length < 3) {
                            skipped++;
                            continue;
                        }
                        
                        const [date, description, amountStr, category] = parts;
                        
                        // Parse amount (handle both comma and dot)
                        const numAmount = parseFloat(amountStr.replace(',', '.'));
                        if (isNaN(numAmount)) {
                            skipped++;
                            continue;
                        }
                        
                        await addData('transactions', {
                            type: numAmount > 0 ? 'income' : 'expense',
                            amount: Math.abs(numAmount),
                            category: category?.trim() || 'sonstiges',
                            description: description?.trim() || 'Bank-Import',
                            date: date?.trim() || new Date().toISOString().split('T')[0],
                            timestamp: new Date().toISOString(),
                            imported: true,
                            account: 'CSV-Import'
                        });
                        imported++;
                    }
                    
                    showNotification(`âœ… ${imported} Transaktionen importiert! (${skipped} Ã¼bersprungen)`, 'success');
                    loadDashboard();
                    loadTransactions();
                    
                } catch (error) {
                    console.error('CSV Import error:', error);
                    showNotification(`âŒ CSV-Import fehlgeschlagen: ${error.message}`, 'error');
                }
            };
            input.click();
        };

        const loadConnectedBanks = async () => {
            const settings = await getAllData('settings');
            const bankAPI = settings.find(s => s.key === 'bankAPI')?.value;
            const container = document.getElementById('connected-banks-list');

            if (!bankAPI || !bankAPI.connected) {
                container.innerHTML = '<p style="color: #6B7280;">Keine Banken verbunden.</p>';
                return;
            }

            container.innerHTML = `
                <div class="card">
                    <h4>${bankAPI.provider.toUpperCase()}</h4>
                    <p style="margin-top: 10px; color: #10B981;">â— Verbunden</p>
                    <button class="btn btn-secondary" style="margin-top: 15px;" onclick="manualImportNow()">ğŸ”„ Jetzt synchronisieren</button>
                </div>
            `;
        };

        const saveAutoImportSettings = async () => {
            const enabled = document.getElementById('auto-import-enabled').checked;
            const interval = document.getElementById('auto-import-interval').value;
            const autoCategorize = document.getElementById('auto-categorize').checked;

            await updateData('settings', {
                key: 'autoImport',
                value: { enabled, interval, autoCategorize }
            });

            showNotification('âœ… Auto-Import Einstellungen gespeichert!', 'success');

            if (enabled) {
                startAutoImport(parseInt(interval));
            }
        };

        const startAutoImport = (intervalMinutes) => {
            setInterval(async () => {
                await manualImportNow(true);
            }, intervalMinutes * 60 * 1000);
        };

        const manualImportNow = async (silent = false) => {
            if (!silent) showNotification('ğŸ”„ Importiere Transaktionen...', 'success');

            const settings = await getAllData('settings');
            const bankAPI = settings.find(s => s.key === 'bankAPI')?.value;

            if (!bankAPI || !bankAPI.connected) {
                if (!silent) showNotification('âŒ Keine Bank verbunden!', 'error');
                return;
            }

            try {
                // Fetch transactions from bank API
                const transactions = await fetchBankTransactions(bankAPI);
                
                // Auto-categorize if enabled
                const autoImport = settings.find(s => s.key === 'autoImport')?.value;
                
                for (const trans of transactions) {
                    if (autoImport?.autoCategorize) {
                        trans.category = await categorizeWithAI(trans.description);
                    }
                    await addData('transactions', trans);
                }

                if (!silent) showNotification(`âœ… ${transactions.length} Transaktionen importiert!`, 'success');
                await loadDashboard();
                await loadTransactions();
            } catch (error) {
                if (!silent) showNotification(`âŒ Import fehlgeschlagen: ${error.message}`, 'error');
            }
        };

        const fetchBankTransactions = async (bankAPI) => {
            // Real API implementation
            const url = `${bankAPI.endpoint}/transactions`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${bankAPI.apiKey}`,
                    'X-Client-Secret': bankAPI.apiSecret
                }
            });

            if (!response.ok) throw new Error('API request failed');

            const data = await response.json();
            
            // Transform API response to our format
            return data.transactions.map(t => ({
                type: t.amount > 0 ? 'income' : 'expense',
                amount: Math.abs(t.amount),
                description: t.description || t.merchant || 'Transaktion',
                date: t.date || new Date().toISOString().split('T')[0],
                account: 'Bank-Import',
                category: 'sonstiges',
                timestamp: new Date().toISOString()
            }));
        };

        // ==================== OCR & RECEIPT FUNCTIONS ====================
        const processReceipt = async (file) => {
            if (!file) {
                showNotification('âŒ Keine Datei ausgewÃ¤hlt', 'error');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                showNotification('âŒ Datei zu groÃŸ! Max 10 MB', 'error');
                return;
            }

            const progressDiv = document.getElementById('ocr-progress');
            const resultDiv = document.getElementById('ocr-result');
            
            if (progressDiv) progressDiv.style.display = 'block';
            if (resultDiv) resultDiv.style.display = 'none';

            try {
                // Check if Tesseract is available
                if (!window.Tesseract) {
                    showNotification('âš ï¸ OCR-Bibliothek nicht geladen. Manuelle Eingabe...', 'warning');
                    if (progressDiv) progressDiv.style.display = 'none';
                    if (resultDiv) {
                        resultDiv.style.display = 'block';
                        document.getElementById('receipt-date').value = new Date().toISOString().split('T')[0];
                    }
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageData = e.target.result;

                    try {
                        document.getElementById('ocr-status').textContent = 'OCR wird initialisiert...';
                        
                        // OCR Processing with Tesseract
                        const { data: { text } } = await Tesseract.recognize(
                            imageData,
                            'deu',
                            {
                                logger: (m) => {
                                    if (m.status === 'recognizing text') {
                                        const progress = Math.round(m.progress * 100);
                                        const progressBar = document.getElementById('ocr-progress-bar');
                                        const statusText = document.getElementById('ocr-status');
                                        if (progressBar) progressBar.style.width = progress + '%';
                                        if (statusText) statusText.textContent = `Erkenne Text... ${progress}%`;
                                    }
                                }
                            }
                        );

                        console.log('OCR Text:', text);

                        // Extract data from OCR text
                        const extractedData = extractReceiptData(text);
                        
                        // Fill form
                        document.getElementById('receipt-amount').value = extractedData.amount || '';
                        document.getElementById('receipt-merchant').value = extractedData.merchant || '';
                        document.getElementById('receipt-date').value = extractedData.date || new Date().toISOString().split('T')[0];
                        
                        // AI categorization
                        try {
                            const category = await categorizeWithAI(extractedData.merchant || text);
                            document.getElementById('receipt-category').value = category;
                        } catch (catError) {
                            console.error('Categorization error:', catError);
                        }

                        if (progressDiv) progressDiv.style.display = 'none';
                        if (resultDiv) resultDiv.style.display = 'block';
                        
                        // Store receipt image
                        await storeReceiptImage(imageData, extractedData);
                        
                        showNotification('âœ… Beleg erfolgreich erkannt!', 'success');
                    } catch (ocrError) {
                        console.error('OCR processing error:', ocrError);
                        showNotification(`âŒ OCR-Fehler: ${ocrError.message}. Bitte manuell eingeben.`, 'error');
                        
                        // Show form for manual entry
                        if (progressDiv) progressDiv.style.display = 'none';
                        if (resultDiv) {
                            resultDiv.style.display = 'block';
                            document.getElementById('receipt-date').value = new Date().toISOString().split('T')[0];
                        }
                    }
                };

                reader.onerror = () => {
                    showNotification('âŒ Fehler beim Lesen der Datei', 'error');
                    if (progressDiv) progressDiv.style.display = 'none';
                };

                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Receipt processing error:', error);
                showNotification(`âŒ Fehler: ${error.message}`, 'error');
                if (progressDiv) progressDiv.style.display = 'none';
            }
        };

        const extractReceiptData = (text) => {
            const data = {
                amount: null,
                merchant: null,
                date: null
            };

            // Extract amount (EUR, â‚¬, Euro)
            const amountMatch = text.match(/(\d+[,.]\d{2})\s*(?:EUR|â‚¬|Euro)/i);
            if (amountMatch) {
                data.amount = amountMatch[1].replace(',', '.');
            }

            // Extract date (DD.MM.YYYY or similar)
            const dateMatch = text.match(/(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})/);
            if (dateMatch) {
                const [, day, month, year] = dateMatch;
                data.date = `${year.length === 2 ? '20' + year : year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // Extract merchant (first line or common patterns)
            const lines = text.split('\n').filter(l => l.trim());
            if (lines.length > 0) {
                data.merchant = lines[0].trim();
            }

            return data;
        };

        const handleReceiptDrop = async (e) => {
            e.preventDefault();
            e.target.style.borderColor = 'var(--border)';
            const file = e.dataTransfer.files[0];
            if (file) await processReceipt(file);
        };

        const captureReceipt = () => {
            // Mobile camera capture
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.capture = 'environment'; // Use rear camera on mobile
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    showNotification('ğŸ“¸ Foto wird verarbeitet...', 'success');
                    await processReceipt(file);
                }
            };
            
            input.onerror = () => {
                showNotification('âŒ Kamera-Zugriff fehlgeschlagen', 'error');
            };
            
            input.click();
        };

        const storeReceiptImage = async (imageData, extractedData) => {
            await addData('receipts', {
                image: imageData,
                data: extractedData,
                timestamp: new Date().toISOString()
            });
        };

        const saveReceiptTransaction = async (e) => {
            e.preventDefault();

            const amount = parseFloat(document.getElementById('receipt-amount').value);
            const description = document.getElementById('receipt-merchant').value;
            const date = document.getElementById('receipt-date').value;
            const category = document.getElementById('receipt-category').value;

            if (!amount || amount <= 0) {
                showNotification('âŒ Bitte gÃ¼ltigen Betrag eingeben', 'error');
                return;
            }

            if (!description) {
                showNotification('âŒ Bitte Beschreibung eingeben', 'error');
                return;
            }

            const transaction = {
                type: 'expense',
                amount: amount,
                description: description,
                date: date,
                category: category,
                account: 'Beleg-Import',
                timestamp: new Date().toISOString(),
                hasReceipt: true
            };

            try {
                await addData('transactions', transaction);
                showNotification('âœ… Beleg als Transaktion gespeichert!', 'success');
                
                const resultDiv = document.getElementById('ocr-result');
                if (resultDiv) resultDiv.style.display = 'none';
                
                // Reset form
                document.getElementById('receipt-form').reset();
                
                await loadDashboard();
                await loadTransactions();
                await loadReceipts();
            } catch (error) {
                showNotification('âŒ Fehler beim Speichern: ' + error.message, 'error');
                console.error('Receipt transaction save error:', error);
            }
        };

        const loadReceipts = async () => {
            try {
                const receipts = await getAllData('receipts');
                const container = document.getElementById('receipts-list');

                if (!container) return;

                if (!receipts || receipts.length === 0) {
                    container.innerHTML = '<p style="color: #6B7280;">Noch keine Belege gespeichert.</p>';
                    return;
                }

                container.innerHTML = receipts.map((r, idx) => `
                    <div class="card" style="margin-bottom: 15px; display: flex; gap: 15px; align-items: center;">
                        <img src="${r.image}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 8px; cursor: pointer;" alt="Beleg" onclick="viewReceipt(${r.id})">
                        <div style="flex: 1;">
                            <h4>${r.data?.merchant || 'Unbekannt'}</h4>
                            <p>${formatCurrency(r.data?.amount || 0)} â€¢ ${formatDate(r.data?.date || new Date().toISOString())}</p>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-secondary" style="padding: 8px 15px; font-size: 0.9em;" onclick="exportReceipt(${r.id})">ğŸ’¾ Export</button>
                            <button class="btn btn-danger" style="padding: 8px 15px; font-size: 0.9em;" onclick="deleteReceipt(${r.id})">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading receipts:', error);
                const container = document.getElementById('receipts-list');
                if (container) {
                    container.innerHTML = '<p style="color: #EF4444;">Fehler beim Laden der Belege.</p>';
                }
            }
        };

        const exportReceipt = async (receiptId) => {
            try {
                const receipts = await getAllData('receipts');
                const receipt = receipts.find(r => r.id === receiptId);
                
                if (!receipt) {
                    showNotification('âŒ Beleg nicht gefunden', 'error');
                    return;
                }
                
                // ECHTES Original-Format: Bild + JSON-Daten
                const timestamp = new Date().toISOString().split('T')[0];
                
                // 1. Bild exportieren
                const imageLink = document.createElement('a');
                imageLink.href = receipt.image;
                imageLink.download = `beleg-${timestamp}-${receiptId}.jpg`;
                imageLink.click();
                
                // 2. OCR-Daten als JSON exportieren
                const jsonData = {
                    id: receipt.id,
                    timestamp: receipt.timestamp,
                    ocr_data: receipt.data,
                    merchant: receipt.data?.merchant,
                    amount: receipt.data?.amount,
                    date: receipt.data?.date
                };
                
                const jsonBlob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
                const jsonUrl = URL.createObjectURL(jsonBlob);
                const jsonLink = document.createElement('a');
                jsonLink.href = jsonUrl;
                jsonLink.download = `beleg-ocr-${timestamp}-${receiptId}.json`;
                jsonLink.click();
                URL.revokeObjectURL(jsonUrl);
                
                showNotification('âœ… Beleg exportiert (Bild + OCR-Daten)', 'success');
            } catch (error) {
                showNotification('âŒ Export-Fehler: ' + error.message, 'error');
            }
        };

        const exportAllReceipts = async () => {
            try {
                const receipts = await getAllData('receipts');
                
                if (receipts.length === 0) {
                    showNotification('âš ï¸ Keine Belege zum Exportieren', 'warning');
                    return;
                }
                
                showNotification(`ğŸ“¦ Exportiere ${receipts.length} Belege...`, 'success');
                
                // Export als JSON-Paket (mit Base64-Bildern)
                const exportData = {
                    version: '2.0.0',
                    export_date: new Date().toISOString(),
                    total_receipts: receipts.length,
                    receipts: receipts.map(r => ({
                        id: r.id,
                        timestamp: r.timestamp,
                        merchant: r.data?.merchant,
                        amount: r.data?.amount,
                        date: r.data?.date,
                        image_base64: r.image
                    }))
                };
                
                const json = JSON.stringify(exportData, null, 2);
                const timestamp = new Date().toISOString().split('T')[0];
                downloadFile(json, `alle-belege-${timestamp}.json`, 'application/json');
                
                showNotification('âœ… Alle Belege exportiert!', 'success');
            } catch (error) {
                showNotification('âŒ Export-Fehler: ' + error.message, 'error');
            }
        };

        const viewReceipt = async (receiptId) => {
            const receipts = await getAllData('receipts');
            const receipt = receipts.find(r => r.id === receiptId);
            
            if (receipt) {
                window.open(receipt.image, '_blank');
            }
        };

        const deleteReceipt = async (receiptId) => {
            if (confirm('Beleg wirklich lÃ¶schen?')) {
                try {
                    await deleteData('receipts', receiptId);
                    showNotification('âœ… Beleg gelÃ¶scht', 'success');
                    await loadReceipts();
                } catch (error) {
                    showNotification('âŒ Fehler: ' + error.message, 'error');
                }
            }
        };

        // ==================== AI & CATEGORIZATION ====================
        const categorizeWithAI = async (description) => {
            // Real AI categorization using OpenAI API or local ML model
            const settings = await getAllData('settings');
            const aiAPI = settings.find(s => s.key === 'aiAPI')?.value;

            if (aiAPI && aiAPI.apiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${aiAPI.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: 'Du bist ein Finanz-Kategorisierungs-Assistent. Kategorisiere Transaktionen in: lebensmittel, miete, freizeit, auto, gesundheit, gehalt, bonus, investition, sonstiges. Antworte nur mit der Kategorie.'
                            }, {
                                role: 'user',
                                content: `Kategorisiere: ${description}`
                            }],
                            max_tokens: 10,
                            temperature: 0.3
                        })
                    });

                    const data = await response.json();
                    return data.choices[0].message.content.trim().toLowerCase();
                } catch (error) {
                    console.error('AI categorization error:', error);
                }
            }

            // Fallback: Rule-based categorization
            const desc = description.toLowerCase();
            if (desc.includes('rewe') || desc.includes('edeka') || desc.includes('aldi') || desc.includes('lidl')) return 'lebensmittel';
            if (desc.includes('miete') || desc.includes('wohnung') || desc.includes('strom') || desc.includes('gas')) return 'miete';
            if (desc.includes('kino') || desc.includes('restaurant') || desc.includes('bar') || desc.includes('spotify')) return 'freizeit';
            if (desc.includes('tankstelle') || desc.includes('shell') || desc.includes('aral') || desc.includes('uber')) return 'auto';
            if (desc.includes('apotheke') || desc.includes('arzt') || desc.includes('kranken')) return 'gesundheit';
            if (desc.includes('gehalt') || desc.includes('lohn')) return 'gehalt';
            return 'sonstiges';
        };

        // ==================== GAMIFICATION FUNCTIONS ====================
        const loadAchievements = async () => {
            try {
                const transactions = await getAllData('transactions');
                const budgets = await getAllData('budgets');
                const receipts = await getAllData('receipts');
                
                const achievements = [];
                let xp = 0;

            // Achievement: Erste Transaktion
            if (transactions.length >= 1) {
                achievements.push({
                    icon: 'ğŸ¯',
                    title: 'Erster Schritt',
                    description: 'Erste Transaktion erfasst!',
                    xp: 10
                });
                xp += 10;
            }

            // Achievement: 10 Transaktionen
            if (transactions.length >= 10) {
                achievements.push({
                    icon: 'ğŸ“Š',
                    title: 'FleiÃŸiger Buchhalter',
                    description: '10 Transaktionen erfasst!',
                    xp: 50
                });
                xp += 50;
            }

            // Achievement: 100 Transaktionen
            if (transactions.length >= 100) {
                achievements.push({
                    icon: 'ğŸ†',
                    title: 'Finanz-Profi',
                    description: '100 Transaktionen erfasst!',
                    xp: 200
                });
                xp += 200;
            }

            // Achievement: Budget eingerichtet
            if (budgets.length >= 1) {
                achievements.push({
                    icon: 'ğŸ¯',
                    title: 'Budget-Meister',
                    description: 'Erstes Budget erstellt!',
                    xp: 25
                });
                xp += 25;
            }

            // Achievement: Beleg gescannt
            if (receipts.length >= 1) {
                achievements.push({
                    icon: 'ğŸ§¾',
                    title: 'OCR-Pionier',
                    description: 'Ersten Beleg gescannt!',
                    xp: 30
                });
                xp += 30;
            }

            // Achievement: Monat ohne Ãœberschreitung
            const currentMonth = new Date().getMonth();
            const monthExpenses = transactions.filter(t => 
                t.type === 'expense' && 
                new Date(t.date).getMonth() === currentMonth
            ).reduce((sum, t) => sum + parseFloat(t.amount), 0);

            const totalBudget = budgets.reduce((sum, b) => sum + parseFloat(b.limit), 0);
            if (budgets.length > 0 && monthExpenses <= totalBudget) {
                achievements.push({
                    icon: 'ğŸ’',
                    title: 'Sparfuchs',
                    description: 'Budget eingehalten!',
                    xp: 100
                });
                xp += 100;
            }

            // Calculate level
            const level = Math.floor(xp / 100) + 1;
            const levelProgress = (xp % 100);

            // Update UI
            const container = document.getElementById('achievements-container');
            if (container) {
                container.innerHTML = achievements.map(a => `
                    <div class="achievement">
                        <div class="achievement-icon">${a.icon}</div>
                        <div>
                            <strong>${a.title}</strong><br>
                            <small>${a.description} (+${a.xp} XP)</small>
                        </div>
                    </div>
                `).join('');
            }

            const levelBar = document.getElementById('level-progress');
            const levelText = document.getElementById('level-text');
            if (levelBar) levelBar.style.width = levelProgress + '%';
            
            const levelTitles = [
                'Finanz-AnfÃ¤nger',
                'Budget-Bewusst',
                'Spar-Enthusiast',
                'Finanz-Profi',
                'Investitions-Guru',
                'Wohlstands-Meister'
            ];
            
            if (levelText) {
                levelText.textContent = `Level ${level} - ${levelTitles[Math.min(level - 1, levelTitles.length - 1)]} (${xp} XP)`;
            }

                return { achievements, xp, level };
            } catch (error) {
                console.error('Error loading achievements:', error);
                return { achievements: [], xp: 0, level: 1 };
            }
        };

        // ==================== HELPER FUNCTIONS ====================
        const formatCurrency = (amount) => {
            try {
                if (amount === null || amount === undefined) return '0,00 â‚¬';
                
                const num = parseFloat(amount);
                if (isNaN(num)) return '0,00 â‚¬';
                
                // Check if Intl is available
                if (typeof Intl !== 'undefined' && Intl.NumberFormat) {
                    return new Intl.NumberFormat('de-DE', {
                        style: 'currency',
                        currency: 'EUR'
                    }).format(num);
                }
                
                // Fallback: Manual formatting
                const fixed = num.toFixed(2);
                const parts = fixed.split('.');
                const integer = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                return `${integer},${parts[1]} â‚¬`;
            } catch (error) {
                console.error('Currency formatting error:', error, 'for amount:', amount);
                return '0,00 â‚¬';
            }
        };

        const formatDate = (dateString) => {
            try {
                if (!dateString) return '-';
                const date = new Date(dateString);
                
                // Check if Intl is available
                if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
                    return new Intl.DateTimeFormat('de-DE').format(date);
                }
                
                // Fallback: Manual formatting
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            } catch (error) {
                console.error('Date formatting error:', error, 'for date:', dateString);
                return dateString; // Return original if all fails
            }
        };

        const showNotification = (message, type = 'success') => {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = message.replace(/\n/g, '<br>');
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s';
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        };

        // ==================== INITIALIZATION ====================
        const init = async () => {
            try {
                console.log('ğŸ”„ Initializing TEL Haushaltsbuch 2025...');
                
                // CRITICAL: Initialize database FIRST and WAIT
                await initDB();
                
                // Double-check database is ready
                if (!db || !dbReady) {
                    throw new Error('Database initialization failed');
                }
                
                console.log('âœ… Database ready, loading data...');
                
                // Now safe to load data
                await loadDashboard();
                
                // Set current month in filter
                const now = new Date();
                const monthInput = document.getElementById('filter-month');
                if (monthInput) {
                    monthInput.value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                }

                console.log('âœ… Application ready');
                showNotification('âœ… TEL Haushaltsbuch 2025 bereit!', 'success');
            } catch (error) {
                console.error('âŒ CRITICAL Initialization error:', error);
                showNotification('âŒ Fehler beim Laden: ' + error.message, 'error');
                
                // Show user-friendly error
                const content = document.querySelector('.content');
                if (content) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 50px;">
                            <h2 style="color: #EF4444;">âŒ Fehler beim Laden</h2>
                            <p>${error.message}</p>
                            <button class="btn" onclick="location.reload()">ğŸ”„ Neu laden</button>
                        </div>
                    `;
                }
            }
        };

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Add CSS animation for slide out
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideOutRight {
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>

