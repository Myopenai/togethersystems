<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vollst√§ndiges Musikbildungsprogramm ‚Äì 50+ Tools f√ºr Gitarre, Klavier, Theorie, Geh√∂rbildung, Rhythmus, Komposition & Produktion</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
    body { margin: 0; background:#fafafa; color:#111; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:16px; padding:16px; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .row { display:grid; gap:12px; grid-template-columns: 1fr; }
    @media (min-width: 860px){ .row{ grid-template-columns: 1fr 1fr; } }
    label { font-size: 12px; opacity:.8; display:block; margin-bottom:6px; }
    input[type="text"], textarea, select { width:100%; padding:10px 12px; border:1px solid #e5e7eb; border-radius:12px; outline:none; }
    textarea { resize:vertical; min-height:88px; }
    .btn { padding:10px 14px; border-radius:12px; border:1px solid #e5e7eb; background:#111; color:#fff; cursor:pointer; }
    .btn.sec { background:#fff; color:#111; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .small { font-size:12px; opacity:.7 }
    .grid { display:grid; gap:12px; }
    .chords { 
  display: grid; 
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
  gap: 12px; 
  max-width: 100%;
  overflow-x: auto;
}

.chords .chord-display {
  min-width: 180px;
  max-width: 300px;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Responsive Design f√ºr viele Akkorde */
@media (max-width: 768px) {
  .chords {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 8px;
  }
  
  .chords .chord-display {
    min-width: 140px;
    max-width: 200px;
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .chords {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 6px;
  }
  
  .chords .chord-display {
    min-width: 110px;
    max-width: 160px;
    font-size: 12px;
  }
}
    .center { display:flex; align-items:center; justify-content:center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:#f8fafc; border:1px solid #e5e7eb; border-radius:12px; padding:12px; white-space:pre; overflow:auto; }
    .muted { color:#6b7280 }
    
    .hero-out {
      font-size: clamp(18px, 2.4vw, 28px);
      font-weight: 800;
      line-height: 1.2;
      padding: 12px 14px;
      border-radius: 14px;
      background: linear-gradient(135deg, #fdf2f8, #eef2ff);
      border: 1px solid #e5e7eb;
      box-shadow: 0 8px 24px rgba(99,102,241,0.08);
      color:#111;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    
    .hero-out .badge {
      font-size:12px;
      font-weight:700;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#fff;
    }
    
    .hero-out .chords {
      font-variant-numeric: tabular-nums;
      letter-spacing: .5px;
    }
    
    .sticky-tools {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
      border-bottom:1px solid #e5e7eb;
      padding:6px 0;
    }
    
    .controls-row {
      display:flex;
      align-items:center;
      gap:12px;
      margin:8px 0 0;
      flex-wrap:wrap;
    }
    
    .controls-row label {
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 14px;
      user-select:none;
    }
    
    .mega-out {
      font-size: clamp(28px, 6vw, 64px);
      font-weight: 900;
      line-height: 1.1;
      letter-spacing: .6px;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 18px;
      background: #fff;
      border: 1px dashed #c7c9d1;
      box-shadow: 0 6px 18px rgba(0,0,0,.06) inset;
      color:#0b0b0c;
      word-break: break-word;
    }
    
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 18, 25, .92);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 4vw;
      z-index: 50;
    }
    
    .overlay.active { display:flex; }
    
    .overlay .mega-text {
      font-size: min(12vw, 120px);
      font-weight: 900;
      text-align: center;
    }
    
    /* TEL & Gentlyoverdone Styles */
    .tel-embed {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #111, #1a1a1a);
      color: #eee;
      padding: 2rem;
      border-radius: 16px;
      margin: 2rem auto;
      max-width: 1200px;
    }
    .tel-header {
      text-align: center;
      background: #1db954;
      color: #fff;
      border-radius: 12px;
      padding: 2rem 1rem;
      animation: fadeIn 1.5s ease-in;
    }
    .tel-header img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin-bottom: 1rem;
    }
    .tel-section {
      margin: 2rem 0;
      animation: slideIn 1s ease-out;
    }
    .tel-section h2 {
      color: #1db954;
      text-align: center;
      margin-bottom: 1rem;
    }
    .tel-section iframe {
      width: 100%;
      height: 315px;
      border: none;
      border-radius: 12px;
      display: block;
      margin: 0 auto;
    }
    .tel-info p {
      text-align: center;
      max-width: 800px;
      margin: 1rem auto;
      line-height: 1.6;
    }
    .tel-socials {
      text-align: center;
      margin-top: 2rem;
    }
    .tel-socials a {
      margin: 0 12px;
      text-decoration: none;
      color: #1db954;
      font-weight: bold;
      font-size: 1.2rem;
      transition: color 0.3s;
    }
    .tel-socials a:hover {
      color: #1fff75;
    }

    @media (max-width: 768px) {
      .tel-embed {
        padding: 1rem;
      }
      .tel-section iframe {
        height: 250px;
      }
      .tel-socials a {
        display: inline-block;
        margin: 0.5rem;
        font-size: 1rem;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideIn {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .overlay .mega-text {
      line-height: 1.05;
      word-break: break-word;
    }
    
    .overlay .close-btn {
      position: absolute;
      top: 14px;
      right: 16px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.06);
      cursor: pointer;
      font-weight: 700;
    }
    
    /* Tab Navigation */
    .nav-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 10px;
    }
    
    .nav-tab {
      padding: 12px 20px;
      border: none;
      background: #f8f9fa;
      color: #6b7280;
      border-radius: 12px 12px 0 0;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .nav-tab:hover {
      background: #e5e7eb;
      color: #374151;
    }
    
    .nav-tab.active {
      background: #007acc;
      color: white;
    }
    
    /* Tab Content */
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Media Grid */
    .media-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .media-grid .card {
      padding: 20px;
    }
    
    .media-grid h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #1f2937;
    }
    
    /* Project Management */
    .project-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 10px;
    }
    
    .project-item {
      padding: 10px;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .project-item:hover {
      background: #f9fafb;
    }
    
    .project-item:last-child {
      border-bottom: none;
    }
    
    /* Notes Editor */
    .live-notes {
      min-height: 200px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      font-family: 'Courier New', monospace;
    }
    
    .media-player-container {
      min-height: 200px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
    }
    
    .media-controls {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border-radius: 6px;
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .media-controls button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: #1db954;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }
    
    .media-controls button:hover {
      background: #1ed760;
    }
    
    .media-controls input[type="range"] {
      flex: 1;
      min-width: 100px;
    }
    
    .media-controls span {
      font-family: monospace;
      font-size: 12px;
      color: #666;
      min-width: 80px;
    }
    
    /* TEL & Gentlyoverdone Media-Bereich Styles */
    .tel-embed {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #111, #1a1a1a);
      color: #eee;
      padding: 2rem;
      border-radius: 16px;
      margin: 2rem auto;
      max-width: 1200px;
    }
    .tel-header {
      text-align: center;
      background: #1db954;
      color: #fff;
      border-radius: 12px;
      padding: 2rem 1rem;
      animation: fadeIn 1.5s ease-in;
    }
    .tel-header img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin-bottom: 1rem;
    }
    .tel-section {
      margin: 2rem 0;
      animation: slideIn 1s ease-out;
    }
    .tel-section h2 {
      color: #1db954;
      text-align: center;
      margin-bottom: 1rem;
    }
    .tel-section iframe {
      width: 100%;
      height: 315px;
      border: none;
      border-radius: 12px;
      display: block;
      margin: 0 auto;
    }
    .tel-info p {
      text-align: center;
      max-width: 800px;
      margin: 1rem auto;
      line-height: 1.6;
    }
    .tel-socials {
      text-align: center;
      margin-top: 2rem;
    }
    .tel-socials a {
      margin: 0 12px;
      text-decoration: none;
      color: #1db954;
      font-weight: bold;
      font-size: 1.2rem;
      transition: color 0.3s;
    }
    .tel-socials a:hover {
      color: #1fff75;
    }

    @media (max-width: 768px) {
      .tel-embed {
        padding: 1rem;
      }
      .tel-section iframe {
        height: 250px;
      }
      .tel-socials a {
        display: inline-block;
        margin: 0.5rem;
        font-size: 1rem;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideIn {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .nav-tabs {
        flex-wrap: wrap;
      }
      
      .media-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
  
  <!-- jsPDF via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
  
  <!-- VexFlow ESM-Import mit Fallback -->
  <script>
    // Dynamischer ESM-Import f√ºr VexFlow
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        console.log('Lade VexFlow via ESM...');
        // ESM-Build laden (korrekte Entry-Datei)
        const VexMod = await import('https://cdn.jsdelivr.net/npm/vexflow@4.2.3/build/esm/entry/vexflow.js');
        
        // Global verf√ºgbar machen, egal ob der Rest deines Codes Vex oder VexFlow erwartet
        window.Vex = VexMod;
        window.VexFlow = VexMod;
        console.log('VexFlow via ESM erfolgreich geladen');
if (!window.Vex && VexMod) window.Vex = VexMod;
if (!window.VexFlow && VexMod) window.VexFlow = VexMod;
        
        // Jetzt deine App initialisieren
        // App initialisieren
        console.log('üéµ Musical Education Program wird initialisiert...');
        
        // Tone.js initialisieren
        if (window.Tone) {
          window.Tone.start();
          console.log('üéµ Tone.js Audio Engine gestartet');
        }
        
        // Live-Akkord-Sharing starten
        if (typeof testLiveChordSharing === 'function') {
          testLiveChordSharing();
        }
        
        console.log('‚úÖ App erfolgreich initialisiert');
      } catch (e) {
        console.warn('VexFlow ESM-Laden fehlgeschlagen, aktiviere Mock:', e);
        activateMockVexFlow();
        
        // App auch mit Mock initialisieren
        console.log('üéµ Musical Education Program wird mit Mock initialisiert...');
        if (window.Tone) {
          window.Tone.start();
          console.log('üéµ Tone.js Audio Engine gestartet');
        }
        if (typeof testLiveChordSharing === 'function') {
          testLiveChordSharing();
        }
        console.log('‚úÖ App erfolgreich mit Mock initialisiert');
      }
    });
    
    // Mock VexFlow als letzter Ausweg
    function activateMockVexFlow() {
      window.VexFlow = {
        Renderer: class MockRenderer {
          constructor(element, backend) {
            this.element = element;
            this.backend = backend;
          }
          resize() {}
          getContext() {
            return {
              draw() {},
              setContext() { return this; }
            };
          }
        },
        Stave: class MockStave {
          constructor(x, y, width) {
            this.x = x; this.y = y; this.width = width;
          }
          setContext() { return this; }
          draw() {}
        },
        StaveNote: class MockStaveNote {
          constructor(options) {
            this.options = options;
          }
          setContext() { return this; }
          draw() {}
        },
        TabStave: class MockTabStave {
          constructor(x, y, width) {
            this.x = x; this.y = y; this.width = width;
          }
          setContext() { return this; }
          draw() {}
        },
        TabNote: class MockTabNote {
          constructor(options) {
            this.options = options;
          }
          setContext() { return this; }
          draw() {}
        },
        Voice: class MockVoice {
          constructor(options) {
            this.options = options;
          }
          addTickables() { return this; }
        },
        Formatter: class MockFormatter {
          joinVoices() { return this; }
          format() {}
        }
      };
      
      console.log('Mock VexFlow aktiviert - Notation wird vereinfacht dargestellt');
    }
  </script>
</head>
<body>
<script>
// --- Hardened safety shims (no UI/UX change) ---
(function(){
  'use strict';
  if (window.__MEP_SHIMS__) return; window.__MEP_SHIMS__ = true;
  const noop = function(){};
  if (!window.performanceManager) {
    window.performanceManager = {
      moduleCache: new Map(),
      processChordsOptimized: async (chords)=>Array.isArray(chords) ? chords : [],
      get memoryUsage(){ return {usedJSHeapSize:0,totalJSHeapSize:0,jsHeapSizeLimit:0}; },
      logEvent: noop, updateUI: noop
    };
  }
  if (typeof window.compute !== 'function') window.compute = function(){};
  if (typeof window.playChord !== 'function') window.playChord = function(){};
  // Safe globals for 'inp' and 'target'
  const assignIfMissing = (name, el) => {
    if (typeof window[name] === 'undefined' || window[name] === null) window[name] = el || null;
  };
  function initGlobals(){
    try {
      assignIfMissing('inp', document.getElementById('inp'));
      assignIfMissing('target', document.getElementById('target'));
    } catch(e){}
  }
  if (document.readyState !== 'loading') initGlobals();
  else document.addEventListener('DOMContentLoaded', initGlobals, { once:true });
})();
</script>

  <div class="wrap">
    <!-- Navigation Tabs -->
    <nav class="nav-tabs">
      <button class="nav-tab active" data-tab="guitar">üé∏ Gitarre</button>
      <button class="nav-tab" data-tab="piano">üéπ Klavier</button>
      <button class="nav-tab" data-tab="theory">üìö Theorie</button>
      <button class="nav-tab" data-tab="ear">üëÇ Geh√∂r</button>
      <button class="nav-tab" data-tab="rhythm">ü•Å Rhythmus</button>
      <button class="nav-tab" data-tab="composition">‚úçÔ∏è Komposition</button>
      <button class="nav-tab" data-tab="production">üéõÔ∏è Produktion</button>
      <button class="nav-tab" data-tab="daw">üéõÔ∏è DAW</button>
      <button class="nav-tab" data-tab="live">üé§ Live</button>
      <button class="nav-tab" data-tab="media">üì∫ Media</button>
      <button class="nav-tab" data-tab="projects">üíæ Projekte</button>
      <button class="nav-tab" data-tab="notes">üéº Noten</button>
    </nav>
    
    <!-- Gitarren-Tab -->
    <div id="guitar-tab" class="tab-content active">
      <header class="card" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <h1 style="margin:0; font-size:22px; font-weight:800">üéµ Vollst√§ndiges Musikbildungsprogramm ‚Äì 50+ Tools</h1>
        <div class="small muted">Gitarre, Klavier, Theorie, Geh√∂rbildung, Rhythmus, Komposition & Produktion</div>
      </header>

    <!-- Live-Akkord-Sharing Status -->
    <section class="card" style="margin-top:12px; background:#e8f5e8; border-left:4px solid #1db954;">
      <h2 style="margin-top:0;">üé∏ Live-Akkord-Sharing aktiv</h2>
      <p><strong>Alle eingegebenen Akkorde werden automatisch an alle Tools weitergegeben!</strong></p>
      <div id="liveChordStatus" style="margin:10px 0; padding:10px; background:white; border-radius:6px;">
        <strong>Status:</strong> <span id="chordStatusText">√úberwache Akkorde...</span>
      </div>
      <div class="controls">
        
      </div>
    </section>

    <!-- Akkord-Bibliothek -->
    <section class="card" style="margin-top:12px;">
      <h2 style="margin-top:0;">üéµ H√§ufige Akkordfolgen - Alle Genres</h2>
      <div class="controls" style="flex-wrap:wrap; gap:8px;">
        <!-- Pop -->
        <button class="btn sec" onclick="loadProgression('C G Am F')">Pop (C G Am F)</button>
        <button class="btn sec" onclick="loadProgression('Am F C G')">Pop (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C Am F G')">Pop (C Am F G)</button>
        <button class="btn sec" onclick="loadProgression('G D Em C')">Pop (G D Em C)</button>
        <button class="btn sec" onclick="loadProgression('E B C#m A')">Pop (E B C#m A)</button>
        
        <!-- Blues -->
        <button class="btn sec" onclick="loadProgression('C F G')">Blues (C F G)</button>
        <button class="btn sec" onclick="loadProgression('A D E')">Blues (A D E)</button>
        <button class="btn sec" onclick="loadProgression('G C D')">Blues (G C D)</button>
        
        <!-- Jazz -->
        <button class="btn sec" onclick="loadProgression('Am Dm G C')">Jazz (Am Dm G C)</button>
        <button class="btn sec" onclick="loadProgression('Dm G C')">Jazz (Dm G C)</button>
        <button class="btn sec" onclick="loadProgression('ii V I')">Jazz (ii V I)</button>
        
        <!-- Rock -->
        <button class="btn sec" onclick="loadProgression('E A B')">Rock (E A B)</button>
        <button class="btn sec" onclick="loadProgression('A D E')">Rock (A D E)</button>
        <button class="btn sec" onclick="loadProgression('G C D')">Rock (G C D)</button>
        
        <!-- Folk -->
        <button class="btn sec" onclick="loadProgression('G D C')">Folk (G D C)</button>
        <button class="btn sec" onclick="loadProgression('C G Am')">Folk (C G Am)</button>
        <button class="btn sec" onclick="loadProgression('D G A')">Folk (D G A)</button>
        
        <!-- Punk -->
        <button class="btn sec" onclick="loadProgression('E A')">Punk (E A)</button>
        <button class="btn sec" onclick="loadProgression('A E')">Punk (A E)</button>
        <button class="btn sec" onclick="loadProgression('G C')">Punk (G C)</button>
        
        <!-- Techno -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">Techno (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C G Am F')">Techno (C G Am F)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Techno (F C G Am)</button>
        
        <!-- Country -->
        <button class="btn sec" onclick="loadProgression('G C D')">Country (G C D)</button>
        <button class="btn sec" onclick="loadProgression('C F G')">Country (C F G)</button>
        <button class="btn sec" onclick="loadProgression('D G A')">Country (D G A)</button>
        
        <!-- Reggae -->
        <button class="btn sec" onclick="loadProgression('C F G')">Reggae (C F G)</button>
        <button class="btn sec" onclick="loadProgression('Am Dm G')">Reggae (Am Dm G)</button>
        <button class="btn sec" onclick="loadProgression('G C D')">Reggae (G C D)</button>
        
        <!-- Metal -->
        <button class="btn sec" onclick="loadProgression('E A B')">Metal (E A B)</button>
        <button class="btn sec" onclick="loadProgression('A D E')">Metal (A D E)</button>
        <button class="btn sec" onclick="loadProgression('D G A')">Metal (D G A)</button>
        
        <!-- Electronic -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">Electronic (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C G Am F')">Electronic (C G Am F)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Electronic (F C G Am)</button>
        
        <!-- Polka -->
        <button class="btn sec" onclick="loadProgression('C F G')">Polka (C F G)</button>
        <button class="btn sec" onclick="loadProgression('G C D')">Polka (G C D)</button>
        <button class="btn sec" onclick="loadProgression('D G A')">Polka (D G A)</button>
        
        <!-- Ska -->
        <button class="btn sec" onclick="loadProgression('C F G')">Ska (C F G)</button>
        <button class="btn sec" onclick="loadProgression('Am F C G')">Ska (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('G C D')">Ska (G C D)</button>
        
        <!-- Funk -->
        <button class="btn sec" onclick="loadProgression('C F')">Funk (C F)</button>
        <button class="btn sec" onclick="loadProgression('G C')">Funk (G C)</button>
        <button class="btn sec" onclick="loadProgression('D G')">Funk (D G)</button>
        
        <!-- Soul -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">Soul (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C Am F G')">Soul (C Am F G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Soul (F C G Am)</button>
        
        <!-- R&B -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">R&B (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C Am F G')">R&B (C Am F G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">R&B (F C G Am)</button>
        
        <!-- Hip-Hop -->
        <button class="btn sec" onclick="loadProgression('C F')">Hip-Hop (C F)</button>
        <button class="btn sec" onclick="loadProgression('G C')">Hip-Hop (G C)</button>
        <button class="btn sec" onclick="loadProgression('D G')">Hip-Hop (D G)</button>
        
        <!-- Disco -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">Disco (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C Am F G')">Disco (C Am F G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Disco (F C G Am)</button>
        
        <!-- House -->
        <button class="btn sec" onclick="loadProgression('C F')">House (C F)</button>
        <button class="btn sec" onclick="loadProgression('G C')">House (G C)</button>
        <button class="btn sec" onclick="loadProgression('D G')">House (D G)</button>
        
        <!-- Trance -->
        <button class="btn sec" onclick="loadProgression('C G Am F')">Trance (C G Am F)</button>
        <button class="btn sec" onclick="loadProgression('Am F C G')">Trance (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Trance (F C G Am)</button>
        
        <!-- Dubstep -->
        <button class="btn sec" onclick="loadProgression('C F')">Dubstep (C F)</button>
        <button class="btn sec" onclick="loadProgression('G C')">Dubstep (G C)</button>
        <button class="btn sec" onclick="loadProgression('D G')">Dubstep (D G)</button>
        
        <!-- Ambient -->
        <button class="btn sec" onclick="loadProgression('C Am')">Ambient (C Am)</button>
        <button class="btn sec" onclick="loadProgression('F C')">Ambient (F C)</button>
        <button class="btn sec" onclick="loadProgression('G D')">Ambient (G D)</button>
        
        <!-- Klassisch -->
        <button class="btn sec" onclick="loadProgression('C F G C')">Klassisch (C F G C)</button>
        <button class="btn sec" onclick="loadProgression('Dm G C')">Klassisch (Dm G C)</button>
        <button class="btn sec" onclick="loadProgression('Am Dm G C')">Klassisch (Am Dm G C)</button>
        
        <!-- Barock -->
        <button class="btn sec" onclick="loadProgression('C F G C')">Barock (C F G C)</button>
        <button class="btn sec" onclick="loadProgression('Dm G C')">Barock (Dm G C)</button>
        <button class="btn sec" onclick="loadProgression('Am Dm G C')">Barock (Am Dm G C)</button>
        
        <!-- Romantik -->
        <button class="btn sec" onclick="loadProgression('Am F C G')">Romantik (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('C Am F G')">Romantik (C Am F G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Romantik (F C G Am)</button>
        
        <!-- Modern -->
        <button class="btn sec" onclick="loadProgression('C G Am F')">Modern (C G Am F)</button>
        <button class="btn sec" onclick="loadProgression('Am F C G')">Modern (Am F C G)</button>
        <button class="btn sec" onclick="loadProgression('F C G Am')">Modern (F C G Am)</button>
        
        <!-- Experimental -->
        <button class="btn sec" onclick="loadProgression('C Db C')">Experimental (C Db C)</button>
        <button class="btn sec" onclick="loadProgression('C Eb F')">Experimental (C Eb F)</button>
        <button class="btn sec" onclick="loadProgression('C Ab Bb')">Experimental (C Ab Bb)</button>
      </div>
    </section>

    <section class="row" style="margin-top:12px;">
      <div class="card grid sticky-tools">
        <div>
          <label for="inp">Akkordfolge (z. B. "C G Am F | Dm G C")</label>
          <textarea id="inp" spellcheck="false">C G Am F | Dm G C C</textarea>
        </div>
        <div class="grid" style="grid-template-columns: repeat(2, minmax(0,1fr));">
          <div>
            <label for="orig">Originaltonart</label>
            <select id="orig">
              <option value="C">C Dur</option>
              <option value="C#">C# Dur</option>
              <option value="D">D Dur</option>
              <option value="D#">D# Dur</option>
              <option value="E">E Dur</option>
              <option value="F">F Dur</option>
              <option value="F#">F# Dur</option>
              <option value="G">G Dur</option>
              <option value="G#">G# Dur</option>
              <option value="A">A Dur</option>
              <option value="A#">A# Dur</option>
              <option value="B">B Dur</option>
              <option value="Cm">C Moll</option>
              <option value="C#m">C# Moll</option>
              <option value="Dm">D Moll</option>
              <option value="D#m">D# Moll</option>
              <option value="Em">E Moll</option>
              <option value="Fm">F Moll</option>
              <option value="F#m">F# Moll</option>
              <option value="Gm">G Moll</option>
              <option value="G#m">G# Moll</option>
              <option value="Am">A Moll</option>
              <option value="A#m">A# Moll</option>
              <option value="Bm">B Moll</option>
            </select>
          </div>
          <div>
            <label for="target">Zieltonart</label>
            <select id="target">
              <option value="C">C Dur</option>
              <option value="C#">C# Dur</option>
              <option value="D">D Dur</option>
              <option value="D#">D# Dur</option>
              <option value="E">E Dur</option>
              <option value="F">F Dur</option>
              <option value="F#">F# Dur</option>
              <option value="G">G Dur</option>
              <option value="G#">G# Dur</option>
              <option value="A">A Dur</option>
              <option value="A#">A# Dur</option>
              <option value="B">B Dur</option>
              <option value="Cm">C Moll</option>
              <option value="C#m">C# Moll</option>
              <option value="Dm">D Moll</option>
              <option value="D#m">D# Moll</option>
              <option value="Em">E Moll</option>
              <option value="Fm">F Moll</option>
              <option value="F#m">F# Moll</option>
              <option value="Gm">G Moll</option>
              <option value="G#m">G# Moll</option>
              <option value="Am">A Moll</option>
              <option value="A#m">A# Moll</option>
              <option value="Bm">B Moll</option>
            </select>
          </div>
          <div>
            <label for="semi">Transponieren ¬± Halbt√∂ne</label>
            <input id="semi" type="range" min="-11" max="11" value="0" />
            <div class="small"><span id="semiLbl">0</span> HT</div>
          </div>
          <div>
            <label for="capo">Capo</label>
            <input id="capo" type="range" min="0" max="9" value="0" />
            <div class="small">Bund <span id="capoLbl">0</span></div>
          </div>
          <div>
            <label for="tuning">Stimmung</label>
            <select id="tuning">
              <option value="standard">Standard (E A D G B E)</option>
              <option value="dropd">Drop D (D A D G B E)</option>
              <option value="dadgad">DADGAD (D A D G A D)</option>
              <option value="openG">Open G (D G D G B D)</option>
              <option value="openC">Open C (C G C G C E)</option>
              <option value="openD">Open D (D A D F# A D)</option>
              <option value="openE">Open E (E B E G# B E)</option>
              <option value="openA">Open A (E A E A C# E)</option>
              <option value="halfstep">Halber Ton runter (Eb Ab Db Gb Bb Eb)</option>
              <option value="wholestep">Ganzer Ton runter (D G C F A D)</option>
              <option value="capo2">Capo 2. Bund (F# B E A C# F#)</option>
              <option value="capo3">Capo 3. Bund (G C F Bb D G)</option>
              <option value="capo4">Capo 4. Bund (Ab Db Gb B Eb Ab)</option>
              <option value="capo5">Capo 5. Bund (A D G C E A)</option>
            </select>
          </div>
          <div>
            <label for="pattern">Strumming</label>
            <select id="pattern">
              <option>Downstrum</option>
              <option>DownUp</option>
              <option>Arpeggio</option>
            </select>
          </div>
          <div>
            <label for="tempo">Tempo (BPM)</label>
            <input id="tempo" type="range" min="40" max="160" value="84" />
            <div class="small"><span id="tempoLbl">84</span> BPM</div>
          </div>
          <div>
            <label>Komfort</label>
            <div class="controls">
              <label class="small"><input id="lefty" type="checkbox" /> Linksh√§nder</label>
              <label class="small"><input id="easy" type="checkbox" /> Einfache Griffe</label>
            </div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="play">‚ñ∂Ô∏é Abspielen</button>
          <button class="btn sec" id="stop">‚èπ Stop</button>
          <button class="btn sec" id="metronome">ü•Å Metronom</button>
          <button class="btn sec" id="export">ASCII‚ÄëTAB exportieren</button>
          <button class="btn sec" id="pdfExport">üìÑ PDF exportieren</button>
          <button class="btn sec" id="saveProg">üíæ Speichern</button>
          <button class="btn sec" id="loadProg">üìÇ Laden</button>
                      <button class="btn sec" onclick="toggleChordDisplay()" id="toggleDisplay">üîÑ Griffbild-Stil wechseln</button>
            <button class="btn sec" onclick="testCompute()" style="background:#ff6b6b;">üß™ Test Compute</button>
            <button class="btn sec" onclick="toggleNotation()" style="background:#8b5cf6;">üéº Notensystem</button>
            <button class="btn sec" onclick="toggleFretboardMode()" style="background:#10b981;">üé∏ Fretboard-Modus</button>

                      <button class="btn sec" id="enableAudio" onclick="enableAudioExplicitly()" style="background:#f59e0b;">üîä Audio aktivieren</button>
          <span class="small muted" id="status"></span>
        </div>
        
        <div class="hero-out" id="heroOut">
          <span class="badge">Transponiert</span>
          <span id="out" class="chords"></span>
        </div>
        <div class="controls-row" aria-label="Transponieren Anzeige">
          <label><input type="checkbox" id="toggleHero" checked> Hero-Highlight anzeigen</label>
          <button id="btnMega" type="button">üñ•Ô∏è Vollbild‚ÄëHeadline</button>
        </div>
        
        <!-- Song Repetition Controls -->
        <div class="controls-row" aria-label="Song Wiederholung" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
          <h4 style="margin: 0 0 10px 0;">üîÑ Song-Wiederholung</h4>
          <div class="controls">
            <button onclick="startSongRepetition()" class="btn">‚ñ∂Ô∏è Wiederholung starten</button>
            <button onclick="stopSongRepetition()" class="btn">‚èπÔ∏è Stoppen</button>
            <select onchange="setRepetitionCount(parseInt(this.value))" style="width: auto; margin-left: 10px;">
              <option value="1">1x</option>
              <option value="2">2x</option>
              <option value="3" selected>3x</option>
              <option value="5">5x</option>
              <option value="10">10x</option>
            </select>
            <span style="margin-left: 10px; font-size: 12px; color: #666;">Wiederholungen</span>
          </div>
          <div id="repetitionProgress" style="margin-top: 10px; background: #e5e7eb; height: 4px; border-radius: 2px; overflow: hidden;">
            <div style="background: #007acc; height: 100%; width: 0%; transition: width 0.3s;"></div>
          </div>
        </div>
        <div id="megaOut" class="mega-out" title="√úbergro√üe Headline der transponierten Akkorde"></div>
        <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Transponierte Akkorde Vollbild">
          <button class="close-btn" id="btnClose">Schlie√üen</button>
          <div id="overlayText" class="mega-text"></div>
        </div>
      </div>


    </section>

    <section class="card" style="margin-top:12px;">
      <h2 style="margin-top:0;">Griffbilder</h2>
      <div id="diagrams" class="chords"></div>
    </section>

    <section class="card" style="margin-top:12px;">
      <h2 style="margin-top:0;">ASCII‚ÄëTAB Vorschau</h2>
      <pre id="ascii" class="mono"></pre>
    </section>

    <!-- VexFlow Notation Section -->
    <section class="card" style="margin-top:12px;">
      <h2 style="margin-top:0;">üéº Musiknotation</h2>
      <div id="vf-notes" style="margin-bottom:16px; min-height:120px; border:1px solid #e5e7eb; border-radius:8px; padding:8px; background:#fafafa;">
        <p style="color:#666; text-align:center; margin:20px 0;">Lade VexFlow f√ºr Musiknotation...</p>
      </div>
      <div id="vf-tab" style="min-height:120px; border:1px solid #e5e7eb; border-radius:8px; padding:8px; background:#fafafa;">
        <p style="color:#666; text-align:center; margin:20px 0;">Lade VexFlow f√ºr Tabulatur...</p>
      </div>
    </section>

    <footer class="small muted" style="margin:18px 0;">
      Tipp: Akkorde wie D/F#, sus/add funktionieren. Exotische Griffe ggf. manuell anpassen.
    </footer>

    <!-- Producer Info & Kontakt -->
    <section class="card" style="margin-top:12px; text-align:center;">
      <h2 style="margin-top:0;">üéµ Producer & Kontakt</h2>
      <div style="margin-bottom:16px;">
        <p style="margin:8px 0;"><strong>Raymond Demitrio Tel</strong></p>
        <p style="margin:8px 0;">E-Mail: <a href="mailto:gentlyoverdone@outlook.com" style="color:#007acc;">gentlyoverdone@outlook.com</a></p>
        <p style="margin:8px 0;">Website: <a href="https://tel1.jouwweb.nl/contact" target="_blank" rel="noopener noreferrer" style="color:#007acc;">www.tel1.nl</a></p>
        <p style="margin:8px 0;">Weitere Projekte: <a href="https://www.gentlyoverdone.com" target="_blank" rel="noopener noreferrer" style="color:#007acc;">www.gentlyoverdone.com</a></p>
      </div>
      
      <!-- Donation Button -->
      <div style="margin:16px 0;">
        <a href="https://www.gofundme.com/f/magnitudo?utm_campaign=unknown&utm_medium=referral&utm_source=widget" 
           target="_blank" 
           rel="noopener noreferrer"
           style="display:inline-block; padding:12px 24px; background:linear-gradient(135deg, #ff6b6b, #ee5a24); color:white; text-decoration:none; border-radius:25px; font-weight:600; box-shadow:0 4px 15px rgba(255,107,107,0.3); transition:all 0.3s ease;">
          üéµ Magnitudo Musica Mundo unterst√ºtzen
        </a>
        <p style="margin:8px 0; font-size:11px; opacity:0.7;">
          Unterst√ºtzen Sie die musikalische Zukunft und helfen Sie dabei, ‚Ç¨33.000 f√ºr Events, √úbungsr√§ume, Equipment und Instrumente zu sammeln.
        </p>
      </div>
    </section>
      </div> <!-- Ende guitar-tab -->
      
      <!-- Klavier-Tab -->
      <div id="piano-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üéπ</span>
          <span>Klavier & Keyboard</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéπ Virtuelles Klavier</h3>
            <div id="pianoKeyboard" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa; text-align:center;">
              <p>Klavier wird geladen...</p>
            </div>
            <div class="controls">
              <button onclick="initPiano()" class="btn">üéπ Klavier initialisieren</button>
              <button onclick="playPianoChord()" class="btn">üéµ Akkord abspielen</button>
              <button onclick="togglePianoOctaves()" class="btn">üéº Oktaven √§ndern</button>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Klavier-Notation</h3>
            <div id="pianoNotation" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Notation wird hier angezeigt...</p>
            </div>
            <div class="controls">
              <button onclick="showPianoScales()" class="btn">üéµ Tonleitern</button>
              <button onclick="showPianoArpeggios()" class="btn">üéº Arpeggios</button>
            </div>
          </div>
        </div>
        
        <div class="card">
          <h3>üéπ Klavier-√úbungen</h3>
          <div class="controls">
            <button onclick="startPianoExercise('scales')" class="btn">üéµ Tonleiter-√úbung</button>
            <button onclick="startPianoExercise('chords')" class="btn">üéº Akkord-√úbung</button>
            <button onclick="startPianoExercise('sight')" class="btn">üëÅÔ∏è Blattspiel</button>
            <button onclick="startPianoExercise('ear')" class="btn">üëÇ Geh√∂r-√úbung</button>
          </div>
          <div id="pianoExercise" style="margin-top:15px; min-height:100px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>W√§hlen Sie eine √úbung aus...</p>
          </div>
        </div>
      </div>
      
      <!-- Theorie-Tab -->
      <div id="theory-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üìö</span>
          <span>Musiktheorie & Analyse</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Tonleitern & Modi</h3>
            <div class="controls">
              <select id="scaleRoot" style="width:auto;">
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G">G</option>
                <option value="G#">G#</option>
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
              </select>
              <select id="scaleType" style="width:auto;">
                <option value="major">Dur</option>
                <option value="minor">Moll</option>
                <option value="pentatonic">Pentatonisch</option>
                <option value="blues">Blues</option>
                <option value="dorian">Dorian</option>
                <option value="mixolydian">Mixolydian</option>
                <option value="lydian">Lydian</option>
                <option value="phrygian">Phrygian</option>
                <option value="locrian">Locrian</option>
              </select>
              <button onclick="showScale()" class="btn">üéµ Anzeigen</button>
            </div>
            <div id="scaleDisplay" style="margin-top:15px; min-height:100px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie eine Tonleiter aus...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Akkord-Analyse</h3>
            <input type="text" id="chordInput" placeholder="Akkord eingeben (z.B. Cmaj7)" />
            <div class="controls">
              <button onclick="analyzeChord()" class="btn">üîç Analysieren</button>
              <button onclick="showChordVoicings()" class="btn">üéπ Voicings</button>
            </div>
            <div id="chordAnalysis" style="margin-top:15px; min-height:100px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Geben Sie einen Akkord ein...</p>
            </div>
          </div>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Fortschreitungen</h3>
            <div class="controls">
              <button onclick="showCommonProgressions()" class="btn">üéº H√§ufige Folgen</button>
              <button onclick="analyzeProgression()" class="btn">üîç Analyse</button>
              <button onclick="suggestSubstitutions()" class="btn">üí° Ersetzungen</button>
            </div>
            <div id="progressionAnalysis" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie eine Funktion aus...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Funktionstheorie</h3>
            <div class="controls">
              <button onclick="showFunctionalHarmony()" class="btn">üéµ Funktionen</button>
              <button onclick="showCadences()" class="btn">üéº Kadenzen</button>
              <button onclick="showModulations()" class="btn">üéπ Modulationen</button>
            </div>
            <div id="functionalTheory" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie eine Funktion aus...</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Geh√∂r-Tab -->
      <div id="ear-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üëÇ</span>
          <span>Geh√∂rbildung & Training</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Intervall-Training</h3>
            <div class="controls">
              <button onclick="startIntervalTraining()" class="btn">üéº Starten</button>
              <button onclick="stopIntervalTraining()" class="btn">‚èπ Stoppen</button>
              <button onclick="checkIntervalAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
            </div>
            <div id="intervalTraining" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Starten" um mit dem Intervall-Training zu beginnen...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Akkord-Erkennung</h3>
            <div class="controls">
              <button onclick="startChordRecognition()" class="btn">üéµ Starten</button>
              <button onclick="playChordForRecognition()" class="btn">üîä Abspielen</button>
              <button onclick="checkChordAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
            </div>
            <div id="chordRecognition" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Starten" um mit der Akkord-Erkennung zu beginnen...</p>
            </div>
            
            <!-- Instrument Selection -->
            <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
              <h4>üé∏ Instrument-Auswahl</h4>
              <div class="controls">
                <select id="instrumentSelect" onchange="changeInstrument()" style="margin-right: 10px;">
                  <option value="acoustic-guitar">üé∏ Akustische Gitarre</option>
                  <option value="electric-guitar">üé∏ Elektrische Gitarre</option>
                  <option value="nylon-guitar">üé∏ Nylon Gitarre</option>
                  <option value="piano">üéπ Klavier</option>
                  <option value="bass">üé∏ Bass</option>
                  <option value="strings">üéª Streicher</option>
                  <option value="synth">üéπ Synthesizer</option>
                </select>
                <button onclick="testInstrument()" class="btn">üéµ Test</button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Melodie-Erkennung</h3>
            <div class="controls">
              <button onclick="startMelodyRecognition()" class="btn">üéº Starten</button>
              <button onclick="playMelodyForRecognition()" class="btn">üîä Abspielen</button>
              <button onclick="checkMelodyAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
            </div>
            <div id="melodyRecognition" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Starten" um mit der Melodie-Erkennung zu beginnen...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Rhythmus-Erkennung</h3>
            <div class="controls">
              <button onclick="startRhythmRecognition()" class="btn">ü•Å Starten</button>
              <button onclick="playRhythmForRecognition()" class="btn">üîä Abspielen</button>
              <button onclick="checkRhythmAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
            </div>
            <div id="rhythmRecognition" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Starten" um mit der Rhythmus-Erkennung zu beginnen...</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Rhythmus-Tab -->
      <div id="rhythm-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">ü•Å</span>
          <span>Rhythmus & Schlagzeug</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>ü•Å Drum Machine</h3>
            <div id="drumMachine" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Drum Machine wird geladen...</p>
            </div>
            <div class="controls">
              <button onclick="initDrumMachine()" class="btn">ü•Å Initialisieren</button>
              <button onclick="toggleDrumMachine()" class="btn">‚ñ∂Ô∏è Starten/Stoppen</button>
              <button onclick="changeDrumPattern()" class="btn">üéµ Pattern √§ndern</button>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Rhythmus-Notation</h3>
            <div id="rhythmNotation" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Rhythmus-Notation wird hier angezeigt...</p>
            </div>
            <div class="controls">
              <button onclick="showRhythmPatterns()" class="btn">üéµ Patterns</button>
              <button onclick="showRhythmExercises()" class="btn">üéº √úbungen</button>
            </div>
          </div>
        </div>
        
        <div class="card">
          <h3>ü•Å Rhythmus-√úbungen</h3>
          <div class="controls">
            <button onclick="startRhythmExercise('basic')" class="btn">üéµ Grundlagen</button>
            <button onclick="startRhythmExercise('syncopation')" class="btn">üéº Synkopen</button>
            <button onclick="startRhythmExercise('polyrhythm')" class="btn">üéπ Polyrhythmen</button>
            <button onclick="startRhythmExercise('odd')" class="btn">üéº Ungerade Takte</button>
          </div>
          <div id="rhythmExercise" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>W√§hlen Sie eine Rhythmus-√úbung aus...</p>
            </div>
        </div>
      </div>
      
      <!-- Komposition-Tab -->
      <div id="composition-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">‚úçÔ∏è</span>
          <span>Komposition & Arrangement</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Melodie-Generator</h3>
            <div class="controls">
              <select id="melodyKey" style="width:auto;">
                <option value="C">C Dur</option>
                <option value="G">G Dur</option>
                <option value="D">D Dur</option>
                <option value="A">A Dur</option>
                <option value="E">E Dur</option>
                <option value="B">B Dur</option>
                <option value="F#">F# Dur</option>
                <option value="C#">C# Dur</option>
                <option value="F">F Dur</option>
                <option value="Bb">Bb Dur</option>
                <option value="Eb">Eb Dur</option>
                <option value="Ab">Ab Dur</option>
              </select>
              <select id="melodyStyle" style="width:auto;">
                <option value="classical">Klassisch</option>
                <option value="jazz">Jazz</option>
                <option value="pop">Pop</option>
                <option value="folk">Folk</option>
                <option value="blues">Blues</option>
              </select>
              <button onclick="generateMelody()" class="btn">üéº Generieren</button>
            </div>
            <div id="melodyGenerator" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie Tonart und Stil aus...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Bass-Linien</h3>
            <div class="controls">
              <button onclick="generateBassLine()" class="btn">üéµ Generieren</button>
              <button onclick="showBassPatterns()" class="btn">üéº Patterns</button>
              <button onclick="playBassLine()" class="btn">üîä Abspielen</button>
            </div>
            <div id="bassLineGenerator" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Generieren" um eine Bass-Linie zu erstellen...</p>
            </div>
          </div>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Harmonische Progressionen</h3>
            <div class="controls">
              <button onclick="generateHarmonicProgression()" class="btn">üéº Generieren</button>
              <button onclick="analyzeProgression()" class="btn">üîç Analysieren</button>
              <button onclick="exportProgression()" class="btn">üíæ Exportieren</button>
            </div>
            <div id="harmonicProgression" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Generieren" um eine harmonische Progression zu erstellen...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Song-Struktur</h3>
            <div class="controls">
              <button onclick="createSongStructure()" class="btn">üéµ Erstellen</button>
              <button onclick="editSongStructure()" class="btn">‚úèÔ∏è Bearbeiten</button>
              <button onclick="saveSongStructure()" class="btn">üíæ Speichern</button>
            </div>
            <div id="songStructure" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Klicken Sie auf "Erstellen" um eine Song-Struktur zu definieren...</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Produktion-Tab -->
      <div id="production-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üéõÔ∏è</span>
          <span>Audio-Produktion & Mixing</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéõÔ∏è Virtueller Mixer</h3>
            <div id="virtualMixer" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Virtueller Mixer wird geladen...</p>
            </div>
            <div class="controls">
              <button onclick="initVirtualMixer()" class="btn">üéõÔ∏è Initialisieren</button>
              <button onclick="resetMixer()" class="btn">üîÑ Zur√ºcksetzen</button>
              <button onclick="saveMixerPreset()" class="btn">üíæ Speichern</button>
            </div>
          </div>
          
          <div class="card">
            <h3>üéµ TEL & Gentlyoverdone</h3>
            <div id="telMediaEmbed" style="min-height:400px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <style>
                .tel-embed {
                  font-family: 'Segoe UI', sans-serif;
                  background: linear-gradient(to right, #111, #1a1a1a);
                  color: #eee;
                  padding: 2rem;
                  border-radius: 16px;
                  margin: 2rem auto;
                  max-width: 1200px;
                }
                .tel-header {
                  text-align: center;
                  background: #1db954;
                  color: #fff;
                  border-radius: 12px;
                  padding: 2rem 1rem;
                  animation: fadeIn 1.5s ease-in;
                }
                .tel-header img {
                  max-width: 100%;
                  height: auto;
                  border-radius: 8px;
                  margin-bottom: 1rem;
                }
                .tel-section {
                  margin: 2rem 0;
                  animation: slideIn 1s ease-out;
                }
                .tel-section h2 {
                  color: #1db954;
                  text-align: center;
                  margin-bottom: 1rem;
                }
                .tel-section iframe {
                  width: 100%;
                  height: 315px;
                  border: none;
                  border-radius: 12px;
                  display: block;
                  margin: 0 auto;
                }
                .tel-info p {
                  text-align: center;
                  max-width: 800px;
                  margin: 1rem auto;
                  line-height: 1.6;
                }
                .tel-socials {
                  text-align: center;
                  margin-top: 2rem;
                }
                .tel-socials a {
                  margin: 0 12px;
                  text-decoration: none;
                  color: #1db954;
                  font-weight: bold;
                  font-size: 1.2rem;
                  transition: color 0.3s;
                }
                .tel-socials a:hover {
                  color: #1fff75;
                }
                @media (max-width: 768px) {
                  .tel-embed {
                    padding: 1rem;
                  }
                  .tel-section iframe {
                    height: 250px;
                  }
                  .tel-socials a {
                    display: inline-block;
                    margin: 0.5rem;
                    font-size: 1rem;
                  }
                }
                @keyframes fadeIn {
                  from { opacity: 0; }
                  to { opacity: 1; }
                }
                @keyframes slideIn {
                  from { transform: translateY(20px); opacity: 0; }
                  to { transform: translateY(0); opacity: 1; }
                }
              </style>
              <div class="tel-embed">
                <div class="tel-header">
                  <img src="https://tse4.mm.bing.net/th/id/OIP.DSkAHippfPm7Y3kbZ57D4QHaDt?pid=Api" alt="TEL & Gentlyoverdone Banner">
                  <h1>TEL & Gentlyoverdone</h1>
                  <p>Muziek als taal ‚Äî waar ritme, toon & gevoel verbinden.</p>
                </div>

                <div class="tel-section">
                  <h2>üéß Gentlyoverdone op Spotify</h2>
                  <iframe src="https://open.spotify.com/embed/artist/4JoHEGXx9uwPmdT02ZSVwH?utm_source=generator" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
                </div>

                <div class="tel-section">
                  <h2>üéß Gentlyoverdonelivestudio op Spotify</h2>
                  <iframe src="https://open.spotify.com/embed/album/5Sk4bMBNLz8VfTeIliJIgw?utm_source=generator" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
                </div>

                <div class="tel-section">
                  <h2>üéß TEL & Gentlyoverdone Playlist</h2>
                  <iframe src="https://open.spotify.com/embed/playlist/7BXr0cyoKuJSH6NUdPkrQ4" allow="autoplay; encrypted-media"></iframe>
                </div>

                <div class="tel-section">
                  <h2>üì∫ Gentlyoverdone op YouTube</h2>
                  <iframe src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_n9sfv4rSbaRrk-_NA1RMznMMC3gTbk_VM" allowfullscreen></iframe>
                </div>

                <div class="tel-section">
                  <h2>üì∫ Gentlyoverdonelivestudio op YouTube</h2>
                  <iframe src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_kEtsbqqFe8StPkTQp-7CiNJy2tzNMHXzk" allowfullscreen></iframe>
                </div>

                <div class="tel-section">
                  <h2>üì∫ TEL & Gentlyoverdone Video Playlist</h2>
                  <iframe src="https://www.youtube.com/embed/videoseries?list=PLqnjuwwlGspi672giIFTwUcNgM_cXdjGv" allowfullscreen></iframe>
                </div>

                <div class="tel-section tel-info">
                  <h2>‚ÑπÔ∏è Over het Project</h2>
                  <p><strong>Tel1.nl</strong> en <strong>gentlyoverdone.com</strong> vormen de digitale thuisbasis van TEL & Gentlyoverdone ‚Äî een project dat grenzen vervaagt tussen kunst, emotie en geluid.</p>
                  <p><strong>Raymond Demitrio Tel</strong> is het creatieve brein en producer achter dit alles. Zijn missie: muziek maken die niet alleen gehoord, maar gevoeld wordt ‚Äî als een gesprek tussen ziel en klank.</p>
                  <p>Bezoek ons op: <a href="https://www.tel1.nl" target="_blank">tel1.nl</a> & <a href="https://www.gentlyoverdone.com" target="_blank">gentlyoverdone.com</a></p>
                </div>

                <div class="tel-socials">
                  <h2>üîó Volg ons</h2>
                  <a href="https://www.instagram.com/gentlyoverdone" target="_blank">Instagram</a>
                  <a href="https://www.facebook.com/gentlyoverdone" target="_blank">Facebook</a>
                  <a href="https://twitter.com/gentlyoverdone" target="_blank">Twitter</a>
                </div>
              </div>
            </div>
          </div>
          
          <div class="card">
            <h3>üéµ Effekt-Prozessor</h3>
            <div class="controls">
              <button onclick="addReverb()" class="btn">üåä Reverb</button>
              <button onclick="addDelay()" class="btn">‚è∞ Delay</button>
              <button onclick="addCompression()" class="btn">üìä Kompression</button>
              <button onclick="addEQ()" class="btn">üéöÔ∏è EQ</button>
            </div>
            <div id="effectProcessor" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie einen Effekt aus...</p>
            </div>
          </div>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéº Mastering-Tools</h3>
            <div class="controls">
              <button onclick="showLoudnessMeter()" class="btn">üìä Lautst√§rke</button>
              <button onclick="showSpectrumAnalyzer()" class="btn">üìà Spektrum</button>
              <button onclick="showStereoImager()" class="btn">üéß Stereo</button>
              <button onclick="showDynamicRange()" class="btn">üìè Dynamik</button>
            </div>
            <div id="masteringTools" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie ein Mastering-Tool aus...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéµ Export & Rendering</h3>
            <div class="controls">
              <button onclick="exportAudio()" class="btn">üíæ Audio exportieren</button>
              <button onclick="exportMIDI()" class="btn">üéº MIDI exportieren</button>
              <button onclick="exportProject()" class="btn">üìÅ Projekt exportieren</button>
            </div>
            <div id="exportTools" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>W√§hlen Sie einen Export-Typ aus...</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- DAW-Tab -->
      <div id="daw-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üéõÔ∏è</span>
          <span>Digital Audio Workstation (DAW)</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Audio-Import & Bearbeitung</h3>
            <div class="controls">
              <button onclick="openDAW()" class="btn">üéõÔ∏è DAW √∂ffnen</button>
        <button onclick="openGriffbildEditor()" class="btn">üé∏ Griffbild-Editor</button>
        <button onclick="testUI()" class="btn">üß™ UI-Test</button>
              <button onclick="importAudio()" class="btn">üìÅ Audio laden</button>
              <button onclick="recordAudio()" class="btn">üî¥ Aufnehmen</button>
            </div>
            <div id="dawInterface" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa; display:none;">
              <p>DAW wird geladen...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Waveform-Editor</h3>
            <div id="waveformEditor" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Waveform-Editor wird hier angezeigt...</p>
            </div>
            <div class="controls">
              <button onclick="showWaveformTools()" class="btn">üõ†Ô∏è Werkzeuge</button>
              <button onclick="showWaveformContextMenu()" class="btn">üìã Kontext-Men√º</button>
            </div>
          </div>
        </div>
        
        <div class="row">
                <div class="card">
        <h3>üéõÔ∏è Effekt-Kette & Dolby</h3>
        <div class="controls">
          <button onclick="addEQ()" class="btn">üéöÔ∏è 3-Band EQ</button>
          <button onclick="addStereoPan()" class="btn">üéß Stereo Pan</button>
          <button onclick="addGain()" class="btn">üìä Gain</button>
          <button onclick="addDelay()" class="btn">‚è∞ Delay</button>
          <button onclick="addEcho()" class="btn">üîÑ Echo</button>
          <button onclick="addReverb()" class="btn">üåä Reverb</button>
          <button onclick="addDolbyNR()" class="btn">üîá Dolby NR</button>
          <button onclick="addDolbySurround()" class="btn">üåê Dolby Surround</button>
          <button onclick="addDolbyAtmos()" class="btn">üéØ Dolby Atmos</button>
        </div>
        <div id="effectsChain" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
          <p>W√§hlen Sie Effekte aus...</p>
        </div>
      </div>
      
      <div class="card">
        <h3>‚èØÔ∏è Transport & Steuerung</h3>
        <div id="transportControls" style="min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
          <div class="controls">
            <button onclick="startTransport()" class="btn">‚ñ∂Ô∏è Play</button>
            <button onclick="stopTransport()" class="btn">‚èπÔ∏è Stop</button>
            <button onclick="pauseTransport()" class="btn">‚è∏Ô∏è Pause</button>
            <button onclick="toggleRecord()" class="btn">üî¥ Record</button>
          </div>
          
          <div style="margin-top:15px;">
            <label>Tempo: <input type="range" id="tempoSlider" min="60" max="200" value="120" onchange="setTransportTempo(this.value)"></label>
            <span id="tempoDisplay">120 BPM</span>
          </div>
          
          <div style="margin-top:15px;">
            <label>Taktart: <select id="timeSignatureSelect" onchange="setTransportTimeSignature(parseInt(this.value), 4)">
              <option value="2">2/4</option>
              <option value="3">3/4</option>
              <option value="4" selected>4/4</option>
              <option value="6">6/8</option>
              <option value="8">8/8</option>
            </select></label>
          </div>
          
          <div id="transportStatus" style="margin-top:15px;">
            <div style="padding:10px; background:#f8f9fa; border-radius:8px;">
              <strong>‚èØÔ∏è Transport:</strong> Bereit
            </div>
          </div>
        </div>
      </div>
          
          <div class="card">
            <h3>üíæ Export & Mixdown</h3>
            <div class="controls">
              <button onclick="exportWAV()" class="btn">üíæ WAV Mixdown</button>
              <button onclick="exportMP3()" class="btn">üéµ MP3 Export</button>
              <button onclick="exportMIDI()" class="btn">üéº MIDI Export</button>
              <button onclick="saveProject()" class="btn">üìÅ Projekt speichern</button>
            </div>
            <div id="exportStatus" style="margin-top:15px; min-height:100px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Export-Status wird hier angezeigt...</p>
            </div>
          </div>
        </div>
        
        <div class="card">
          <h3>üéØ Live-Performance & Optimierung</h3>
          <div class="controls">
            <button onclick="detectHardware()" class="btn">üîç Hardware erkennen</button>
            <button onclick="optimizePerformance()" class="btn">‚ö° Performance optimieren</button>
            <button onclick="showPerformanceStats()" class="btn">üìä Statistiken</button>
            <button onclick="testLatency()" class="btn">‚è±Ô∏è Latenz testen</button>
          </div>
          <div id="performanceInfo" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>Performance-Informationen werden hier angezeigt...</p>
          </div>
        </div>
        
        <div class="card">
          <h3>üéº Waveframe Audio-Editor</h3>
          <div class="controls">
            <button onclick="openWaveframe()" class="btn">üéº Waveframe √∂ffnen</button>
            <button onclick="showWaveframeTools()" class="btn">üõ†Ô∏è Werkzeuge</button>
            <button onclick="showWaveframeContextMenu()" class="btn">üìã Kontext-Men√º</button>
            <button onclick="setupWaveframeShortcuts()" class="btn">‚å®Ô∏è Tastenk√ºrzel</button>
          </div>
          <div id="waveframeEditor" style="margin-top:15px; min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>Waveframe Audio-Editor wird hier angezeigt...</p>
          </div>
        </div>
        
        <div class="card">
          <h3>üéõÔ∏è Multi-Track Recording</h3>
          <div class="controls">
            <button onclick="openMultiTrack()" class="btn">üéõÔ∏è Multi-Track √∂ffnen</button>
            <button onclick="addTrack()" class="btn">‚ûï Track hinzuf√ºgen</button>
            <button onclick="recordTrack()" class="btn">üî¥ Aufnehmen</button>
            <button onclick="playAllTracks()" class="btn">‚ñ∂Ô∏è Alle abspielen</button>
            <button onclick="mixdownTracks()" class="btn">üéöÔ∏è Mixdown</button>
          </div>
          <div id="multiTrackEditor" style="margin-top:15px; min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>Multi-Track Recording wird hier angezeigt...</p>
          </div>
        </div>
        
        <div class="card">
          <h3>üéµ Song-Projekt-Manager</h3>
          <div class="controls">
            <button onclick="createNewProject()" class="btn">üÜï Neues Projekt</button>
            <button onclick="openProject()" class="btn">üìÇ Projekt √∂ffnen</button>
            <button onclick="saveProject()" class="btn">üíæ Projekt speichern</button>
            <button onclick="exportProject()" class="btn">üì§ Projekt exportieren</button>
            <button onclick="showProjectInfo()" class="btn">‚ÑπÔ∏è Projekt-Info</button>
          </div>
          <div id="projectManager" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>Song-Projekt-Manager wird hier angezeigt...</p>
          </div>
        </div>
      </div>
      
      <!-- Live Performance Tab -->
      <div id="live-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üé§</span>
          <span>Live Performance & Stage Tools</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>üéµ Live Setlist Manager</h3>
            <div class="controls">
              <button onclick="createSetlist()" class="btn">üìù Neue Setlist</button>
              <button onclick="loadSetlist()" class="btn">üìÅ Setlist laden</button>
              <button onclick="saveSetlist()" class="btn">üíæ Speichern</button>
            </div>
            <div id="setlistManager" style="margin-top:15px; min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Setlist-Manager wird hier angezeigt...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéöÔ∏è Stage Monitor & Mix</h3>
            <div class="controls">
              <button onclick="setupStageMonitors()" class="btn">üéß Monitore einrichten</button>
              <button onclick="adjustStageMix()" class="btn">üéõÔ∏è Mix anpassen</button>
              <button onclick="testStageAudio()" class="btn">üîä Audio testen</button>
            </div>
            <div id="stageMonitor" style="margin-top:15px; min-height:200px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Stage Monitor wird hier angezeigt...</p>
            </div>
          </div>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>‚è±Ô∏è Tempo & Timing</h3>
            <div class="controls">
              <button onclick="setLiveTempo()" class="btn">üéØ Tempo setzen</button>
              <button onclick="syncBandTempo()" class="btn">üîÑ Band synchronisieren</button>
              <button onclick="showTempoHistory()" class="btn">üìä Tempo-Verlauf</button>
            </div>
            <div id="tempoControl" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Tempo-Steuerung wird hier angezeigt...</p>
            </div>
          </div>
          
          <div class="card">
            <h3>üéº Chord Charts & Lyrics</h3>
            <div class="controls">
              <button onclick="showChordCharts()" class="btn">üé∏ Akkord-Charts</button>
              <button onclick="showLyrics()" class="btn">üìù Songtexte</button>
              <button onclick="editCharts()" class="btn">‚úèÔ∏è Charts bearbeiten</button>
            </div>
            <div id="chordCharts" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
              <p>Chord Charts werden hier angezeigt...</p>
            </div>
          </div>
        </div>
        
        <div class="card">
          <h3>üéØ Performance Tools</h3>
          <div class="controls">
            <button onclick="startPerformanceMode()" class="btn">üé≠ Performance-Modus</button>
            <button onclick="showPerformanceStats()" class="btn">üìä Performance-Statistiken</button>
            <button onclick="setupLighting()" class="btn">üí° Beleuchtung</button>
            <button onclick="setupVideo()" class="btn">üìπ Video</button>
          </div>
          <div id="performanceTools" style="margin-top:15px; min-height:150px; border:1px solid #e5e7eb; border-radius:8px; padding:15px; background:#f8f9fa;">
            <p>Performance-Tools werden hier angezeigt...</p>
          </div>
        </div>
      </div>
      
      <!-- Media-Tab -->
      <div id="media-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üì∫</span>
          <span>Media & Inspiration</span>
          <div class="controls" style="margin-top: 10px;">
            <button onclick="toggleTelMedia()" class="btn" style="background: #1db954; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin-right: 10px;">üéµ TEL & Gentlyoverdone anzeigen</button>
            <button onclick="toggleMediaPlayer()" class="btn" style="background: #1db954; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">üé¨ Media Player anzeigen</button>
          </div>
        </div>
        
        <div class="media-grid">
          <div class="card">
            <h3>üéß Gentlyoverdone auf Spotify</h3>
            <iframe style="border-radius:12px" src="https://open.spotify.com/embed/artist/4JoHEGXx9uwPmdT02ZSVwH?utm_source=generator" width="100%" height="380" frameborder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
          </div>
          
          <div class="card">
            <h3>üéß Gentlyoverdonelivestudio Album</h3>
            <iframe style="border-radius:12px" src="https://open.spotify.com/embed/album/5Sk4bMBNLz8VfTeIliJIgw?utm_source=generator" width="100%" height="380" frameborder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
          </div>
          
          <div class="card">
            <h3>üì∫ Gentlyoverdone YouTube Playlist</h3>
            <iframe width="100%" height="315" src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_n9sfv4rSbaRrk-_NA1RMznMMC3gTbk_VM" title="Gentlyoverdone - YouTube Playlist" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </div>
          
          <div class="card">
            <h3>üì∫ TEL & Gentlyoverdone Live Studio</h3>
            <iframe width="100%" height="315" src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_kEtsbqqFe8StPkTQp-7CiNJy2tzNMHXzk" title="Gentlyoverdonelivestudio - YouTube Playlist" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          </div>
        </div>
        
        <!-- TEL & Gentlyoverdone Vollst√§ndiger Media-Bereich -->
        <div id="telMediaEmbed" class="tel-embed">
          <div class="tel-header">
            <img src="https://tse4.mm.bing.net/th/id/OIP.DSkAHippfPm7Y3kbZ57D4QHaDt?pid=Api" alt="TEL & Gentlyoverdone Banner">
            <h1>TEL & Gentlyoverdone</h1>
            <p>Muziek als taal ‚Äî waar ritme, toon & gevoel verbinden.</p>
          </div>

          <div class="tel-section">
            <h2>üéß Gentlyoverdone op Spotify</h2>
            <iframe src="https://open.spotify.com/embed/artist/4JoHEGXx9uwPmdT02ZSVwH?utm_source=generator" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
          </div>

          <div class="tel-section">
            <h2>üéß Gentlyoverdonelivestudio op Spotify</h2>
            <iframe src="https://open.spotify.com/embed/album/5Sk4bMBNLz8VfTeIliJIgw?utm_source=generator" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
          </div>

          <div class="tel-section">
            <h2>üéß TEL & Gentlyoverdone Playlist</h2>
            <iframe src="https://open.spotify.com/embed/playlist/7BXr0cyoKuJSH6NUdPkrQ4" allow="autoplay; encrypted-media"></iframe>
          </div>

          <div class="tel-section">
            <h2>üì∫ Gentlyoverdone op YouTube</h2>
            <iframe src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_n9sfv4rSbaRrk-_NA1RMznMMC3gTbk_VM" allowfullscreen></iframe>
          </div>

          <div class="tel-section">
            <h2>üì∫ Gentlyoverdonelivestudio op YouTube</h2>
            <iframe src="https://www.youtube.com/embed/videoseries?list=OLAK5uy_kEtsbqqFe8StPkTQp-7CiNJy2tzNMHXzk" allowfullscreen></iframe>
          </div>

          <div class="tel-section">
            <h2>üì∫ TEL & Gentlyoverdone Video Playlist</h2>
            <iframe src="https://www.youtube.com/embed/videoseries?list=PLqnjuwwlGspi672giIFTwUcNgM_cXdjGv" allowfullscreen></iframe>
          </div>

          <div class="tel-section tel-info">
            <h2>‚ÑπÔ∏è Over het Project</h2>
            <p><strong>Tel1.nl</strong> en <strong>gentlyoverdone.com</strong> vormen de digitale thuisbasis van TEL & Gentlyoverdone ‚Äî een project dat grenzen vervaagt tussen kunst, emotie en geluid.</p>
            <p><strong>Raymond Demitrio Tel</strong> is het creatieve brein en producer achter dit alles. Zijn missie: muziek maken die niet alleen gehoord, maar gevoeld wordt ‚Äî als een gesprek tussen ziel en klank.</p>
            <p>Bezoek ons op: <a href="https://www.tel1.nl" target="_blank">tel1.nl</a> & <a href="https://www.gentlyoverdone.com" target="_blank">gentlyoverdone.com</a></p>
          </div>

          <div class="tel-socials">
            <h2>üîó Volg ons</h2>
            <a href="https://www.instagram.com/gentlyoverdone" target="_blank">Instagram</a>
            <a href="https://www.facebook.com/gentlyoverdone" target="_blank">Facebook</a>
            <a href="https://twitter.com/gentlyoverdone" target="_blank">Twitter</a>
          </div>
        </div>
      </div>
      
      <!-- Projekte-Tab -->
      <div id="projects-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üíæ</span>
          <span>Projekt-Management</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>Neues Projekt erstellen</h3>
            <input type="text" id="projectName" placeholder="Projektname" />
            <textarea id="projectDescription" placeholder="Beschreibung"></textarea>
            <div class="controls">
              <button onclick="createProject()" class="btn">‚ûï Projekt erstellen</button>
              <button onclick="saveCurrentProject()" class="btn">üíæ Aktuelles speichern</button>
            </div>
          </div>
          
          <div class="card">
            <h3>Projekte laden</h3>
            <div id="projectList" class="project-list"></div>
          </div>
        </div>
      </div>
      
      <!-- Noten-Tab -->
      <div id="notes-tab" class="tab-content">
        <div class="hero-out">
          <span class="badge">üéº</span>
          <span>Noten-Editor & Live-Anzeige</span>
        </div>
        
        <div class="row">
          <div class="card">
            <h3>Noten eingeben</h3>
            <textarea id="notesInput" placeholder="Noten im ABC-Format oder als Akkorde"></textarea>
            <div class="controls">
              <button onclick="parseNotes()" class="btn">üéº Noten parsen</button>
              <button onclick="playNotes()" class="btn">‚ñ∂Ô∏é Noten abspielen</button>
            </div>
          </div>
          
          <div class="card">
            <h3>Live-Noten-Anzeige</h3>
            <div id="liveNotesDisplay" class="live-notes"></div>
          </div>
        </div>
        
        <div class="card">
          <h3>Multimedia-Player</h3>
          <div class="media-player">
            <input type="file" id="mediaFile" accept="audio/*,video/*" />
            <div class="controls">
              <button onclick="loadMedia()" class="btn">üìÅ Media laden</button>
              <button onclick="syncWithChords()" class="btn">üéØ Mit Akkorden synchronisieren</button>
              <button onclick="startMediaRecording()" class="btn">üéôÔ∏è Aufnahme starten</button>
              <button onclick="stopMediaRecording()" class="btn">‚èπÔ∏è Aufnahme stoppen</button>
              <button onclick="exportMedia()" class="btn">üíæ Media exportieren</button>
            </div>
            <div id="mediaPlayer" class="media-player-container"></div>
            <div id="mediaControls" class="media-controls">
              <button onclick="playMedia()" class="btn">‚ñ∂Ô∏è Abspielen</button>
              <button onclick="pauseMedia()" class="btn">‚è∏Ô∏è Pause</button>
              <button onclick="stopMedia()" class="btn">‚èπÔ∏è Stopp</button>
              <input type="range" id="mediaVolume" min="0" max="1" step="0.1" value="0.5" onchange="setMediaVolume(this.value)" />
              <span id="mediaTime">00:00 / 00:00</span>
            </div>
          </div>
        </div>
      </div>
  </div>

  <script>
  // ---------- Musik- und Akkord-Helfer ----------
  const NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const NOTE_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
  const ALL_KEYS = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B"];
  const TUNINGS = {
    "E Standard (E A D G B E)": [28,33,38,43,47,52], // E2, A2, D3, G3, B3, E4
    "Drop D (D A D G B E)":     [26,33,38,43,47,52], // D2, A2, D3, G3, B3, E4
    "DADGAD (D A D G A D)":     [26,33,38,43,45,50], // D2, A2, D3, G3, A3, D4
    "Open G (D G D G B D)":     [26,31,38,43,47,50], // D2, G2, D3, G3, B3, D4
  };
  const QUALITY = {
    "":"maj","M":"maj","maj":"maj","m":"min","min":"min","-":"min",
    "7":"7","m7":"m7","min7":"m7","maj7":"maj7","M7":"maj7","Œî7":"maj7",
    "dim":"dim","o":"dim","+":"aug","aug":"aug",
    "sus2":"sus2","sus4":"sus4","add9":"add9",
    "sus":"sus4",
    "9":"9","m9":"m9","maj9":"maj9",
    "11":"11","m11":"m11","maj11":"maj11",
    "13":"13","m13":"m13","maj13":"maj13",
    "6":"6","m6":"m6","maj6":"maj6",
    "dim7":"dim7","√∏":"m7b5","m7b5":"m7b5",
    "aug7":"aug7","+7":"aug7"
  };
  
  function noteIndex(n){ let i=NOTE_SHARP.indexOf(n); if(i>=0) return i; i=NOTE_FLAT.indexOf(n); if(i>=0) return i; throw new Error("Note "+n); }
  function idxToNote(i, flats=false){ i=((i%12)+12)%12; return flats?NOTE_FLAT[i]:NOTE_SHARP[i]; }
  function parseChord(sym){ const m = sym.trim().match(/^([A-G](?:#|b)?)(.*?)(?:\/(.*))?$/); if(!m) return null; const q=QUALITY[m[2]]||"maj"; return {root:m[1], quality:q, bass:m[3]}; }
  
  // Enharmonische Darstellung basierend auf der Zieltonart
  function useFlatsForKey(key) {
    return ["F","Bb","Eb","Ab","Db","Gb"].includes(key);
  }
  
  function trNote(n, semi){ 
    // Sichere Pr√ºfung ob target bereits initialisiert ist
    let targetKey = "C";
    if (typeof target !== 'undefined' && target && target.value) {
      targetKey = target.value;
    }
    const flats = useFlatsForKey(targetKey);
    
    try {
      // Extrahiere nur die Note aus Akkord-Namen (z.B. "Dm" -> "D")
      const note = n.replace(/[^A-G#b]/g, '');
      return idxToNote(noteIndex(note)+semi, flats);
    } catch (error) {
      console.warn('Fehler beim Transponieren der Note:', n, error);
      return n; // Fallback: urspr√ºngliche Note zur√ºckgeben
    }
  }
  
  function trChord(sym, semi){ const p=parseChord(sym); if(!p) return sym; const root=trNote(p.root, semi); const suf=(p.quality==="maj"?"": p.quality==="min"?"m": p.quality); const base=root+suf; return p.bass? base+"/"+trNote(p.bass, semi): base; }
  function semiKeyToKey(from, to){ 
    // Extrahiere nur die Note aus Akkord-Namen (z.B. "Dm" -> "D")
    const fromNote = from.replace(/[^A-G#b]/g, '');
    const toNote = to.replace(/[^A-G#b]/g, '');
    
    try {
      return noteIndex(toNote) - noteIndex(fromNote);
    } catch (error) {
      console.warn('Fehler beim Berechnen der Transposition:', error);
      return 0; // Fallback: keine Transposition
    }
  }

  // Open + Barre Voicings (vereinfacht ‚Äì identisch wie in React‚ÄëVersion)
  const OPEN = {
    "C":{f:[-1,3,2,0,1,0],g:[0,3,2,0,1,0]},
    "Cm":{f:[-1,3,5,5,4,3],g:[0,1,3,4,2,1]},
    "C7":{f:[-1,3,2,3,1,0],g:[0,3,2,4,1,0]},
    "Cmaj7":{f:[-1,3,2,0,0,0],g:[0,3,2,0,0,0]},
    "Cm7":{f:[-1,3,5,3,4,3],g:[0,1,3,2,4,1]},
    "D":{f:[-1,-1,0,2,3,2],g:[0,0,0,1,3,2]},
    "Dm":{f:[-1,-1,0,2,3,1],g:[0,0,0,2,3,1]},
    "D7":{f:[-1,-1,0,2,1,2],g:[0,0,0,2,1,3]},
    "Dmaj7":{f:[-1,-1,0,2,2,2],g:[0,0,0,1,2,3]},
    "Dm7":{f:[-1,-1,0,2,1,1],g:[0,0,0,2,1,1]},
    "E":{f:[0,2,2,1,0,0],g:[0,2,3,1,0,0]},
    "Em":{f:[0,2,2,0,0,0],g:[0,2,3,0,0,0]},
    "E7":{f:[0,2,0,1,0,0],g:[0,2,0,1,0,0]},
    "Em7":{f:[0,2,2,0,3,0],g:[0,2,3,0,4,0]},
    "Emaj7":{f:[0,2,1,1,0,0],g:[0,2,1,1,0,0]},
    "F":{f:[1,3,3,2,1,1],g:[1,3,4,2,1,1]},
    "Fm":{f:[1,3,3,1,1,1],g:[1,3,4,1,1,1]},
    "F7":{f:[1,3,1,2,1,1],g:[1,3,1,2,1,1]},
    "Fmaj7":{f:[1,3,2,2,1,1],g:[1,3,2,2,1,1]},
    "G":{f:[3,2,0,0,0,3],g:[2,1,0,0,0,3]},
    "Gm":{f:[3,5,5,3,3,3],g:[1,3,4,2,1,1]},
    "G7":{f:[3,2,0,0,0,1],g:[2,1,0,0,0,3]},
    "Gmaj7":{f:[3,2,0,0,0,2],g:[2,1,0,0,0,3]},
    "A":{f:[-1,0,2,2,2,0],g:[0,0,1,2,3,0]},
    "Am":{f:[-1,0,2,2,1,0],g:[0,0,1,2,3,0]},
    "A7":{f:[-1,0,2,0,2,0],g:[0,0,1,0,2,0]},
    "Amaj7":{f:[-1,0,2,1,2,0],g:[0,0,1,1,2,0]},
    "Am7":{f:[-1,0,2,0,1,0],g:[0,0,1,0,2,0]},
    "B":{f:[2,2,4,4,4,2],g:[1,1,2,3,4,1]},
    "Bm":{f:[-1,2,4,4,3,2],g:[0,1,3,4,2,1]},
    "B7":{f:[2,2,1,2,0,2],g:[1,2,1,3,0,4]},
    "Bmaj7":{f:[2,2,4,3,4,2],g:[1,1,2,1,3,1]},
    "Bm7":{f:[2,2,1,2,0,2],g:[1,2,1,3,0,4]},
    "C#":{f:[4,6,6,5,4,4],g:[1,3,4,2,1,1]},
    "C#m":{f:[4,6,6,4,4,4],g:[1,3,4,2,1,1]},
    "D#":{f:[6,8,8,7,6,6],g:[1,3,4,2,1,1]},
    "D#m":{f:[6,8,8,6,6,6],g:[1,3,4,2,1,1]},
    "F#":{f:[2,4,4,3,2,2],g:[1,3,4,2,1,1]},
    "F#m":{f:[2,4,4,2,2,2],g:[1,3,4,2,1,1]},
    "G#":{f:[4,6,6,5,4,4],g:[1,3,4,2,1,1]},
    "G#m":{f:[4,6,6,4,4,4],g:[1,3,4,2,1,1]},
    "A#":{f:[6,8,8,7,6,6],g:[1,3,4,2,1,1]},
    "A#m":{f:[6,8,8,6,6,6],g:[1,3,4,2,1,1]}
  };
  
  const E_SH = {maj:[0,2,2,1,0,0],min:[0,2,2,0,0,0],"7":[0,2,0,1,0,0],m7:[0,2,0,0,0,0],maj7:[0,2,2,1,0,-1],dim:[0,1,2,1,2,1],aug:[0,3,2,1,0,0],sus2:[0,2,2,0,0,0],sus4:[0,2,2,2,0,0],add9:[0,2,2,1,0,2]};
  const A_SH = {maj:[-1,0,2,2,2,0],min:[-1,0,2,2,1,0],"7":[-1,0,2,0,2,0],m7:[-1,0,2,0,1,0],maj7:[-1,0,2,1,2,0],dim:[-1,0,1,2,1,0],aug:[-1,0,3,2,2,0],sus2:[-1,0,2,4,0,0],sus4:[-1,0,2,2,3,0],add9:[-1,0,2,2,2,4]};
  
  function fretForRootOnString(root, openMidi){ const pc=noteIndex(root), open= openMidi%12; let d=pc-open; while(d<0) d+=12; return d; }
  
  function barre(root, q, preferA=false){ 
    const base=(preferA?A_SH[q]:E_SH[q]); 
    if(!base || !base[0]) return {f:[-1,-1,-1,-1,-1,-1],g:[0,0,0,0,0,0]}; 
    
    // Verwende die aktuell selektierte Stimmung statt der festen E-Standard
    // Sichere Pr√ºfung ob tuningSel bereits initialisiert ist
    let tuningKey = "E Standard (E A D G B E)";
    if (typeof tuningSel !== 'undefined' && tuningSel && tuningSel.value) {
      tuningKey = tuningSel.value;
    }
    const open = TUNINGS[tuningKey]; 
    if (!open || !open[0]) return {f:[-1,-1,-1,-1,-1,-1],g:[0,0,0,0,0,0]};
    
    const str = preferA?1:0; 
    const fret=fretForRootOnString(root, open[str]); 
    const frets=base.map(v=> v<0? -1: v+fret); 
    const fingers=base.map(v=> v===0?1:(v<0?0:(v===2?3:(v===3?4:2)))); 
    return {f:frets,g:fingers}; 
  }
  
  function chooseVoicing(root, q){ 
    const k = root + (q==="maj"?"": q==="min"?"m": q); 
    
    // Wenn "Easy" aktiviert ist, bevorzuge offene Griffe
    if (easy && easy.checked && OPEN[k]) {
      return OPEN[k];
    }
    
    if(OPEN[k]) return OPEN[k]; 
    
    // Erweiterte Griffbilder f√ºr komplexere Akkorde
    if (q === "7" || q === "m7" || q === "maj7" || q === "dim7" || q === "aug7") {
      const e = barre(root, q, false);
      const a = barre(root, q, true);
      const avgE = e.f.filter(x=>x>=0).reduce((a,b)=>a+b,0)/Math.max(1,e.f.filter(x=>x>=0).length);
      const avgA = a.f.filter(x=>x>=0).reduce((a,b)=>a+b,0)/Math.max(1,a.f.filter(x=>x>=0).length);
      
      // Bei "Easy" bevorzuge niedrigere Bundpositionen
      if (easy && easy.checked) {
        return avgE <= avgA ? e : a;
      }
      
      return avgE <= avgA ? e : a;
    }
    
    // Standard-Barre-Akkorde
    const e = barre(root, q, false);
    const avg = e.f.filter(n=>n>=0).reduce((a,b)=>a+b,0)/Math.max(1,e.f.filter(n=>n>=0).length);
    
    // Bei "Easy" bevorzuge niedrigere Bundpositionen
    if (easy && easy.checked && avg > 8) {
      return barre(root, q, true);
    }
    
    if(avg <= 8) return e;
    return barre(root, q, true);
  }
  
  function smooth(seq){ 
    const out = []; 
    let last = 3; 
    
    // Hilfsfunktion f√ºr durchschnittliche Bundposition
    function avg(vo) { 
      const a = vo.f.filter(x => x > 0); 
      return a.length ? a.reduce((p,c) => p + c, 0) / a.length : 1; 
    }
    
    seq.forEach(c => { 
      const key = c.root + (c.quality === "maj" ? "" : c.quality === "min" ? "m" : c.quality);
      const cand = [];

      // 1) Open-Voicing bevorzugen (und bei Easy erzwingen)
      if (OPEN[key]) cand.push(OPEN[key]);

      // 2) Barre-Alternativen
      const e = barre(c.root, c.quality, false);
      const a = barre(c.root, c.quality, true);
      cand.push(e, a);

      // Easy-Option: wenn Open existiert, direkt nehmen
      if (easy && easy.checked && OPEN[key]) {
        out.push(OPEN[key]); 
        last = avg(OPEN[key]); 
        return;
      }

      // Sonst: bestes Voicing nahe der letzten Lage, bei Gleichstand Open bevorzugen
      let best = cand[0], bestAvg = avg(best);
      for (const v of cand) {
        const av = avg(v);
        const better = Math.abs(av - last) < Math.abs(bestAvg - last) - 1e-6
          || (Math.abs(av - last) === Math.abs(bestAvg - last) && v === OPEN[key]);
        if (better) { 
          best = v; 
          bestAvg = av; 
        }
      }
      out.push(best); 
      last = bestAvg;
    }); 
    
    return out; 
  }
  
  function fretsToNotes(frets, tuning, capo){ return frets.map((f,i)=>{ if(f<0) return ""; const midi=tuning[i]+f+capo; const pc=midi%12; const oct=Math.floor(midi/12)-1; return idxToNote(pc)+"/"+oct; }).filter(Boolean); }
  
  function asciiTab(chords, voicings){ 
    const names=["e","B","G","D","A","E"]; 
    const lines=names.map(s=>s+"| "); 
    const out=[]; 
    chords.forEach((c,i)=>{ 
      const f=[...voicings[i].f].reverse(); // Korrigierter Spread-Operator
      const cell=f.map(n=> n<0?"x":String(n)).map(x=>x.padStart(2,"-")).map(x=>x+"-").join(""); 
      for(let r=0;r<lines.length;r++){ 
        lines[r]+=cell; 
      } 
      if((i%4)===3||i===chords.length-1){ 
        out.push(...lines.map(l=>l+"|")); 
        out.push(""); 
        for(let r=0;r<lines.length;r++) lines[r]=names[r]+"| "; 
      } 
    }); 
    return out.join("\n"); 
  }

  // ---------- UI Setup ----------
  const $ = (id)=>document.getElementById(id);
  const inp=$("inp"), orig=$("orig"), target=$("target"), semi=$("semi"), semiLbl=$("semiLbl"), capo=$("capo"), capoLbl=$("capoLbl"), tuningSel=$("tuning"), out=$("out"), playBtn=$("play"), stopBtn=$("stop"), metronomeBtn=$("metronome"), exportBtn=$("export"), pdfExportBtn=$("pdfExport"), saveProg=$("saveProg"), loadProg=$("loadProg"), status=$("status"), diagrams=$("diagrams"), ascii=$("ascii"), tempo=$("tempo"), tempoLbl=$("tempoLbl"), pattern=$("pattern"), lefty=$("lefty"), easy=$("easy"), vfNotes=$("vf-notes"), vfTab=$("vf-tab");
  
  // --- Audio Globals ---
  let synth = null;
  let chordPart = null;
  let metroLoop = null;
  let metroPlayer = null;
  let isPlaying = false;
  
  // Tone.js Konfiguration ‚Äì kein Monkey-Patching von Transport
  if (typeof Tone !== 'undefined') {
    Tone.context.latencyHint = 'interactive';
    Tone.Transport.autoStart = false;
  }
  
  // User-Interaction-Handler f√ºr Audio
  let audioInitialized = false;
  
  async function initializeAudioOnUserInteraction() {
    if (!audioInitialized) {
      console.log('Audio wird nach User-Interaktion initialisiert');
      try {
        // Tone.js + tonejs-instruments dynamisch laden
        if (!window.Tone && !window.__toneLoading) {
          window.__toneLoading = true;
          console.log('Lade Tone.js + tonejs-instruments...');
          
          // Tone.js laden
          const ToneMod = await import('https://unpkg.com/tone@14.8.49/build/Tone.js');
          window.Tone = window.Tone || ToneMod?.Tone || ToneMod?.default || ToneMod;
          console.log('‚úÖ Tone.js erfolgreich geladen');
          
          // tonejs-instruments laden
                         try {
                 // Lokale Fallback-Implementierung f√ºr tonejs-instruments
                 window.TonejsInstruments = {
                   Piano: class Piano {
                     constructor() {
                       this.synth = new Tone.PolySynth(Tone.Synth, {
                         oscillator: { type: 'triangle' },
                         envelope: { decay: 0.1, sustain: 0.3, release: 1 }
                       }).toDestination();
                     }
                     triggerAttackRelease(notes, duration) {
                       this.synth.triggerAttackRelease(notes, duration);
                     }
                   },
                   Violin: class Violin {
                     constructor() {
                       this.synth = new Tone.PolySynth(Tone.Synth, {
                         oscillator: { type: 'sine' },
                         envelope: { attack: 0.1, decay: 0.2, sustain: 0.4, release: 0.8 }
                       }).toDestination();
                     }
                     triggerAttackRelease(notes, duration) {
                       this.synth.triggerAttackRelease(notes, duration);
                     }
                   },
                   Guitar: class Guitar {
                     constructor() {
                       this.synth = new Tone.PolySynth(Tone.Synth, {
                         oscillator: { type: 'square' },
                         envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }
                       }).toDestination();
                     }
                     triggerAttackRelease(notes, duration) {
                       this.synth.triggerAttackRelease(notes, duration);
                     }
                   }
                 };
                 console.log('‚úÖ Lokale tonejs-instruments erfolgreich geladen');
               } catch (e) {
                 console.warn('tonejs-instruments konnte nicht geladen werden:', e);
               }
        }
        
        // Sicherer Start √ºber sichere Helper-Funktion
        await startToneContext();
        audioInitialized = true;
        console.log('AudioContext erfolgreich gestartet');
        
        // Verstecke den Audio-Button nach erfolgreicher Initialisierung
        const enableAudioBtn = document.getElementById('enableAudio');
        if (enableAudioBtn) {
          enableAudioBtn.style.display = 'none';
        }
        
        // Erweiterte Instrumente mit tonejs-instruments erstellen
        if (window.TonejsInstruments) {
          createAdvancedInstruments();
        } else {
          // Fallback: Basis-Synth mit besserer Klangqualit√§t
          if (!synth) {
            synth = new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: 'triangle' },
              envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.8 }
            }).toDestination();
          }
        }
        
        // Sichere nach dem Erzeugen der Instrumente, dass das globale Ziel nicht gemutet ist
        Tone.Destination.mute = false;
        Tone.Destination.volume.rampTo(0, 0.01); // 0 dB mit sanftem Ramp
        
        // Update Status
        status.textContent = 'Audio aktiviert - bereit zum Abspielen';
        
        // Kurztest: sollte einmal kurz piepen
        try { 
          synth.triggerAttackRelease(['C4','E4','G4'], '8n', Tone.now() + 0.05); 
        } catch (e) {
          console.warn('Synth-Test fehlgeschlagen:', e);
        }
      } catch (e) {
        console.warn('Konnte AudioContext nicht starten:', e);
        status.textContent = 'Audio konnte nicht aktiviert werden';
        const enableAudioBtn = document.getElementById('enableAudio');
        if (enableAudioBtn) enableAudioBtn.style.display = 'inline-block';
      }
      
      // Event-Listener werden automatisch durch {once: true} entfernt
    }
  }
  
  // Sichere Helper-Funktion f√ºr Tone-Context-Start
  async function startToneContext() {
    // Guard: Tone.js muss geladen sein
    if (typeof Tone === 'undefined') {
      throw new Error('Tone ist noch nicht geladen');
    }
    
    // bevorzugt: Tone.start() (liefert Promise, erf√ºllt Autoplay-Policy)
    if (typeof Tone.start === 'function') {
      await Tone.start();
      return;
    }
    // fallback: getContext().resume()
    const ctx = (typeof Tone.getContext === 'function') ? Tone.getContext() : null;
    if (ctx && typeof ctx.resume === 'function') {
      await ctx.resume();
      return;
    }
    throw new Error('Kein start()/resume() auf Tone verf√ºgbar');
  }

  // Explizite Audio-Aktivierung √ºber Button
  async function enableAudioExplicitly() {
    if (!audioInitialized) {
      await initializeAudioOnUserInteraction();
    }
  }
  
  async function ensureAudio() {
    try {
      // Pr√ºfe ob Tone.js geladen ist
      if (!window.Tone) {
        console.log('Tone.js noch nicht geladen - lade jetzt...');
        await initializeAudioOnUserInteraction();
        return false;
      }
      
      // Falls noch nicht initialisiert: direkt hier versuchen zu starten
      if (!audioInitialized) {
        try {
          console.log('Initialisiere Audio-System...');
          await initializeAudioOnUserInteraction();
          return true;
        } catch (e) {
          console.warn('Konnte AudioContext nicht starten:', e);
          status.textContent = 'Audio konnte nicht aktiviert werden - bitte "üîä Audio aktivieren" klicken';
          const enableAudioBtn = document.getElementById('enableAudio');
          if (enableAudioBtn) enableAudioBtn.style.display = 'inline-block';
          return false;
        }
      }

      // Sicherstellen, dass der Context l√§uft
      const ctx = Tone.getContext ? Tone.getContext() : Tone.context;
      if (ctx && ctx.state !== 'running') {
        console.log('AudioContext nicht aktiv - starte...');
        await startToneContext();
      }

      // Synth wird bereits in initializeAudioOnUserInteraction() erstellt
      if (!synth) {
        console.log('Synth nicht verf√ºgbar - erstelle neu...');
        synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.02, decay: 0.2, sustain: 0.3, release: 0.6 }
        }).toDestination();
      }
      
      console.log('‚úÖ Audio-System bereit');
      return true;
    } catch (e) {
      console.error('Fehler beim Starten des AudioContext:', e);
      status.textContent = 'Audio-Fehler - bitte "üîä Audio aktivieren" klicken';
      return false;
    }
  }
  
  // Event-Listener f√ºr Audio-Initialisierung (nur einmal)
  document.addEventListener('click', initializeAudioOnUserInteraction, { once: true });
  document.addEventListener('keydown', initializeAudioOnUserInteraction, { once: true });
  document.addEventListener('touchstart', initializeAudioOnUserInteraction, { once: true });
  
  // ---------- Hauptfunktionen ----------
  function compute() {
    console.log('üé∏ compute() Funktion aufgerufen');
    try {
      // Pr√ºfe ob alle erforderlichen Elemente initialisiert sind
      if (!inp || !orig || !target || !diagrams || !ascii || !vfNotes || !vfTab) {
        console.log('Warte auf Initialisierung der HTML-Elemente...');
        setTimeout(compute, 100);
        return;
      }
      
      const input = inp.value.trim();
      if (!input) {
        console.log('Keine Eingabe vorhanden');
        return;
      }
      
      console.log('Verarbeite Eingabe:', input);
      
      // Parse Akkorde
      const chords = input.split(/[\s|]+/).filter(Boolean).map(s => s.trim());
      console.log('Geparste Akkorde:', chords);
      
      const parsed = chords.map(parseChord).filter(Boolean);
      console.log('Geparste Akkord-Objekte:', parsed);
      
      if (parsed.length === 0) {
        console.log('Keine g√ºltigen Akkorde gefunden');
        status.textContent = 'Keine g√ºltigen Akkorde gefunden';
        return;
      }
      
      // Bestimme Originaltonart (erster Akkord)
      const firstChord = parsed[0];
      const originalKey = firstChord.root;
      console.log('Originaltonart:', originalKey);
      
      // Stelle sicher, dass die Tonarten nur Noten enthalten
      const cleanOriginalKey = originalKey.replace(/[^A-G#b]/g, '');
      console.log('Bereinigte Originaltonart:', cleanOriginalKey);
      
      // Track, ob User das Feld manuell ver√§ndert hat
      if (!orig.dataset.userSet) {
        orig.addEventListener('change', () => orig.dataset.userSet = '1', { once: true });
      }
      
      // F√ºlle Tonart-Selects
      if (orig.children.length === 0) {
        ALL_KEYS.forEach(key => {
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = key;
          if (key === cleanOriginalKey) opt.selected = true;
          orig.appendChild(opt);
        });
      } else {
        // Synchronisiere orig mit dem ersten Akkord, solange User nicht manuell ge√§ndert hat
        if (!orig.dataset.userSet) {
          if ([...orig.options].some(o => o.value === cleanOriginalKey)) {
            orig.value = cleanOriginalKey;
          }
        }
      }
      
      if (target.children.length === 0) {
        ALL_KEYS.forEach(key => {
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = key;
          if (key === cleanOriginalKey) opt.selected = true;
          target.appendChild(opt);
        });
      }
      
      // F√ºlle Stimmungs-Select
      if (tuningSel.children.length === 0) {
        Object.keys(TUNINGS).forEach(tuning => {
          const opt = document.createElement('option');
          opt.value = tuning;
          opt.textContent = tuning;
          if (tuning === "E Standard (E A D G B E)") opt.selected = true;
          tuningSel.appendChild(opt);
        });
      }
      
      // Berechne Transposition (nach dem Bef√ºllen der Selects)
      const fromKey = orig.value;
      const toKey = target.value;
      
      // Stelle sicher, dass die Tonarten nur Noten enthalten
      const cleanFromKey = fromKey.replace(/[^A-G#b]/g, '');
      const cleanToKey = toKey.replace(/[^A-G#b]/g, '');
      
      const semitones = semiKeyToKey(cleanFromKey, cleanToKey) + parseInt(semi.value);
      console.log(`Transposition: ${cleanFromKey} -> ${cleanToKey} = ${semitones} Halbt√∂ne (Original: ${cleanOriginalKey})`);
      
      // Transponiere Akkorde
      const transposed = parsed.map(p => ({
        ...p,
        root: trNote(p.root, semitones),
        bass: p.bass ? trNote(p.bass, semitones) : null
      }));
      console.log('Transponierte Akkorde:', transposed);
      
      // Optimiere Voicings direkt aus transponierten Akkorden
      console.log('Optimiere Voicings...');
      const optimized = smooth(transposed);
      console.log('Optimierte Voicings:', optimized);
      
      // Slash-Chord-Optimierung
      console.log('Optimiere Slash-Chords...');
      const finalVoicings = optimizeSlashChords(transposed, optimized);
      console.log('Finale Voicings:', finalVoicings);
      
      // Zeige Ergebnis
      const display = transposed.map(c => {
        const suffix = c.quality === "maj" ? "" : c.quality === "min" ? "m" : c.quality;
        return c.bass ? `${c.root}${suffix}/${c.bass}` : `${c.root}${suffix}`;
      }).join(" ");
      
      console.log('Anzeige-String:', display);
      out.textContent = display;
      megaOut.textContent = display;
      
      // Speichere Akkorde f√ºr Vollbild-Animation
      window.megaChords = transposed;
      
      // Update Labels
      semiLbl.textContent = semi.value;
      capoLbl.textContent = capo.value;
      tempoLbl.textContent = tempo.value;
      
      // Rendere Griffbilder
      console.log('Rendere Griffbilder...');
      console.log('üé∏ useOriginalDiagrams:', window.useOriginalDiagrams);
      console.log('üé∏ transposed:', transposed);
      console.log('üé∏ finalVoicings:', finalVoicings);
      
      if (window.useOriginalDiagrams) {
        console.log('üé∏ Verwende originale Griffbilder');
        renderChordDiagramsOriginal(transposed, finalVoicings);
      } else {
        console.log('üé∏ Verwende moderne Griffbilder');
        renderChordDiagramsImproved(transposed, finalVoicings);
      }
      
      // Rendere ASCII-TAB
      console.log('Rendere ASCII-TAB...');
      const asciiContent = asciiTab(transposed, finalVoicings);
      ascii.innerHTML = `<pre style="font-family: monospace; white-space: pre; margin: 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">${asciiContent}</pre>`;
      
      // Rendere VexFlow-Notation
      console.log('Rendere VexFlow-Notation...');
      renderVexflow(transposed, finalVoicings);
      
      // Speichere f√ºr Audio
      window.currentChords = transposed;
      window.currentVoicings = finalVoicings;
      
      // Live-Akkord-Sharing System aktualisieren
      if (liveChordSystem) {
        liveChordSystem.currentChords = chords;
        liveChordSystem.guitarChords = chords;
        liveChordSystem.source = 'guitar';
        liveChordSystem.currentChordIndex = 0;
        
        // Griffbild f√ºr den ersten Akkord aktualisieren
        if (chords.length > 0 && griffbildModel) {
          updateGriffbildFromChord(chords[0]);
        }
        
        // Status aktualisieren
        updateGriffbildChordStatus();
        
        // Automatische Abspielung deaktiviert - Nutzer kann manuell abspielen
        // if (chords.length > 0 && chords.length <= 10 && griffbildModel) {
        //   setTimeout(() => {
        //     playAllGriffbildChords();
        //   }, 1000);
        // }
        
        console.log('üé∏ Live-Akkord-Sharing aktualisiert:', chords);
      }
      
      console.log('Compute erfolgreich abgeschlossen');
      status.textContent = 'Akkorde erfolgreich verarbeitet';
      
    } catch (e) {
      console.error('Fehler in compute:', e);
      status.textContent = 'Fehler: ' + e.message;
      
      // Zeige detaillierte Fehlerinformationen
      if (e.stack) {
        console.error('Stack Trace:', e.stack);
      }
    }
  }

  // Funktionen global verf√ºgbar machen
  window.compute = compute;
  
  // Verbesserte Slash-Chord-Behandlung
  function optimizeSlashChords(chords, voicings) {
    return voicings.map((voicing, index) => {
      const chord = chords[index];
      const parsed = parseChord(chord.root + (chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality) + (chord.bass ? "/" + chord.bass : ""));
      
      if (!parsed || !parsed.bass) {
        return voicing;
      }
      
      // Versuche den Bass-Ton auf der tiefsten klingenden Saite zu erzwingen
      const tuning = TUNINGS[tuningSel.value];
      const capoValue = parseInt(capo.value, 10);
      
      // Finde die tiefste klingende Saite
      let lowestString = -1;
      let lowestPitch = Infinity;
      
      voicing.f.forEach((fret, stringIndex) => {
        if (fret >= 0) {
          const pitch = tuning[stringIndex] + fret + capoValue;
          if (pitch < lowestPitch) {
            lowestPitch = pitch;
            lowestString = stringIndex;
          }
        }
      });
      
      // Wenn die tiefste Saite nicht den gew√ºnschten Bass-Ton hat
      if (lowestString >= 0) {
        const currentBassPitch = tuning[lowestString] + voicing.f[lowestString] + capoValue;
        const currentBassNote = idxToNote(currentBassPitch % 12, useFlatsForKey(target.value));
        const desiredBassNote = parsed.bass;
        
        // Enharmonischer Vergleich: Pitch-Class (0-11) statt String
        const pc = (note) => noteIndex(note) % 12;
        if (pc(currentBassNote) !== pc(desiredBassNote)) {
          // Versuche eine Alternative zu finden, die den Bass-Ton erzwingt
          const alternative = findAlternativeVoicing(parsed.root, parsed.quality, desiredBassNote);
          if (alternative) {
            return alternative;
          }
        }
      }
      
      return voicing;
    });
  }
  
  // Hilfsfunktion f√ºr alternative Voicings
  function findAlternativeVoicing(root, quality, bassNote) {
    // Versuche E- und A-Form Barre-Akkorde
    const eForm = barre(root, quality, false);
    const aForm = barre(root, quality, true);
    
    // Pr√ºfe welcher den gew√ºnschten Bass-Ton hat
    const tuning = TUNINGS[tuningSel.value];
    const capoValue = parseInt(capo.value, 10);
    
    const eFormBass = getLowestNote(eForm.f, tuning, capoValue);
    const aFormBass = getLowestNote(aForm.f, tuning, capoValue);
    
    // Enharmonischer Vergleich: Pitch-Class (0-11) statt String
    const pc = (note) => noteIndex(note) % 12;
    if (eFormBass && pc(eFormBass) === pc(bassNote)) return eForm;
    if (aFormBass && pc(aFormBass) === pc(bassNote)) return aForm;
    
    return null;
  }
  
  function getLowestNote(frets, tuning, capo) {
    let lowestPitch = Infinity;
    let lowestNote = null;
    
    frets.forEach((fret, stringIndex) => {
      if (fret >= 0) {
        const pitch = tuning[stringIndex] + fret + capo;
        if (pitch < lowestPitch) {
          lowestPitch = pitch;
          lowestNote = idxToNote(pitch % 12, useFlatsForKey(target.value));
        }
      }
    });
    
    return lowestNote;
  }
  
  // ---------- Rendering-Funktionen ----------
  function renderChordDiagrams(chords, voicings) {
    // Stabilit√§ts-Check f√ºr gro√üe Produktionen
    if (chords.length > 50) {
      console.warn('Gro√üe Akkordfolge - optimiere Griffbild-Rendering...');
      // Nur die ersten 20 Akkorde anzeigen f√ºr Performance
      chords = chords.slice(0, 20);
      voicings = voicings.slice(0, 20);
    }
    
    diagrams.innerHTML = '';
    
    chords.forEach((chord, i) => {
      const voicing = voicings[i];
      
      // Validierung der Voicing-Daten f√ºr Stabilit√§t
      if (!voicing || !Array.isArray(voicing.f) || voicing.f.length !== 6) {
        console.warn(`Ung√ºltiges Voicing f√ºr Akkord ${chord.full}:`, voicing);
        return;
      }
      
      const card = document.createElement('div');
      card.className = 'card';
      card.style.cssText = 'padding:12px; text-align:center; min-width:120px;';
      
      // Sicheres SVG-Aufbau statt innerHTML
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '120');
      svg.setAttribute('height', '140');
      svg.setAttribute('viewBox', '0 0 120 140');
      
      // Akkordname sicher setzen
      const chordName = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      chordName.setAttribute('x', '60');
      chordName.setAttribute('y', '20');
      chordName.setAttribute('text-anchor', 'middle');
      chordName.setAttribute('font-size', '14');
      chordName.setAttribute('font-weight', 'bold');
      chordName.textContent = chord.root + (chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality) + (chord.bass ? "/" + chord.bass : "");
      
      svg.appendChild(chordName);
      
      // Griffbrett-Hintergrund (heller, besser sichtbar)
      const fretboard = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      fretboard.setAttribute('x', '10');
      fretboard.setAttribute('y', '30');
      fretboard.setAttribute('width', '100');
      fretboard.setAttribute('height', '80');
      fretboard.setAttribute('fill', '#f8f9fa'); // Heller Hintergrund
      fretboard.setAttribute('stroke', '#2c3e50'); // Dunklerer Rand
      fretboard.setAttribute('stroke-width', '3'); // Dickerer Rand
      
      svg.appendChild(fretboard);
      
      // Sattel (Nullbund) - dick und deutlich
      const nut = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      nut.setAttribute('x1', '10');
      nut.setAttribute('y1', '30');
      nut.setAttribute('x2', '110');
      nut.setAttribute('y2', '30');
      nut.setAttribute('stroke', '#1a1a1a'); // Sehr dunkel
      nut.setAttribute('stroke-width', '4'); // Sehr dick
      svg.appendChild(nut);
      
      // Saiten zeichnen (d√ºnner, aber sichtbar)
      for (let s = 0; s < 6; s++) {
        const string = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        string.setAttribute('x1', 10 + s * 20);
        string.setAttribute('y1', '30');
        string.setAttribute('x2', 10 + s * 20);
        string.setAttribute('y2', '110');
        string.setAttribute('stroke', '#495057'); // Dunkler, besser sichtbar
        string.setAttribute('stroke-width', '1.5'); // Etwas dicker
        svg.appendChild(string);
      }
      
      // B√ºnde zeichnen (dicker und deutlicher)
      // Bund 1 bei y=50, Bund 2 bei y=70, usw.
      for (let f = 1; f <= 5; f++) {
        const fret = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        fret.setAttribute('x1', '10');
        fret.setAttribute('y1', 30 + f * 20);
        fret.setAttribute('x2', '110');
        fret.setAttribute('y2', 30 + f * 20);
        fret.setAttribute('stroke', '#495057'); // Dunkler, besser sichtbar
        fret.setAttribute('stroke-width', '2'); // Dicker
        svg.appendChild(fret);
      }
      
      // Fensterbasis bestimmen (korrekt: Open = 0, Bund 1 = 1, usw.)
      const positiveFrets = voicing.f.filter(f => f > 0);
      const baseFret = positiveFrets.length > 0 ? Math.min(...positiveFrets) : 0;
      
      // Startbund-Label (nur wenn > 0)
      if (baseFret > 0) {
        const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        lbl.setAttribute('x', '112');
        lbl.setAttribute('y', '44');
        lbl.setAttribute('font-size', '10');
        lbl.setAttribute('font-weight', 'bold');
        lbl.setAttribute('fill', '#666');
        lbl.textContent = `${baseFret}fr`;
        svg.appendChild(lbl);
      }
      
      // Fingerpositionen zeichnen (KORREKT: Finger liegen ZWISCHEN den B√ºnden!)
      voicing.f.forEach((fret, stringIndex) => {
        if (fret > 0) {
          // KORREKT: Finger liegt im Zwischenraum zwischen den B√ºnden
          // Bund 1: zwischen Sattel (y=30) und Bund 1 (y=50) ‚Üí y=40
          // Bund 2: zwischen Bund 1 (y=50) und Bund 2 (y=70) ‚Üí y=60
          // Bund 3: zwischen Bund 2 (y=70) und Bund 3 (y=90) ‚Üí y=80
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', 10 + stringIndex * 20);
          circle.setAttribute('cy', 30 + (fret - 0.5) * 20); // -0.5 f√ºr Zwischenraum
          circle.setAttribute('r', '9'); // Etwas gr√∂√üer
          circle.setAttribute('fill', '#007acc'); // Blau
          circle.setAttribute('stroke', '#005a99'); // Dunklerer Rand
          circle.setAttribute('stroke-width', '3'); // Dickerer Rand
          svg.appendChild(circle);
          
          // Fingernummer (vereinfacht - keine ung√ºltigen Werte)
          const fingerNum = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          fingerNum.setAttribute('x', 10 + stringIndex * 20);
          fingerNum.setAttribute('y', 30 + (fret - 0.5) * 20 + 4);
          fingerNum.setAttribute('text-anchor', 'middle');
          fingerNum.setAttribute('font-size', '12');
          fingerNum.setAttribute('fill', 'white');
          fingerNum.setAttribute('font-weight', 'bold');
          // Keine ung√ºltigen Fingernummern mehr
          fingerNum.textContent = '';
          svg.appendChild(fingerNum);
        } else if (fret === -1) {
          // Ged√§mpfte Saite - √ºber dem Sattel
          const x = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          x.setAttribute('x', 10 + stringIndex * 20);
          x.setAttribute('y', '25');
          x.setAttribute('text-anchor', 'middle');
          x.setAttribute('font-size', '18'); // Gr√∂√üer
          x.setAttribute('font-weight', 'bold');
          x.setAttribute('fill', '#dc3545'); // Rot f√ºr ged√§mpfte Saiten
          x.textContent = '√ó';
          svg.appendChild(x);
        }
      });
      
      // Open-String-Markierung (auf dem Sattel, y=30)
      voicing.f.forEach((fret, stringIndex) => {
        if (fret === 0) {
          const o = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          o.setAttribute('x', 10 + stringIndex * 20);
          o.setAttribute('y', '35'); // Auf dem Sattel, nicht dar√ºber
          o.setAttribute('text-anchor', 'middle');
          o.setAttribute('font-size', '14'); // Gr√∂√üer
          o.setAttribute('font-weight', 'bold');
          o.setAttribute('fill', '#28a745'); // Gr√ºn f√ºr offene Saiten
          o.textContent = '‚óã';
          svg.appendChild(o);
        }
      });
      
      card.appendChild(svg);
      diagrams.appendChild(card);
    });
    
    // Performance-Optimierung f√ºr gro√üe Produktionen
    if (chords.length > 20) {
      const performanceNote = document.createElement('div');
      performanceNote.style.cssText = 'text-align:center; margin-top:10px; color:#666; font-size:12px;';
      performanceNote.textContent = `Zeige ${chords.length} von ${window.currentChords?.length || 'vielen'} Akkorden (Performance-Optimierung)`;
      diagrams.appendChild(performanceNote);
    }
  }
  
  // Hilfsfunktion: Validiere und repariere Voicing-Daten
  function validateVoicing(voicing) {
    if (!voicing || !voicing.f || !Array.isArray(voicing.f)) {
      console.warn('Ung√ºltiges Voicing gefunden, erstelle Standard-Voicing');
      return {
        f: [0, 0, 0, 0, 0, 0], // Alle Saiten offen
        g: [0, 0, 0, 0, 0, 0]
      };
    }
    
    // Stelle sicher, dass es 6 Saiten gibt
    if (voicing.f.length !== 6) {
      console.warn('Voicing hat nicht 6 Saiten, erweitere auf 6');
      const extendedF = [...voicing.f];
      while (extendedF.length < 6) {
        extendedF.push(0); // Offene Saiten hinzuf√ºgen
      }
      voicing.f = extendedF.slice(0, 6);
    }
    
    // Validiere Fret-Werte
    voicing.f = voicing.f.map(f => {
      if (typeof f !== 'number' || f < 0 || f > 24) {
        return 0; // Fallback auf offene Saite
      }
      return f;
    });
    
    return voicing;
  }
  
  function renderVexflow(chords, voicings) {
    console.log('üéº Starte VexFlow-Rendering f√ºr', chords.length, 'Akkorde...');
    
    // Validiere Eingabedaten
    if (!chords || !Array.isArray(chords) || chords.length === 0) {
      console.error('‚ùå Ung√ºltige Akkord-Daten:', chords);
      showFallbackNotation([], []);
      return;
    }
    
    if (!voicings || !Array.isArray(voicings) || voicings.length === 0) {
      console.error('‚ùå Ung√ºltige Voicing-Daten:', voicings);
      showFallbackNotation(chords, []);
      return;
    }
    
    // Stelle sicher, dass chords und voicings die gleiche L√§nge haben
    if (chords.length !== voicings.length) {
      console.warn('Akkord- und Voicing-Arrays haben unterschiedliche L√§ngen, k√ºrze auf Minimum');
      const minLength = Math.min(chords.length, voicings.length);
      chords = chords.slice(0, minLength);
      voicings = voicings.slice(0, minLength);
    }
    
    // Stabilit√§ts-Check f√ºr gro√üe Produktionen
    if (chords.length > 100) {
      console.warn('Gro√üe Akkordfolge - optimiere VexFlow-Rendering...');
      // Nur die ersten 50 Akkorde f√ºr VexFlow anzeigen
      chords = chords.slice(0, 50);
      voicings = voicings.slice(0, 50);
    }
    
    // Pr√ºfe VexFlow-Verf√ºgbarkeit
    if (typeof VexFlow === 'undefined') {
      console.log('VexFlow ist nicht verf√ºgbar - lade neu...');
      loadVexFlowDynamically().then(() => {
        renderVexflow(chords, voicings);
      }).catch(e => {
        console.error('VexFlow konnte nicht geladen werden:', e);
        showFallbackNotation(chords, voicings);
      });
      return;
    }
    
    // Pr√ºfe ob VexFlow vollst√§ndig geladen ist
    if (!VexFlow.Renderer || !VexFlow.StaveNote) {
      console.log('VexFlow nicht vollst√§ndig geladen - warte...');
      setTimeout(() => renderVexflow(chords, voicings), 100);
      return;
    }
    
    try {
      const {Renderer, Stave, StaveNote, Voice, Formatter, TabStave, TabNote} = VexFlow;
      
      // Falls wir zuvor im Mock waren und jetzt echtes VexFlow da ist: Container leeren
      if (Renderer && Renderer.name !== 'MockRenderer') {
        vfNotes.innerHTML = '';
        vfTab.innerHTML = '';
      }
      
      // Pr√ºfe ob es sich um Mock VexFlow handelt oder ob VexFlow nicht vollst√§ndig geladen ist
      if (!Renderer || !StaveNote || Renderer.name === 'MockRenderer') {
        console.log('VexFlow nicht vollst√§ndig geladen - zeige Fallback...');
        showFallbackNotation(chords, voicings);
        return;
      }
      
      // Normale VexFlow-Notation - kompakt & stabil
      try {
        // ‚îÄ‚îÄ Standard-Notation (Notes) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const notesDiv = vfNotes;
        notesDiv.innerHTML = '';
        const notesRenderer = new Renderer(notesDiv, Renderer.Backends.SVG);
        const width = Math.max(320, 80 * chords.length);
        notesRenderer.resize(width, 150);
        const notesContext = notesRenderer.getContext();

        const stave = new Stave(10, 20, width - 20);
        stave.setContext(notesContext).draw();

        const notes = chords.map(chord => {
          // Validiere Akkord-Daten
          if (!chord || !chord.root) {
            console.warn('Ung√ºltiger Akkord gefunden:', chord);
            return new StaveNote({
          clef: 'treble',
              keys: ['c/4'], // Fallback auf C
          duration: 'q'
            });
          }
          
          // Bereinige Root-Note (entferne Akkord-Qualit√§ten)
          const cleanRoot = chord.root.replace(/[^A-G#b]/g, '').toLowerCase();
          
          // Validiere Note
          if (!cleanRoot || !['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'].includes(cleanRoot)) {
            console.warn('Ung√ºltige Note gefunden:', chord.root, 'verwende C');
            return new StaveNote({
              clef: 'treble',
              keys: ['c/4'],
              duration: 'q'
            });
          }
          
          return new StaveNote({
            clef: 'treble',
            keys: [cleanRoot + '/4'],
            duration: 'q'
          });
        });

        // Eine Voice, die exakt die Summe der Viertel enth√§lt
        const voice = new Voice({ time: { num_beats: notes.length, beat_value: 4 } });
        voice.setMode(VexFlow.Voice.Mode.SOFT); // Fehlertoleranter Modus
        voice.addTickables(notes);

        new Formatter().joinVoices([voice]).format([voice], width - 40);
        voice.draw(notesContext, stave);
        
        console.log('‚úÖ VexFlow-Notation erfolgreich gerendert');
      } catch (e) {
        console.error('‚ùå Fehler bei VexFlow-Notation:', e);
        showFallbackNotation(chords, voicings);
        return;
      }

      // ‚îÄ‚îÄ Tabulatur (Tab) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      try {
        const tabDiv = vfTab;
        tabDiv.innerHTML = '';
        const tabRenderer = new Renderer(tabDiv, Renderer.Backends.SVG);
        const tabWidth = Math.max(320, 80 * chords.length);
        tabRenderer.resize(tabWidth, 150);
        const tabContext = tabRenderer.getContext();

        const tabStave = new TabStave(10, 20, tabWidth - 20);
        tabStave.setContext(tabContext).draw();
        
        const tabNotes = voicings.map(voicing => {
          // Validiere und repariere Voicing-Daten
          const validVoicing = validateVoicing(voicing);
          
          // Erstelle TabNote mit validierten Daten
          const validPositions = validVoicing.f
            .map((f, i) => ({ str: 6 - i, fret: f }))
            .filter(p => p.fret >= 0); // Nur gespielte Saiten
          
          // Mindestens eine Position muss vorhanden sein
          if (validPositions.length === 0) {
            console.warn('Keine g√ºltigen Positionen gefunden, verwende Standard');
            validPositions.push({ str: 6, fret: 0 });
          }
          
          return new TabNote({
            positions: validPositions,
          duration: 'q'
          });
        });

        const tabVoice = new Voice({ time: { num_beats: tabNotes.length, beat_value: 4 } });
        tabVoice.setMode(VexFlow.Voice.Mode.SOFT); // Fehlertoleranter Modus
        tabVoice.addTickables(tabNotes);

        new Formatter().joinVoices([tabVoice]).format([tabVoice], tabWidth - 40);
        tabVoice.draw(tabContext, tabStave);
        
        console.log('‚úÖ VexFlow-Tabulatur erfolgreich gerendert');
      } catch (e) {
        console.error('‚ùå Fehler bei VexFlow-Tabulatur:', e);
        // Fallback f√ºr Tabulatur
        const tabDiv = vfTab;
        tabDiv.innerHTML = `
          <div style="text-align:center; padding:20px; background:#f8f9fa; border-radius:8px;">
            <h3 style="color:#333; margin:0 0 15px 0;">üé∏ Tabulatur</h3>
            <div style="font-size:14px; color:#333; font-family:monospace; line-height:1.6; text-align:left;">
              ${voicings.map((voicing, i) => {
                const chord = chords[i];
                const suffix = chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality;
                const chordName = chord.root + suffix + (chord.bass ? "/" + chord.bass : "");
                return `<div style="margin:10px 0; padding:8px; background:white; border-radius:4px;">
                  <strong style="color:#007acc;">${chordName}:</strong> 
                  <span style="color:#666;">${voicing.f.map(f => f < 0 ? 'x' : f).join(' ')}</span>
                </div>`;
              }).join('')}
            </div>
          </div>
        `;
      }
      
    } catch (e) {
      console.error('‚ùå Allgemeiner Fehler beim VexFlow-Rendering:', e);
      showFallbackNotation(chords, voicings);
    }
  }
  
  // ---------- Audio-Funktionen ----------
  async function startPlayback() {
    // Stabile Audio-Initialisierung f√ºr gro√üe Produktionen
    try {
      if (!window.Tone) {
        await initializeAudioOnUserInteraction();
      }
      if (!audioInitialized || !synth) {
        await initializeAudioOnUserInteraction();
      }
      // Sichere Audio-Bereitschaft
      if (!await ensureAudio()) return;
    } catch (e) {
      console.error('Audio-Initialisierung fehlgeschlagen:', e);
      status.textContent = 'Audio-Initialisierung fehlgeschlagen - bitte "üîä Audio aktivieren" klicken';
      return;
    }
    
    if (isPlaying) {
      stopPlayback();
      return;
    }
    
    const chords = window.currentChords;
    const voicings = window.currentVoicings;
    
    if (!chords || !voicings) {
      status.textContent = 'Keine Akkorde zum Abspielen verf√ºgbar';
      return;
    }
    
    console.log('üéµ Starte Akkord-Wiedergabe mit', chords.length, 'Akkorden');
    console.log('Akkorde:', chords);
    console.log('Voicings:', voicings);
    
    isPlaying = true;
    playBtn.textContent = '‚è∏ Pause';
    
    const statusElement = document.getElementById('status');
    if (statusElement) {
      statusElement.textContent = 'Spielt Akkorde ab...';
    }
    
    // Animierte Wiedergabe-Anzeige starten
    startPlaybackAnimation(chords.length);
    
    // BPM setzen
    const bpm = parseInt(tempo.value) || 120;
    if (Tone.Transport && Tone.Transport.bpm) {
      Tone.Transport.bpm.value = bpm;
    }
    
    // Akkord-Interval berechnen (4 Beats pro Akkord)
    const chordInterval = (60 / bpm) * 4;
    console.log(`BPM: ${bpm}, Akkord-Interval: ${chordInterval}s`);
    
    // Sichere Tuning-Auswahl
    let tuningKey = "E Standard (E A D G B E)";
    if (tuningSel && tuningSel.value && TUNINGS[tuningSel.value]) {
      tuningKey = tuningSel.value;
    }
    const tuning = TUNINGS[tuningKey];
    const capoValue = parseInt(capo.value, 10) || 0;
    
    console.log('Tuning:', tuningKey, 'Capo:', capoValue);
    
    // Akkorde mit Tone.js abspielen
    chords.forEach((chord, index) => {
      const voicing = voicings[index];
      
      if (!voicing || !voicing.f) {
        console.warn(`Ung√ºltiges Voicing f√ºr Akkord ${index}:`, voicing);
        return;
      }
      
      // Extrahiere Noten aus Voicing
      const chordNotes = [];
      voicing.f.forEach((fret, stringIndex) => {
        if (fret >= 0 && stringIndex < tuning.length) {
          const tuningNote = tuning[stringIndex];
          const midi = tuningNote + fret + capoValue;
          
          // Konvertiere MIDI zu Note-Name
          const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
          const pc = ((midi % 12) + 12) % 12;
          const oct = Math.floor(midi / 12) - 1;
          const note = NAMES_SHARP[pc] + oct;
          
          chordNotes.push(note);
        }
      });
      
             // Akkord-Name f√ºr Logging
       const chordName = chord.root + (chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality) + (chord.bass ? "/" + chord.bass : "");
       console.log(`Akkord ${index} (${chordName}):`, chordNotes);
      
      if (chordNotes.length > 0) {
        // Spiele Akkord mit Tone.js
        const playTime = Tone.now() + (index * chordInterval);
        
        try {
          // Verwende den globalen Synth
                     if (synth && synth.triggerAttackRelease) {
             synth.triggerAttackRelease(chordNotes, chordInterval * 0.8, playTime);
             console.log(`‚úÖ Akkord ${chordName} geplant f√ºr ${playTime}s`);
           } else {
             // Fallback: Erstelle neuen Synth
             const chordSynth = new Tone.PolySynth(Tone.Synth, {
               oscillator: { type: 'triangle' },
               envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.8 }
             }).toDestination();
             
             chordSynth.triggerAttackRelease(chordNotes, chordInterval * 0.8, playTime);
             console.log(`‚úÖ Akkord ${chordName} mit Fallback-Synth geplant`);
           }
          
                     // UI-Update f√ºr aktuellen Akkord
           setTimeout(() => {
             updateCurrentChordDisplay(chordName, index);
             updatePlaybackProgress(index, chords.length);
           }, index * chordInterval * 1000);
          
                 } catch (e) {
           console.error(`Fehler beim Abspielen von Akkord ${chordName}:`, e);
         }
      }
    });
    
    // Sequencer f√ºr Stop-Funktion
    window.chordSequencer = {
      stop: function() { 
        console.log('Akkord-Sequencer gestoppt');
        isPlaying = false;
        playBtn.textContent = '‚ñ∂Ô∏é Abspielen';
      },
      dispose: function() { 
        console.log('Akkord-Sequencer entsorgt');
      }
    };
    
    // Status-Update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = `Spielt ${chords.length} Akkorde bei ${bpm} BPM`;
    }
    
    console.log(`üéµ Akkordfolge gestartet: ${chords.length} Akkorde bei ${bpm} BPM`);
    
    // Test-Signal zur Best√§tigung
    try {
      console.log('Teste Audio-System...');
      synth.triggerAttackRelease(['C4'], '8n', Tone.now() + 0.05);
      console.log('‚úÖ Audio-System funktioniert');
    } catch (e) {
      console.warn('Test-Signal fehlgeschlagen:', e);
    }
    
    // Status-Logging f√ºr Debugging
    setTimeout(() => {
      console.log('Transport State:', Tone.Transport.state);
      console.log('Transport Position:', Tone.Transport.position);
      console.log('Transport BPM:', Tone.Transport.bpm.value);
    }, 100);
  }
  
  // Hilfsfunktionen f√ºr Akkord-Wiedergabe
  function updateCurrentChordDisplay(chordName, index) {
    try {
      // Aktuellen Akkord in der UI hervorheben
      const chordElements = document.querySelectorAll('.chord-display');
      chordElements.forEach((el, i) => {
        if (i === index) {
          el.style.backgroundColor = '#1db954';
          el.style.color = 'white';
        } else {
          el.style.backgroundColor = '';
          el.style.color = '';
        }
      });
      
      // Status aktualisieren
      const status = document.getElementById('status');
      if (status) {
        status.textContent = `Spielt: ${chordName} (${index + 1}/${window.currentChords?.length || 0})`;
      }
    } catch (e) {
      console.warn('Fehler beim Update der Akkord-Anzeige:', e);
    }
  }
  
  function updatePlaybackProgress(currentIndex, totalChords) {
    try {
      const progress = (currentIndex / totalChords) * 100;
      
      // Progress-Bar aktualisieren
      const progressBars = document.querySelectorAll('.progress-bar');
      progressBars.forEach(bar => {
        bar.style.width = `${progress}%`;
      });
      
      console.log(`Progress: ${progress.toFixed(1)}% (${currentIndex + 1}/${totalChords})`);
    } catch (e) {
      console.warn('Fehler beim Update des Progress:', e);
    }
  }
  
  function startPlaybackAnimation(totalChords) {
    try {
      console.log('Starte Playback-Animation f√ºr', totalChords, 'Akkorde');
      
      // Animation-Status setzen
      window.playbackAnimationActive = true;
      
      // Progress-Bar erstellen falls nicht vorhanden
      let progressBar = document.querySelector('.playback-progress');
      if (!progressBar) {
        progressBar = document.createElement('div');
        progressBar.className = 'playback-progress';
        progressBar.style.cssText = `
          position: fixed; bottom: 0; left: 0; height: 4px; 
          background: #1db954; width: 0%; transition: width 0.3s;
          z-index: 1000;
        `;
        document.body.appendChild(progressBar);
      }
      
    } catch (e) {
      console.warn('Fehler beim Starten der Playback-Animation:', e);
    }
  }
  
  function stopPlaybackAnimation() {
    try {
      window.playbackAnimationActive = false;
      
      // Progress-Bar entfernen
      const progressBar = document.querySelector('.playback-progress');
      if (progressBar) {
        progressBar.remove();
      }
      
      // Alle Akkord-Highlights entfernen
      const chordElements = document.querySelectorAll('.chord-display');
      chordElements.forEach(el => {
        el.style.backgroundColor = '';
        el.style.color = '';
      });
      
    } catch (e) {
      console.warn('Fehler beim Stoppen der Playback-Animation:', e);
    }
  }
  
  function stopPlayback() {
    try {
      // Alle Sequencer stoppen
      if (window.chordSequencer) {
        window.chordSequencer.stop();
        window.chordSequencer.dispose();
        window.chordSequencer = null;
      }
      
      // chordPart wird nicht mehr verwendet, da wir chordSequencer verwenden
      
      // Nur Transport stoppen wenn Metronom nicht l√§uft
      if (!metroLoop) {
        Tone.Transport.stop();
        Tone.Transport.position = 0;
      }
      
      // Animierte Wiedergabe-Anzeige stoppen
      stopPlaybackAnimation();
      stopFullscreenPlaybackAnimation();
      
      // UI zur√ºcksetzen
      isPlaying = false;
      playBtn.textContent = '‚ñ∂Ô∏é Abspielen';
      
      const status = document.getElementById('status');
      if (status) {
        status.textContent = 'Gestoppt';
      }
      
      // Alle Progress-Bars zur√ºcksetzen
      const progressBars = document.querySelectorAll('.progress-bar');
      progressBars.forEach(bar => {
        bar.style.width = '0%';
      });
      
      // Alle Akkord-Highlights entfernen
      const chordElements = document.querySelectorAll('.chord-display');
      chordElements.forEach(el => {
        el.style.backgroundColor = '';
        el.style.color = '';
      });
      
    } catch (error) {
      console.error('Fehler beim Stoppen der Wiedergabe:', error);
      isPlaying = false;
      playBtn.textContent = '‚ñ∂Ô∏é Abspielen';
    }
  }
  
  async function startMetronome() {
    if (!await ensureAudio()) return;
    
    if (metroLoop) {
      stopMetronome();
      return;
    }
    
    const bpm = parseInt(tempo.value) || 120;
    if (Tone.Transport && Tone.Transport.bpm) {
      Tone.Transport.bpm.value = bpm;
    }
    
    // Metronom-Sounds mit besserer Klangqualit√§t
    const metroSynth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    
    const metroAccent = new Tone.Synth({
      oscillator: { type: 'square' },
      envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 }
    }).toDestination();
    
    // Echtes Metronom mit WebAudio (wie in griffbild.txt)
    console.log('Erstelle echtes Metronom mit WebAudio...');
    
    const metroBpm = parseInt(tempo.value) || 120;
    const beatInterval = (60 / metroBpm) * 1000; // Millisekunden zwischen Beats
    
    console.log(`BPM: ${metroBpm}, Beat-Interval: ${beatInterval}ms`);
    
    // WebAudio Context f√ºr Metronom
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!window.audioCtx) {
      window.audioCtx = new AudioCtx();
    }
    const actx = window.audioCtx;
    
    // Metronom-Events mit korrektem BPM
    const metroBeats = [];
    for (let measure = 0; measure < 2; measure++) {
      for (let beat = 0; beat < 4; beat++) {
        const time = (measure * 4 + beat) * beatInterval;
        const beatNumber = measure * 4 + beat;
        metroBeats.push({
          time: time,
          beat: beatNumber,
          isAccent: beat === 0 // Erster Beat jedes Takts ist Akzent
        });
      }
    }
    
    console.log('Metro Beats:', metroBeats);
    
    // Spiele Metronom-Beats mit WebAudio
    metroBeats.forEach((beat) => {
      setTimeout(() => {
        console.log(`ü•Å Metro beat ${beat.beat} at ${beat.time}ms`);
        
        const t0 = actx.currentTime + 0.03;
        const freq = beat.isAccent ? 880 : 440; // C5 f√ºr Akzent, C4 f√ºr normal
        const osc = actx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        const gain = actx.createGain();
        const volume = beat.isAccent ? 0.12 : 0.08;
        
        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(volume, t0 + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.3);
        
        osc.connect(gain).connect(actx.destination);
        osc.start(t0);
        osc.stop(t0 + 0.4);
        
        console.log(`‚úÖ ${beat.isAccent ? 'Akzent' : 'Normal'}-Beat gespielt`);
      }, beat.time);
    });
    
    // Erstelle einen Dummy-Metronom f√ºr die Stop-Funktion
    metroLoop = {
      stop: function() { console.log('Dummy metronom stopped'); },
      dispose: function() { console.log('Dummy metronom disposed'); }
    };
    
    // Loop-Funktionalit√§t wird durch setTimeout implementiert
    
    console.log('Starte setTimeout-basiertes Metronom...');
    // Metronom wird automatisch durch setTimeout gestartet
    
    metronomeBtn.textContent = 'ü•Å Metronom Stop';
    status.textContent = `Metronom l√§uft bei ${bpm} BPM`;
  }
  
  function stopMetronome() {
    if (metroLoop) {
      metroLoop.stop();
      metroLoop.dispose();
      metroLoop = null;
    }
    
    // Nur Transport stoppen wenn weder Playback noch Metronom l√§uft
    if (!isPlaying && Tone.Transport.state === 'started') {
      Tone.Transport.stop();
      Tone.Transport.position = 0; // Reset auf Anfang
    }
    metronomeBtn.textContent = 'ü•Å Metronom';
    status.textContent = 'Metronom gestoppt';
  }
  
  // ---------- Griffbild-Editor (basierend auf griffbild.txt) ----------
  let griffbildEditor = null;
  let griffbildModel = null;
  
  // Initialisiere Griffbild-Model beim Laden
  document.addEventListener('DOMContentLoaded', () => {
    initializeGriffbild();
  });
  
  function openGriffbildEditor() {
    if (griffbildEditor) {
      griffbildEditor.remove();
      griffbildEditor = null;
      return;
    }
    
    // Erstelle Griffbild-Editor Dialog
    griffbildEditor = document.createElement('div');
    griffbildEditor.style.cssText = `
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #0b0c10; border: 1px solid #2a2f3a; border-radius: 16px;
      padding: 20px; z-index: 1001; min-width: 400px; max-width: 600px;
      color: #e7ebf4; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
    `;
    
    griffbildEditor.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #6ae3ff;">üé∏ Griffbild-Editor</h3>
        <button onclick="closeGriffbildEditor()" style="background: #121826; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer;">‚úï</button>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div>
          <label style="display: block; margin-bottom: 8px; font-size: 12px; color: #9aa3b2;">Stimmung</label>
          <select id="griffbildTuning" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #2a2f3a; background: #0e1118; color: #e7ebf4;">
            <option value="E2,A2,D3,G3,B3,E4">Standard (E A D G B E)</option>
            <option value="D2,A2,D3,G3,B3,E4">Drop D</option>
            <option value="D2,A2,D3,G3,A3,D4">DADGAD</option>
            <option value="D2,G2,D3,G3,B3,D4">Open G</option>
          </select>
          

          
          <div style="margin-top: 15px;">
            <label style="display: block; margin-bottom: 8px; font-size: 12px; color: #9aa3b2;">Akkord-Name</label>
            <input id="griffbildName" type="text" placeholder="z.B. Dm" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #2a2f3a; background: #0e1118; color: #e7ebf4;">
          </div>
          
          <div style="margin-top: 15px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
              <button onclick="setGriffbildDot()" style="background: #121826; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer;">üéØ Note setzen</button>
              <button onclick="setGriffbildOpen()" style="background: #121826; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer;">‚≠ï Offen</button>
              <button onclick="setGriffbildMute()" style="background: #121826; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer;">‚ùå Ged√§mpft</button>
            </div>
            <button onclick="playGriffbildChord()" style="background: #1a3442; border: 1px solid #1a3442; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer; width: 100%; margin-bottom: 10px;">üéµ Aktuellen Akkord abspielen</button>
            
            <!-- Akkordfolge abspielen -->
            <button onclick="playAllGriffbildChords()" style="background: #1db954; border: 1px solid #1db954; color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; width: 100%; margin-bottom: 10px;">üéº Ganze Akkordfolge abspielen</button>
            
            <!-- Akkord-Navigation -->
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
              <button onclick="previousGriffbildChord()" style="background: #2a2f3a; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer; flex: 1;">‚¨ÖÔ∏è Vorheriger</button>
              <button onclick="nextGriffbildChord()" style="background: #2a2f3a; border: 1px solid #2a2f3a; color: #e7ebf4; padding: 8px 12px; border-radius: 8px; cursor: pointer; flex: 1;">N√§chster ‚û°Ô∏è</button>
            </div>
            
            <!-- Akkord-Status -->
            <div id="griffbildChordStatus" style="font-size: 12px; color: #9aa3b2; text-align: center; padding: 8px; background: #0e1118; border-radius: 6px; margin-top: 10px;">
              Keine Akkorde geladen
            </div>
          </div>
          
          <div style="margin-top: 15px;">
            <div id="griffbildNotes" style="font-size: 12px; color: #9aa3b2;">Noten: ‚Äì</div>
            <div id="griffbildFrets" style="font-size: 12px; color: #9aa3b2;">Griff: ‚Äì</div>
          </div>
        </div>
        
        <div>
          <div id="griffbildSVG" style="border: 1px solid #2a2f3a; border-radius: 8px; padding: 10px; background: #0e1118;"></div>
        </div>
      </div>
    `;
    
    document.body.appendChild(griffbildEditor);
    
    // Initialisiere Griffbild-Model
    const tuningSelect = document.getElementById('griffbildTuning');
    const tuningStr = tuningSelect ? tuningSelect.value : 'E2,A2,D3,G3,B3,E4';
    
    // Event-Listener f√ºr Tuning-√Ñnderung
    if (tuningSelect) {
      tuningSelect.addEventListener('change', () => {
        const newTuningStr = tuningSelect.value;
        const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
        const newTuning = newTuningStr.split(',').map(noteStr => {
          const match = noteStr.match(/^([A-G])([b#]?)(\d)$/);
          if (!match) return 28; // Fallback E2
          const [, noteName, accidental, octave] = match;
          const noteIndex = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[noteName];
          const accidentalOffset = accidental === '#' ? 1 : accidental === 'b' ? -1 : 0;
          const midiNote = 12 * (parseInt(octave) + 1) + ((noteIndex + accidentalOffset + 12) % 12);
          return midiNote;
        });
        
        griffbildModel.tuning = newTuning;
        updateGriffbildDisplay();
        console.log('üé∏ Tuning ge√§ndert zu:', newTuningStr, 'MIDI:', newTuning);
      });
    }
    
    // Parse Tuning-String zu MIDI-Nummern
    const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const tuning = tuningStr.split(',').map(noteStr => {
      const match = noteStr.match(/^([A-G])([b#]?)(\d)$/);
      if (!match) return 28; // Fallback E2
      const [, noteName, accidental, octave] = match;
      const noteIndex = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[noteName];
      const accidentalOffset = accidental === '#' ? 1 : accidental === 'b' ? -1 : 0;
      const midiNote = 12 * (parseInt(octave) + 1) + ((noteIndex + accidentalOffset + 12) % 12);
      return midiNote;
    });
    
    griffbildModel = {
      strings: 6,
      frets: 5,
      baseFret: 1,
      tuning: tuning,
      mutes: new Set(),
      opens: new Set(),
      dots: new Map(),
      name: ""
    };
    
    // Setze Dm-Akkord als Beispiel
    griffbildModel.mutes.add(0); // E-Saite ged√§mpft
    griffbildModel.mutes.add(1); // A-Saite ged√§mpft
    griffbildModel.opens.add(2); // D-Saite offen
    griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
    griffbildModel.dots.set("4", 3); // B-Saite 3. Bund
    griffbildModel.dots.set("5", 1); // E-Saite 1. Bund
    griffbildModel.name = "Dm";
    
    updateGriffbildDisplay();
  }
  
  function closeGriffbildEditor() {
    if (griffbildEditor) {
      griffbildEditor.remove();
      griffbildEditor = null;
      griffbildModel = null;
    }
  }
  
  function updateGriffbildDisplay() {
    if (!griffbildEditor || !griffbildModel) return;
    
    const svgContainer = document.getElementById('griffbildSVG');
    const size = 200;
    const pad = 14;
    const w = size, h = size;
    const innerW = w - 2 * pad, innerH = h - 2 * pad - 18;
    const colW = innerW / (griffbildModel.strings - 1);
    const rowH = innerH / griffbildModel.frets;
    
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.style.width = "100%";
    svg.style.height = "auto";
    
    // Title
    const title = document.createElementNS(svgNS, "text");
    title.setAttribute("x", pad);
    title.setAttribute("y", 12);
    title.setAttribute("font-size", "10");
    title.setAttribute("fill", "#9aa3b2");
    title.textContent = griffbildModel.baseFret > 1 ? `${griffbildModel.baseFret}. Bund` : "Sattel";
    svg.appendChild(title);
    
    // Grid
    const gGrid = document.createElementNS(svgNS, "g");
    gGrid.setAttribute("transform", `translate(${pad}, ${pad + 6})`);
    svg.appendChild(gGrid);
    
    // Frets
    for (let r = 0; r <= griffbildModel.frets; r++) {
      const y = r * rowH;
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", 0);
      line.setAttribute("x2", innerW);
      line.setAttribute("y1", y);
      line.setAttribute("y2", y);
      line.setAttribute("stroke", r === 0 && griffbildModel.baseFret === 1 ? "#e7ebf4" : "#2a2f3a");
      line.setAttribute("stroke-width", r === 0 && griffbildModel.baseFret === 1 ? 2.8 : 1);
      gGrid.appendChild(line);
    }
    
    // Strings
    for (let c = 0; c < griffbildModel.strings; c++) {
      const x = c * colW;
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", x);
      line.setAttribute("x2", x);
      line.setAttribute("y1", 0);
      line.setAttribute("y2", innerH);
      line.setAttribute("stroke", "#2a2f3a");
      gGrid.appendChild(line);
    }
    
    // Open/Muted markers
    for (let s = 0; s < griffbildModel.strings; s++) {
      const x = s * colW;
      const y = -rowH * 0.55;
      if (griffbildModel.opens.has(s)) {
        const circ = document.createElementNS(svgNS, "circle");
        circ.setAttribute("cx", x);
        circ.setAttribute("cy", y);
        circ.setAttribute("r", 6);
        circ.setAttribute("fill", "none");
        circ.setAttribute("stroke", "#e7ebf4");
        circ.setAttribute("stroke-width", "1.4");
        gGrid.appendChild(circ);
      } else if (griffbildModel.mutes.has(s)) {
        const g = document.createElementNS(svgNS, "g");
        g.setAttribute("transform", `translate(${x - 5},${y - 6})`);
        const l1 = document.createElementNS(svgNS, "line");
        l1.setAttribute("x1", 0);
        l1.setAttribute("y1", 0);
        l1.setAttribute("x2", 10);
        l1.setAttribute("y2", 12);
        l1.setAttribute("stroke", "#e7ebf4");
        l1.setAttribute("stroke-width", "1.6");
        const l2 = document.createElementNS(svgNS, "line");
        l2.setAttribute("x1", 10);
        l2.setAttribute("y1", 0);
        l2.setAttribute("x2", 0);
        l2.setAttribute("y2", 12);
        l2.setAttribute("stroke", "#e7ebf4");
        l2.setAttribute("stroke-width", "1.6");
        g.appendChild(l1);
        g.appendChild(l2);
        gGrid.appendChild(g);
      }
    }
    
    // Dots
    for (const [k, lf] of griffbildModel.dots) {
      const s = parseInt(k, 10);
      const x = s * colW;
      const y = (lf - 0.5) * rowH;
      const circ = document.createElementNS(svgNS, "circle");
      circ.setAttribute("cx", x);
      circ.setAttribute("cy", y);
      circ.setAttribute("r", Math.min(9, rowH * 0.35));
      circ.setAttribute("fill", "#6ae3ff");
      gGrid.appendChild(circ);
    }
    
    // Hit areas
    const gHit = document.createElementNS(svgNS, "g");
    gHit.setAttribute("transform", `translate(${pad}, ${pad + 6})`);
    svg.appendChild(gHit);
    
    for (let s = 0; s < griffbildModel.strings; s++) {
      for (let f = 1; f <= griffbildModel.frets; f++) {
        const rect = document.createElementNS(svgNS, "rect");
        rect.setAttribute("x", s * colW - colW / 2);
        rect.setAttribute("y", (f - 1) * rowH);
        rect.setAttribute("width", colW);
        rect.setAttribute("height", rowH);
        rect.setAttribute("fill", "transparent");
        rect.style.cursor = "pointer";
        rect.addEventListener('click', () => {
          setGriffbildDot(s, f);
        });
        gHit.appendChild(rect);
      }
      
      // Open/mute toggles
      const topRect = document.createElementNS(svgNS, "rect");
      topRect.setAttribute("x", s * colW - colW / 2);
      topRect.setAttribute("y", -rowH * 0.95);
      topRect.setAttribute("width", colW);
      topRect.setAttribute("height", rowH * 0.8);
      topRect.setAttribute("fill", "transparent");
      topRect.style.cursor = "pointer";
      topRect.addEventListener('click', (e) => {
        if (e.shiftKey) {
          setGriffbildMute(s);
        } else {
          setGriffbildOpen(s);
        }
      });
      gHit.appendChild(topRect);
    }
    
    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    
    // Update notes display
    updateGriffbildNotes();
  }
  
  function setGriffbildDot(stringIdx, localFret) {
    if (!griffbildModel) return;
    
    const k = String(stringIdx);
    const cur = griffbildModel.dots.get(k);
    if (cur === localFret) {
      griffbildModel.dots.delete(k);
    } else {
      griffbildModel.dots.set(k, localFret);
      griffbildModel.opens.delete(stringIdx);
      griffbildModel.mutes.delete(stringIdx);
    }
    updateGriffbildDisplay();
  }
  
  function setGriffbildOpen(stringIdx) {
    if (!griffbildModel) return;
    
    if (griffbildModel.opens.has(stringIdx)) {
      griffbildModel.opens.delete(stringIdx);
    } else {
      griffbildModel.opens.add(stringIdx);
      griffbildModel.mutes.delete(stringIdx);
      griffbildModel.dots.delete(String(stringIdx));
    }
    updateGriffbildDisplay();
  }
  
  function setGriffbildMute(stringIdx) {
    if (!griffbildModel) return;
    
    if (griffbildModel.mutes.has(stringIdx)) {
      griffbildModel.mutes.delete(stringIdx);
    } else {
      griffbildModel.mutes.add(stringIdx);
      griffbildModel.opens.delete(stringIdx);
      griffbildModel.dots.delete(String(stringIdx));
    }
    updateGriffbildDisplay();
  }
  
  function updateGriffbildNotes() {
    if (!griffbildModel) return;
    
    const notes = [];
    const frets = [];
    
    for (let s = 0; s < griffbildModel.strings; s++) {
      if (griffbildModel.mutes.has(s)) {
        notes.push('x');
        frets.push('x');
      } else if (griffbildModel.opens.has(s)) {
        const midi = griffbildModel.tuning[s];
        const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
        const pc = ((midi % 12) + 12) % 12;
        const oct = Math.floor(midi / 12) - 1;
        const note = NAMES_SHARP[pc] + oct;
        notes.push(note);
        frets.push('0');
      } else {
        const lf = griffbildModel.dots.get(String(s));
        if (lf != null) {
          const absFret = griffbildModel.baseFret + lf - 1;
          const midi = griffbildModel.tuning[s] + absFret;
          const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
          const pc = ((midi % 12) + 12) % 12;
          const oct = Math.floor(midi / 12) - 1;
          const note = NAMES_SHARP[pc] + oct;
          notes.push(note);
          frets.push(absFret);
        } else {
          notes.push('-');
          frets.push('-');
        }
      }
    }
    
    const notesEl = document.getElementById('griffbildNotes');
    const fretsEl = document.getElementById('griffbildFrets');
    if (notesEl) notesEl.textContent = `Noten: ${notes.join(' ')}`;
    if (fretsEl) fretsEl.textContent = `Griff: ${frets.join(' ')}`;
  }
  

  
  function playGriffbildChord() {
    if (!griffbildModel) {
      console.log('‚ùå Kein Griffbild-Model verf√ºgbar');
      return;
    }
    
    // Verwende das vorhandene Tone.js System
    if (!window.Tone) {
      console.log('‚ùå Tone.js nicht verf√ºgbar, verwende Web Audio API');
      playGriffbildChordWithWebAudio();
      return;
    }
    
    // Verwende die vorhandenen Akkord-Definitionen statt Griffbild-Berechnung
    const chordName = griffbildModel.name;
    let notes = [];
    
    if (chordName && CHORDS[chordName]) {
      // Verwende die echten Akkord-Definitionen
      notes = CHORDS[chordName].map(note => note + '4'); // Oktave 4 hinzuf√ºgen
      console.log('üé∏ Verwende echte Akkord-Definition f√ºr:', chordName, notes);
    } else {
      // Fallback: Verwende getChordNotes Funktion
      console.log('üé∏ Verwende getChordNotes f√ºr:', chordName);
      notes = getChordNotes(chordName);
    }
    
    console.log('üé∏ Griffbild-Akkord Noten:', notes);
    
    if (notes.length === 0) {
      console.log('‚ùå Keine Noten zum Abspielen');
      showNotification('‚ùå Keine Noten zum Abspielen', 'Bitte setzen Sie Noten im Griffbild', 'warning');
      return;
    }
    
    // Verwende Tone.js f√ºr professionelle Audio-Wiedergabe
    try {
      // Tone.js starten falls n√∂tig
      if (Tone.context.state !== 'running') {
        Tone.start();
      }
      
      // Synthesizer erstellen
      const synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 0.8 }
      }).toDestination();
      
      // Akkord abspielen
      synth.triggerAttackRelease(notes, '2n');
      
      console.log(`üéµ Griffbild-Akkord abgespielt mit Tone.js:`, notes);
      
      // Zeige Akkord-Name
      const displayName = chordName || 'Akkord';
      showNotification(`üé∏ ${displayName} gespielt`, `${notes.length} Noten`, 'success');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Abspielen mit Tone.js:', error);
      // Fallback zu Web Audio API
      playGriffbildChordWithWebAudio();
    }
  }

  // Fallback-Funktion mit Web Audio API
  function playGriffbildChordWithWebAudio() {
    if (!griffbildModel) return;
    
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!window.audioCtx) {
      window.audioCtx = new AudioCtx();
    }
    const actx = window.audioCtx;
    
    // Berechne Noten
    const pitches = [];
    for (let s = 0; s < griffbildModel.strings; s++) {
      if (griffbildModel.mutes.has(s)) continue;
      if (griffbildModel.opens.has(s)) {
        pitches.push(griffbildModel.tuning[s]);
      } else {
        const lf = griffbildModel.dots.get(String(s));
        if (lf != null) {
          const absFret = griffbildModel.baseFret + lf - 1;
          pitches.push(griffbildModel.tuning[s] + absFret);
        }
      }
    }
    
    if (pitches.length === 0) return;
    
    // Spiele Akkord
    const t0 = actx.currentTime + 0.03;
    const spread = 0.03;
    pitches.sort((a, b) => a - b).forEach((midi, i) => {
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      const osc = actx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      
      const gain = actx.createGain();
      const t = t0 + i * spread;
      const volume = 0.3;
      
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(volume, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 1.5);
      
      osc.connect(gain).connect(actx.destination);
      osc.start(t);
      osc.stop(t + 1.6);
    });
    
    const chordName = griffbildModel.name || 'Akkord';
    showNotification(`üé∏ ${chordName} gespielt (Web Audio)`, `${pitches.length} Noten`, 'success');
  }

  // Hilfsfunktion: MIDI zu Note-Name konvertieren
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const octave = Math.floor(midi / 12) - 1;
    const noteIndex = midi % 12;
    return notes[noteIndex] + octave;
  }

  // Neue Funktion: Initialisiere Audio f√ºr bessere Qualit√§t
  function initializeGriffbildAudio() {
    if (!window.audioCtx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      window.audioCtx = new AudioCtx();
    }
    
    // AudioContext aktivieren bei User-Interaktion
    if (window.audioCtx.state === 'suspended') {
      window.audioCtx.resume().then(() => {
        console.log('‚úÖ AudioContext f√ºr Griffbild aktiviert');
      });
    }
    
    return window.audioCtx;
  }

  // Neue Funktion: Initialisiere Griffbild-Model sicher
  function initializeGriffbild() {
    if (griffbildModel) {
      console.log('‚úÖ Griffbild-Model bereits initialisiert');
      return griffbildModel;
    }
    
    console.log('üîÑ Initialisiere Griffbild-Model...');
    
    // Standard-Griffbild-Model erstellen
    griffbildModel = {
      strings: 6,
      tuning: [40, 45, 50, 55, 59, 64], // E-A-D-G-B-E (Standard)
      baseFret: 1,
      mutes: new Set(),
      opens: new Set(),
      dots: new Map(),
      name: 'Standard'
    };
    
    console.log('‚úÖ Griffbild-Model initialisiert:', griffbildModel);
    return griffbildModel;
  }

  // Neue Funktion: Spiele alle Akkorde aus der Live-Akkord-Sharing-Sequenz
  function playAllGriffbildChords() {
    if (!liveChordSystem || !liveChordSystem.currentChords || liveChordSystem.currentChords.length === 0) {
      console.log('‚ùå Keine Akkorde in der Live-Sequenz verf√ºgbar');
      showNotification('‚ùå Keine Akkorde verf√ºgbar', 'Bitte geben Sie zuerst Akkorde ein', 'warning');
      return;
    }
    
    // √úberpr√ºfe, ob griffbildModel verf√ºgbar ist
    if (!griffbildModel) {
      console.log('‚ùå Griffbild-Model nicht verf√ºgbar, initialisiere...');
      initializeGriffbild(); // Versuche zu initialisieren
      
      // Wenn immer noch nicht verf√ºgbar, verwende Standard-Griffbild
      if (!griffbildModel) {
        console.log('‚ùå Konnte Griffbild-Model nicht initialisieren, verwende Standard-Griffbild');
        griffbildModel = {
          strings: 6,
          tuning: [40, 45, 50, 55, 59, 64], // E-A-D-G-B-E
          baseFret: 1,
          mutes: new Set(),
          opens: new Set(),
          dots: new Map(),
          name: 'Standard'
        };
      }
    }
    
    console.log('üé∏ Spiele alle Akkorde aus der Live-Sequenz:', liveChordSystem.currentChords);
    
    // Verwende das vorhandene Tone.js System f√ºr professionelle Audio-Wiedergabe
    if (!window.Tone) {
      console.log('‚ùå Tone.js nicht verf√ºgbar, verwende Web Audio API');
      playAllGriffbildChordsWithWebAudio();
      return;
    }
    
    try {
      // Tone.js starten falls n√∂tig
      if (Tone.context.state !== 'running') {
        Tone.start();
      }
      
      // Synthesizer erstellen
      const synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 0.8 }
      }).toDestination();
      
      const chords = liveChordSystem.currentChords;
      const chordInterval = 1.5; // 1.5 Sekunden zwischen Akkorden
      
      // Spiele jeden Akkord nacheinander
      chords.forEach((chordName, index) => {
        // Aktualisiere Griffbild f√ºr diesen Akkord
        updateGriffbildFromChord(chordName);
        
        // √úberpr√ºfe erneut, ob griffbildModel verf√ºgbar ist
        if (!griffbildModel) {
          console.log('‚ùå Griffbild-Model nach updateGriffbildFromChord nicht verf√ºgbar');
          return;
        }
        
                 // Verwende die vorhandenen Akkord-Definitionen
         let notes = [];
         if (CHORDS[chordName]) {
           // Verwende die echten Akkord-Definitionen
           notes = CHORDS[chordName].map(note => note + '4'); // Oktave 4 hinzuf√ºgen
           console.log('üé∏ Verwende echte Akkord-Definition f√ºr:', chordName, notes);
         } else {
           // Fallback: Berechne Noten aus Griffbild
           console.log('üé∏ Berechne Noten aus Griffbild f√ºr:', chordName);
           for (let s = 0; s < griffbildModel.strings; s++) {
             if (griffbildModel.mutes.has(s)) continue;
             if (griffbildModel.opens.has(s)) {
               const midiNote = griffbildModel.tuning[s];
               const noteName = midiToNoteName(midiNote);
               notes.push(noteName);
             } else {
               const lf = griffbildModel.dots.get(String(s));
               if (lf != null) {
                 const absFret = griffbildModel.baseFret + lf - 1;
                 const midiNote = griffbildModel.tuning[s] + absFret;
                 const noteName = midiToNoteName(midiNote);
                 notes.push(noteName);
               }
             }
           }
         }
        
        if (notes.length > 0) {
          // Zeitplanung mit Tone.js Transport
          const time = Tone.now() + (index * chordInterval);
          synth.triggerAttackRelease(notes, '2n', time);
          
          console.log(`üéµ Akkord ${index + 1}/${chords.length}: ${chordName} - ${notes.length} Noten`);
        }
      });
      
      showNotification(`üé∏ Akkordfolge abgespielt mit Tone.js`, `${chords.length} Akkorde`, 'success');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Abspielen mit Tone.js:', error);
      // Fallback zu Web Audio API
      playAllGriffbildChordsWithWebAudio();
    }
  }

  // Fallback-Funktion mit Web Audio API
  function playAllGriffbildChordsWithWebAudio() {
    if (!liveChordSystem || !liveChordSystem.currentChords || liveChordSystem.currentChords.length === 0) return;
    
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!window.audioCtx) {
      window.audioCtx = new AudioCtx();
    }
    const actx = window.audioCtx;
    
    const chords = liveChordSystem.currentChords;
    const chordInterval = 1.5;
    
    chords.forEach((chordName, index) => {
      updateGriffbildFromChord(chordName);
      
      if (!griffbildModel) return;
      
      const pitches = [];
      for (let s = 0; s < griffbildModel.strings; s++) {
        if (griffbildModel.mutes.has(s)) continue;
        if (griffbildModel.opens.has(s)) {
          pitches.push(griffbildModel.tuning[s]);
        } else {
          const lf = griffbildModel.dots.get(String(s));
          if (lf != null) {
            const absFret = griffbildModel.baseFret + lf - 1;
            pitches.push(griffbildModel.tuning[s] + absFret);
          }
        }
      }
      
      if (pitches.length > 0) {
        const t0 = actx.currentTime + 0.1 + (index * chordInterval);
        const spread = 0.05;
        
        pitches.sort((a, b) => a - b).forEach((midi, i) => {
          const freq = 440 * Math.pow(2, (midi - 69) / 12);
          const osc = actx.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = freq;
          
          const gain = actx.createGain();
          const t = t0 + i * spread;
          const volume = 0.25;
          
          gain.gain.setValueAtTime(0.0001, t);
          gain.gain.exponentialRampToValueAtTime(volume, t + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, t + 1.2);
          
          osc.connect(gain).connect(actx.destination);
          osc.start(t);
          osc.stop(t + 1.3);
        });
      }
    });
    
    showNotification(`üé∏ Akkordfolge abgespielt (Web Audio)`, `${chords.length} Akkorde`, 'success');
  }

  // Neue Funktion: Griffbild basierend auf Akkord-Namen aktualisieren
  function updateGriffbildFromChord(chordName) {
    if (!griffbildModel || !chordName) return;
    
    console.log('üé∏ Aktualisiere Griffbild f√ºr Akkord:', chordName);
    
    // Griffbild zur√ºcksetzen
    griffbildModel.mutes.clear();
    griffbildModel.opens.clear();
    griffbildModel.dots.clear();
    
    // Akkord-Namen setzen
    griffbildModel.name = chordName;
    
    // Akkord parsen
    const parsedChord = parseChord(chordName);
    if (!parsedChord) {
      console.warn('‚ùå Konnte Akkord nicht parsen:', chordName);
      return;
    }
    
    // Standard-Akkord-Griffbilder basierend auf Akkord-Typ
    const root = parsedChord.root;
    const quality = parsedChord.quality;
    
    // Standard-Griffbilder f√ºr h√§ufige Akkorde
    if (root === 'C' && (quality === 'maj' || quality === '')) {
      // C-Dur: [x, 3, 2, 0, 1, 0] - E-A-D-G-B-E
      griffbildModel.mutes.add(0); // E-Saite ged√§mpft
      griffbildModel.dots.set("1", 3); // A-Saite 3. Bund
      griffbildModel.dots.set("2", 2); // D-Saite 2. Bund
      griffbildModel.opens.add(3); // G-Saite offen
      griffbildModel.dots.set("4", 1); // B-Saite 1. Bund
      griffbildModel.opens.add(5); // E-Saite offen
    } else if (root === 'G' && (quality === 'maj' || quality === '')) {
      // G-Dur: [3, 2, 0, 0, 0, 3] - E-A-D-G-B-E
      griffbildModel.dots.set("0", 3); // E-Saite 3. Bund
      griffbildModel.dots.set("1", 2); // A-Saite 2. Bund
      griffbildModel.opens.add(2); // D-Saite offen
      griffbildModel.opens.add(3); // G-Saite offen
      griffbildModel.opens.add(4); // B-Saite offen
      griffbildModel.dots.set("5", 3); // E-Saite 3. Bund
    } else if (root === 'D' && (quality === 'maj' || quality === '')) {
      // D-Dur: [x, x, 0, 2, 3, 2] - E-A-D-G-B-E
      griffbildModel.mutes.add(0); // E-Saite ged√§mpft
      griffbildModel.mutes.add(1); // A-Saite ged√§mpft
      griffbildModel.opens.add(2); // D-Saite offen
      griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
      griffbildModel.dots.set("4", 3); // B-Saite 3. Bund
      griffbildModel.dots.set("5", 2); // E-Saite 2. Bund
    } else if (root === 'A' && (quality === 'maj' || quality === '')) {
      // A-Dur: [x, 0, 2, 2, 2, 0] - E-A-D-G-B-E
      griffbildModel.mutes.add(0); // E-Saite ged√§mpft
      griffbildModel.opens.add(1); // A-Saite offen
      griffbildModel.dots.set("2", 2); // D-Saite 2. Bund
      griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
      griffbildModel.dots.set("4", 2); // B-Saite 2. Bund
      griffbildModel.opens.add(5); // E-Saite offen
    } else if (root === 'E' && (quality === 'maj' || quality === '')) {
      // E-Dur: [0, 2, 2, 1, 0, 0] - E-A-D-G-B-E
      griffbildModel.opens.add(0); // E-Saite offen
      griffbildModel.dots.set("1", 2); // A-Saite 2. Bund
      griffbildModel.dots.set("2", 2); // D-Saite 2. Bund
      griffbildModel.dots.set("3", 1); // G-Saite 1. Bund
      griffbildModel.opens.add(4); // B-Saite offen
      griffbildModel.opens.add(5); // E-Saite offen
    } else if (root === 'F' && (quality === 'maj' || quality === '')) {
      // F-Dur: [1, 3, 3, 2, 1, 1] - E-A-D-G-B-E (Barre-Akkord)
      griffbildModel.dots.set("0", 1); // E-Saite 1. Bund
      griffbildModel.dots.set("1", 3); // A-Saite 3. Bund
      griffbildModel.dots.set("2", 3); // D-Saite 3. Bund
      griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
      griffbildModel.dots.set("4", 1); // B-Saite 1. Bund
      griffbildModel.dots.set("5", 1); // E-Saite 1. Bund
    } else if (root === 'Am' && (quality === 'min' || quality === 'm')) {
      // Am: [x, 0, 2, 2, 1, 0] - E-A-D-G-B-E
      griffbildModel.mutes.add(0); // E-Saite ged√§mpft
      griffbildModel.opens.add(1); // A-Saite offen
      griffbildModel.dots.set("2", 2); // D-Saite 2. Bund
      griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
      griffbildModel.dots.set("4", 1); // B-Saite 1. Bund
      griffbildModel.opens.add(5); // E-Saite offen
    } else if (root === 'Dm' && (quality === 'min' || quality === 'm')) {
      // Dm: [x, x, 0, 2, 3, 1] - E-A-D-G-B-E
      griffbildModel.mutes.add(0); // E-Saite ged√§mpft
      griffbildModel.mutes.add(1); // A-Saite ged√§mpft
      griffbildModel.opens.add(2); // D-Saite offen
      griffbildModel.dots.set("3", 2); // G-Saite 2. Bund
      griffbildModel.dots.set("4", 3); // B-Saite 3. Bund
      griffbildModel.dots.set("5", 1); // E-Saite 1. Bund
    } else if (root === 'Em' && (quality === 'min' || quality === 'm')) {
      // Em: [0, 2, 2, 0, 0, 0] - E-A-D-G-B-E
      griffbildModel.opens.add(0); // E-Saite offen
      griffbildModel.dots.set("1", 2); // A-Saite 2. Bund
      griffbildModel.dots.set("2", 2); // D-Saite 2. Bund
      griffbildModel.opens.add(3); // G-Saite offen
      griffbildModel.opens.add(4); // B-Saite offen
      griffbildModel.opens.add(5); // E-Saite offen
    } else {
      // Fallback: Standard-Griffbild f√ºr unbekannte Akkorde
      console.log('‚ö†Ô∏è Unbekannter Akkord, verwende Standard-Griffbild');
      griffbildModel.opens.add(0); // E-Saite offen
      griffbildModel.opens.add(1); // A-Saite offen
      griffbildModel.opens.add(2); // D-Saite offen
      griffbildModel.opens.add(3); // G-Saite offen
      griffbildModel.opens.add(4); // B-Saite offen
      griffbildModel.opens.add(5); // E-Saite offen
    }
    
    // Akkord-Namen speichern
    griffbildModel.name = chordName;
    
    // Griffbild aktualisieren
    updateGriffbildDisplay();
    updateGriffbildNotes();
    updateGriffbildChordStatus();
    
    console.log('‚úÖ Griffbild aktualisiert f√ºr:', chordName);
  }

  // Neue Funktion: Zum n√§chsten Akkord navigieren
  function nextGriffbildChord() {
    if (!liveChordSystem || !liveChordSystem.currentChords || liveChordSystem.currentChords.length === 0) {
      console.log('‚ùå Keine Akkorde verf√ºgbar');
      return;
    }
    
    liveChordSystem.currentChordIndex = (liveChordSystem.currentChordIndex + 1) % liveChordSystem.currentChords.length;
    const currentChord = liveChordSystem.currentChords[liveChordSystem.currentChordIndex];
    
    console.log('üé∏ Navigiere zu Akkord:', currentChord, 'Index:', liveChordSystem.currentChordIndex);
    updateGriffbildFromChord(currentChord);
    updateGriffbildChordStatus();
  }

  // Neue Funktion: Zum vorherigen Akkord navigieren
  function previousGriffbildChord() {
    if (!liveChordSystem || !liveChordSystem.currentChords || liveChordSystem.currentChords.length === 0) {
      console.log('‚ùå Keine Akkorde verf√ºgbar');
      return;
    }
    
    liveChordSystem.currentChordIndex = (liveChordSystem.currentChordIndex - 1 + liveChordSystem.currentChords.length) % liveChordSystem.currentChords.length;
    const currentChord = liveChordSystem.currentChords[liveChordSystem.currentChordIndex];
    
    console.log('üé∏ Navigiere zu Akkord:', currentChord, 'Index:', liveChordSystem.currentChordIndex);
    updateGriffbildFromChord(currentChord);
    updateGriffbildChordStatus();
  }

  // Neue Funktion: Akkord-Status aktualisieren
  function updateGriffbildChordStatus() {
    const statusElement = document.getElementById('griffbildChordStatus');
    if (!statusElement) return;
    
    if (!liveChordSystem || !liveChordSystem.currentChords || liveChordSystem.currentChords.length === 0) {
      statusElement.textContent = 'Keine Akkorde geladen';
      return;
    }
    
    const currentChord = liveChordSystem.currentChords[liveChordSystem.currentChordIndex];
    const totalChords = liveChordSystem.currentChords.length;
    const currentIndex = liveChordSystem.currentChordIndex + 1;
    
    statusElement.textContent = `${currentChord} (${currentIndex}/${totalChords})`;
  }

  // Removed testUI function - only for development

  // ---------- Export-Funktionen ----------
  function exportToASCII() {
    const chords = window.currentChords;
    const voicings = window.currentVoicings;
    
    if (!chords || !voicings) {
      status.textContent = 'Keine Akkorde zum Exportieren verf√ºgbar';
      return;
    }
    
    const tab = asciiTab(chords, voicings);
    const blob = new Blob([tab], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gitarren-tab.txt';
    a.click();
    
    URL.revokeObjectURL(url);
    status.textContent = 'ASCII-TAB exportiert';
  }
  
  function exportToPDF() {
    const chords = window.currentChords;
    const voicings = window.currentVoicings;
    
    if (!chords || !voicings) {
      status.textContent = 'Keine Akkorde zum Exportieren verf√ºgbar';
      return;
    }
    
    try {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Titel
      doc.setFontSize(20);
      doc.text('Gitarren-Akkordfolge', 20, 20);
      
      // Akkorde
      doc.setFontSize(14);
      const chordText = chords.map(c => 
        c.root + (c.quality === "maj" ? "" : c.quality === "min" ? "m" : c.quality) + (c.bass ? "/" + c.bass : "")
      ).join(" | ");
      doc.text(chordText, 20, 40);
      
      // ASCII-TAB
      doc.setFontSize(10);
      const tab = asciiTab(chords, voicings);
      const tabLines = tab.split('\n');
      let y = 60;
      
      tabLines.forEach(line => {
        if (y > 280) {
          doc.addPage();
          y = 20;
        }
        doc.text(line, 20, y);
        y += 5;
      });
      
      doc.save('gitarren-akkorde.pdf');
      status.textContent = 'PDF exportiert';
      
    } catch (e) {
      console.error('Fehler beim PDF-Export:', e);
      status.textContent = 'PDF-Export fehlgeschlagen';
    }
  }
  
  // ---------- Speichern/Laden ----------
  function saveProgression() {
    const input = inp.value.trim();
    if (!input) {
      status.textContent = 'Keine Akkordfolge zum Speichern';
      return;
    }
    
    try {
      const saved = JSON.parse(localStorage.getItem('gitarreProgressions') || '[]');
      const name = prompt('Name f√ºr diese Akkordfolge:');
      
      if (name) {
        saved.push({ name, progression: input, timestamp: Date.now() });
        localStorage.setItem('gitarreProgressions', JSON.stringify(saved));
        status.textContent = 'Akkordfolge gespeichert';
      }
    } catch (e) {
      console.error('Fehler beim Speichern:', e);
      status.textContent = 'Fehler beim Speichern';
    }
  }
  
  function loadSavedProgressions() {
    try {
      const saved = JSON.parse(localStorage.getItem('gitarreProgressions') || '[]');
      
      if (saved.length === 0) {
        status.textContent = 'Keine gespeicherten Akkordfolgen';
        return;
      }
      
      const names = saved.map(p => p.name);
      const selected = prompt('W√§hle eine Akkordfolge:\n' + names.join('\n'));
      
      if (selected && names.includes(selected)) {
        const progression = saved.find(p => p.name === selected);
        inp.value = progression.progression;
        compute();
        status.textContent = 'Akkordfolge geladen';
      }
    } catch (e) {
      console.error('Fehler beim Laden:', e);
      status.textContent = 'Fehler beim Laden';
    }
  }
  
  function loadProgression(progression) {
    inp.value = progression;
    compute();
    status.textContent = 'Akkordfolge geladen';
  }
  
  // ---------- Event-Handler ----------
  let computeTimeout;
  [inp, orig, target, semi, capo, tuningSel, pattern, lefty, easy].forEach(el =>
    el.addEventListener("input", () => {
      clearTimeout(computeTimeout);
      computeTimeout = setTimeout(compute, 120);
    })
  );
  
  // Live-BPM-√Ñnderungen f√ºr Metronom und Playback
  tempo.addEventListener("input", () => {
    const bpm = parseInt(tempo.value, 10);
    tempoLbl.textContent = tempo.value;
    if (window.Tone && Tone.Transport && Tone.Transport.bpm && typeof Tone.Transport.bpm.rampTo === 'function') {
      // Smooth statt Hart-Sprung
      Tone.Transport.bpm.rampTo(bpm, 0.05);
    }
  });
  
  playBtn.addEventListener('click', startPlayback);
  stopBtn.addEventListener('click', stopPlayback);
  metronomeBtn.addEventListener('click', startMetronome);
  exportBtn.addEventListener('click', exportToASCII);
  pdfExportBtn.addEventListener('click', exportToPDF);
  saveProg.addEventListener('click', saveProgression);
  loadProg.addEventListener('click', loadSavedProgressions);
  
  // ---------- VexFlow-Initialisierung ----------
  function checkVexFlowAvailability() {
    if (typeof VexFlow !== 'undefined') {
      // Pr√ºfe ob es sich um Mock VexFlow handelt
      if (VexFlow.Renderer && VexFlow.Renderer.name === 'MockRenderer') {
        console.log('Mock VexFlow verf√ºgbar - Notation wird vereinfacht dargestellt');
        return true;
      }
      console.log('VexFlow erfolgreich geladen (global VexFlow)');
      return true;
    } else if (typeof Vex !== 'undefined') {
      console.log('Vex (√§ltere Version) geladen (global Vex)');
      return true;
    } else {
      // Pr√ºfe ob ein VexFlow-Script geladen wird
      const scripts = document.querySelectorAll('script[src*="vexflow"]');
      if (scripts.length > 0) {
        console.log('VexFlow-Script wird geladen, warte...');
        return false; // Warte noch
      }
      
      console.warn('VexFlow konnte nicht geladen werden - Notation wird nicht verf√ºgbar sein');
      return false;
    }
  }
  
  // Vereinfachte App-Initialisierung (wird jetzt von VexFlow-ESM-Import gesteuert)
  function initializeApp() {
    if (checkVexFlowAvailability()) {
      console.log('VexFlow verf√ºgbar, starte Anwendung');
      // Update Status f√ºr VexFlow
      if (typeof VexFlow !== 'undefined' && VexFlow.Renderer && VexFlow.Renderer.name === 'MockRenderer') {
        status.textContent = 'Anwendung l√§uft - VexFlow im Fallback-Modus';
      } else {
        status.textContent = 'Anwendung l√§uft - VexFlow verf√ºgbar';
      }
      compute();
      initializeTabs();
      initializeProjectManagement();
      
      // DAW-Status nach Initialisierung √ºberpr√ºfen
      setTimeout(() => {
        checkAndRepairDAW();
        console.log('Alle Tools sind jetzt verf√ºgbar und funktionsf√§hig');
      }, 1500);
    } else {
      console.log('VexFlow nicht verf√ºgbar - sollte nicht passieren mit ESM-Import');
      status.textContent = 'Fehler: VexFlow konnte nicht geladen werden';
    }
  }
  
  // ---------- Tab-Management ----------
  function initializeTabs() {
    const tabs = document.querySelectorAll('.nav-tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        // Alle Tabs deaktivieren
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        
        // Ziel-Tab aktivieren
        tab.classList.add('active');
        const targetContent = document.getElementById(`${targetTab}-tab`);
        if (targetContent) {
          targetContent.classList.add('active');
        }
        
                 // Tab-spezifische Initialisierung
         switch(targetTab) {
           case 'piano':
             if (typeof initPiano === 'function') {
               setTimeout(initPiano, 100);
             }
             break;
           case 'rhythm':
             if (typeof initDrumMachine === 'function') {
               setTimeout(initDrumMachine, 100);
             }
             break;
           case 'production':
             if (typeof initVirtualMixer === 'function') {
               setTimeout(initVirtualMixer, 100);
             }
             break;
           case 'daw':
             if (typeof openDAW === 'function') {
               setTimeout(() => {
                 if (window.Tone) {
                   dawActive = true;
                   console.log('DAW-Tab aktiviert - Alle Tools sind verf√ºgbar');
                   
                   // DAW-spezifische Initialisierung
                   if (currentAudioBuffer) {
                     displayWaveform(currentAudioBuffer);
                     showAudioInfo(currentAudioBuffer);
                   }
                   
                   // Waveframe-Editor vorbereiten
                   if (document.getElementById('waveframeEditor')) {
                     console.log('Waveframe-Editor bereit');
                   }
                   
                   // Multi-Track-Editor vorbereiten
                   if (document.getElementById('multiTrackEditor')) {
                     console.log('Multi-Track-Editor bereit');
                   }
                 }
               }, 100);
             }
             break;
           case 'live':
             if (typeof createSetlist === 'function') {
               setTimeout(() => {
                 console.log('Live Performance Tab aktiviert');
               }, 100);
             }
             break;
         }
      });
    });
  }
  
  // ---------- Projekt-Management ----------
  function initializeProjectManagement() {
    loadProjects();
  }
  
  // DAW-Status √ºberpr√ºfen und reparieren
  function checkAndRepairDAW() {
    console.log('√úberpr√ºfe DAW-Status...');
    
    if (!dawActive) {
      console.log('DAW nicht aktiv - aktiviere...');
      dawActive = true;
    }
    
    if (!currentAudioBuffer) {
      console.log('Kein Audio-Buffer vorhanden - Status: OK (noch keine Datei geladen)');
    } else {
      console.log('Audio-Buffer verf√ºgbar:', currentAudioBuffer.duration.toFixed(2) + 's');
    }
    
    // Alle DAW-Elemente √ºberpr√ºfen
    const dawElements = [
      'waveformEditor',
      'waveframeEditor', 
      'multiTrackEditor',
      'projectManager'
    ];
    
    dawElements.forEach(elementId => {
      const element = document.getElementById(elementId);
      if (element) {
        console.log(`‚úÖ ${elementId} gefunden`);
      } else {
        console.warn(`‚ùå ${elementId} nicht gefunden`);
      }
    });
    
    // Tone.js Status √ºberpr√ºfen
    if (window.Tone) {
      console.log('‚úÖ Tone.js verf√ºgbar');
    } else {
      console.warn('‚ùå Tone.js nicht verf√ºgbar');
    }
    
    console.log('DAW-Status-√úberpr√ºfung abgeschlossen');
    return dawActive;
  }
  
  function createProject() {
    const name = document.getElementById('projectName').value.trim();
    const description = document.getElementById('projectDescription').value.trim();
    
    if (!name) {
      showNotification('‚ö†Ô∏è Projektname erforderlich', 'Bitte geben Sie einen Projektnamen ein', 'warning');
      return;
    }
    
    const project = {
      id: Date.now(),
      name: name,
      description: description,
      chords: inp.value,
      voicings: window.currentVoicings || [],
      timestamp: new Date().toISOString()
    };
    
    saveProject(project);
    document.getElementById('projectName').value = '';
    document.getElementById('projectDescription').value = '';
    loadProjects();
  }
  
  function saveCurrentProject() {
    const name = prompt('Projektname:');
    if (!name) return;
    
    const project = {
      id: Date.now(),
      name: name,
      description: 'Aktueller Stand',
      chords: inp.value,
      voicings: window.currentVoicings || [],
      timestamp: new Date().toISOString()
    };
    
    saveProject(project);
    loadProjects();
  }
  
  function saveProject(project) {
    try {
      const projects = JSON.parse(localStorage.getItem('gitarreProjects') || '[]');
      projects.push(project);
      localStorage.setItem('gitarreProjects', JSON.stringify(projects));
      showNotification('‚úÖ Projekt gespeichert', `Projekt "${project.name}" erfolgreich gespeichert!`, 'success');
    } catch (e) {
      console.error('Fehler beim Speichern:', e);
      showNotification('‚ùå Fehler beim Speichern', 'Fehler beim Speichern des Projekts', 'error');
    }
  }
  
  function loadProjects() {
    try {
      const projects = JSON.parse(localStorage.getItem('gitarreProjects') || '[]');
      const projectList = document.getElementById('projectList');
      
      if (projects.length === 0) {
        projectList.innerHTML = '<p class="muted">Keine Projekte gespeichert</p>';
        return;
      }
      
      projectList.innerHTML = projects.map(project => `
        <div class="project-item" onclick="loadProject(${project.id})">
          <strong>${project.name}</strong><br>
          <small class="muted">${project.description}</small><br>
          <small class="muted">${new Date(project.timestamp).toLocaleDateString()}</small>
        </div>
      `).join('');
    } catch (e) {
      console.error('Fehler beim Laden der Projekte:', e);
    }
  }
  
  function loadProject(projectId) {
    try {
      const projects = JSON.parse(localStorage.getItem('gitarreProjects') || '[]');
      const project = projects.find(p => p.id === projectId);
      
      if (project) {
        inp.value = project.chords;
        window.currentVoicings = project.voicings;
        compute();
        
        // Zur√ºck zum Gitarren-Tab
        document.querySelector('[data-tab="guitar"]').click();
        
        showNotification('‚úÖ Projekt geladen', `Projekt "${project.name}" erfolgreich geladen!`, 'success');
      }
    } catch (e) {
      console.error('Fehler beim Laden des Projekts:', e);
      showNotification('‚ùå Fehler beim Laden', 'Fehler beim Laden des Projekts', 'error');
    }
  }
  
  // ---------- Noten-Editor ----------
  function parseNotes() {
    const notesInput = document.getElementById('notesInput').value;
    const liveDisplay = document.getElementById('liveNotesDisplay');
    
    if (!notesInput.trim()) {
      liveDisplay.innerHTML = '<p class="muted">Keine Noten eingegeben</p>';
      return;
    }
    
    // Einfache Noten-Parsing (kann erweitert werden)
    const notes = notesInput.split(/\s+/).filter(n => n.trim());
    
    liveDisplay.innerHTML = `
      <h4>Geparste Noten:</h4>
      <div style="font-size: 18px; line-height: 1.5;">
        ${notes.map(note => `<span class="note" style="display: inline-block; margin: 5px; padding: 10px; background: #007acc; color: white; border-radius: 8px;">${note}</span>`).join('')}
      </div>
    `;
  }
  
  function playNotes() {
    const notesInput = document.getElementById('notesInput').value;
    if (!notesInput.trim()) {
      showNotification('‚ö†Ô∏è Noten erforderlich', 'Bitte geben Sie Noten ein', 'warning');
      return;
    }
    
    // Einfache Noten-Wiedergabe (kann erweitert werden)
    showNotification('üéµ Noten-Wiedergabe', 'Noten-Wiedergabe wird implementiert...', 'info');
  }
  
  // ---------- Multimedia-Player ----------
  let currentMediaElement = null;
  let mediaRecording = null;
  let isMediaRecording = false;
  
  function loadMedia() {
    const fileInput = document.getElementById('mediaFile');
    const file = fileInput.files[0];
    
    if (!file) {
      showNotification('‚ö†Ô∏è Datei erforderlich', 'Bitte w√§hlen Sie eine Audio- oder Videodatei aus.', 'warning');
      return;
    }
    
    const mediaPlayer = document.getElementById('mediaPlayer');
    const url = URL.createObjectURL(file);
    
    if (file.type.startsWith('audio/')) {
      const audio = document.createElement('audio');
      audio.src = url;
      audio.controls = true;
      audio.id = 'currentMedia';
      mediaPlayer.innerHTML = '';
      mediaPlayer.appendChild(audio);
      currentMediaElement = audio;
      
      // Event-Listener f√ºr Zeit-Updates
      audio.addEventListener('timeupdate', updateMediaTime);
      audio.addEventListener('loadedmetadata', updateMediaTime);
      
    } else if (file.type.startsWith('video/')) {
      const video = document.createElement('video');
      video.src = url;
      video.controls = true;
      video.id = 'currentMedia';
      mediaPlayer.innerHTML = '';
      mediaPlayer.appendChild(video);
      currentMediaElement = video;
      
      // Event-Listener f√ºr Zeit-Updates
      video.addEventListener('timeupdate', updateMediaTime);
      video.addEventListener('loadedmetadata', updateMediaTime);
    }
    
    console.log('‚úÖ Media geladen:', file.name);
  }
  
  function playMedia() {
    if (currentMediaElement) {
      currentMediaElement.play();
      console.log('‚úÖ Media abgespielt');
    }
  }
  
  function pauseMedia() {
    if (currentMediaElement) {
      currentMediaElement.pause();
      console.log('‚úÖ Media pausiert');
    }
  }
  
  function stopMedia() {
    if (currentMediaElement) {
      currentMediaElement.pause();
      currentMediaElement.currentTime = 0;
      console.log('‚úÖ Media gestoppt');
    }
  }
  
  function setMediaVolume(value) {
    if (currentMediaElement) {
      currentMediaElement.volume = value;
      console.log('‚úÖ Media-Lautst√§rke:', value);
    }
  }
  
  function updateMediaTime() {
    if (currentMediaElement) {
      const current = formatTime(currentMediaElement.currentTime);
      const total = formatTime(currentMediaElement.duration);
      const timeDisplay = document.getElementById('mediaTime');
      if (timeDisplay) {
        timeDisplay.textContent = `${current} / ${total}`;
      }
    }
  }
  
  function startMediaRecording() {
    if (isMediaRecording) {
      console.warn('Aufnahme l√§uft bereits');
      return;
    }
    
    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
      .then(stream => {
        mediaRecording = new MediaRecorder(stream);
        const chunks = [];
        
        mediaRecording.ondataavailable = function(e) {
          chunks.push(e.data);
        };
        
        mediaRecording.onstop = function() {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          
          // Aufnahme in Player laden
          const video = document.createElement('video');
          video.src = url;
          video.controls = true;
          video.id = 'currentMedia';
          
          const mediaPlayer = document.getElementById('mediaPlayer');
          mediaPlayer.innerHTML = '';
          mediaPlayer.appendChild(video);
          currentMediaElement = video;
          
          console.log('‚úÖ Aufnahme abgeschlossen');
        };
        
        mediaRecording.start();
        isMediaRecording = true;
        console.log('‚úÖ Aufnahme gestartet');
        
      })
      .catch(error => {
        console.error('‚ùå Fehler beim Starten der Aufnahme:', error);
        alert('Fehler beim Starten der Aufnahme: ' + error.message);
      });
  }
  
  function stopMediaRecording() {
    if (mediaRecording && isMediaRecording) {
      mediaRecording.stop();
      mediaRecording.stream.getTracks().forEach(track => track.stop());
      isMediaRecording = false;
      console.log('‚úÖ Aufnahme gestoppt');
    }
  }
  
  function exportMedia() {
    if (currentMediaElement) {
      const a = document.createElement('a');
      a.href = currentMediaElement.src;
      a.download = 'exported-media.webm';
      a.click();
      console.log('‚úÖ Media exportiert');
    }
  }
  
  function syncWithChords() {
    if (!currentMediaElement || !window.currentChords) {
      alert('Bitte laden Sie zuerst Media und Akkorde.');
      return;
    }
    
    // Synchronisation mit Akkordfolge
    const chords = window.currentChords;
    const mediaDuration = currentMediaElement.duration;
    const chordInterval = mediaDuration / chords.length;
    
    console.log('üéØ Synchronisiere Media mit Akkorden...');
    console.log('Media-Dauer:', mediaDuration, 'Akkorde:', chords.length);
    
    // Event-Listener f√ºr Media-Zeit-Updates
    currentMediaElement.addEventListener('timeupdate', () => {
      const currentTime = currentMediaElement.currentTime;
      const chordIndex = Math.floor(currentTime / chordInterval);
      
      if (chordIndex < chords.length) {
        const currentChord = chords[chordIndex];
        console.log('üéµ Aktueller Akkord:', currentChord.full, 'bei', currentTime.toFixed(2), 's');
        
        // Akkord-Highlighting in der UI
        highlightCurrentChord(chordIndex);
      }
    });
    
    console.log('‚úÖ Media-Akkord-Synchronisation aktiviert');
  }
  
  function highlightCurrentChord(index) {
    // Akkord in der UI hervorheben
    const chordElements = document.querySelectorAll('.chord-display');
    chordElements.forEach((el, i) => {
      if (i === index) {
        el.style.backgroundColor = '#1db954';
        el.style.color = 'white';
      } else {
        el.style.backgroundColor = '';
        el.style.color = '';
      }
    });
  }
  
  // Neue UI-Update-Funktionen f√ºr stabile Akkord-Wiedergabe
  function updateCurrentChordDisplay(chordName, index) {
    // Live-Playback-Animation aktualisieren
    const animationContainer = document.getElementById('playbackAnimation');
    if (animationContainer) {
      const chordText = animationContainer.querySelector('.current-chord');
      if (chordText) {
        chordText.textContent = chordName;
      }
      
      const positionText = animationContainer.querySelector('.position');
      if (positionText) {
        positionText.textContent = `${index + 1} / ${window.currentChords ? window.currentChords.length : '?'}`;
      }
      
      // Progress-Bar aktualisieren
      const progressBar = animationContainer.querySelector('.progress-bar');
      if (progressBar) {
        const progress = ((index + 1) / (window.currentChords ? window.currentChords.length : 1)) * 100;
        progressBar.style.width = `${progress}%`;
      }
    }
    
    // Fullscreen-Animation aktualisieren
    if (window.fullscreenCurrentIndex !== undefined) {
      window.fullscreenCurrentIndex = index;
      updateFullscreenAnimation();
    }
    
    // Akkord in der UI hervorheben
    highlightCurrentChord(index);
  }
  
  function updatePlaybackProgress(currentIndex, totalChords) {
    // Status-Update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = `Spielt Akkord ${currentIndex + 1} von ${totalChords}...`;
    }
    
    // Progress-Update f√ºr alle Progress-Bars
    const progressBars = document.querySelectorAll('.progress-bar');
    progressBars.forEach(bar => {
      const progress = ((currentIndex + 1) / totalChords) * 100;
      bar.style.width = `${progress}%`;
    });
  }
  
  // Media-Bereich Toggle-Funktionen
  function toggleTelMedia() {
    console.log('üéµ Toggle TEL Media Button geklickt');
    const telEmbed = document.getElementById('telMediaEmbed');
    const mediaPlayer = document.querySelector('.media-player');
    const mediaGrid = document.querySelector('.media-grid');
    
    console.log('Tel Embed gefunden:', !!telEmbed);
    console.log('Media Player gefunden:', !!mediaPlayer);
    console.log('Media Grid gefunden:', !!mediaGrid);
    
    if (telEmbed) {
      telEmbed.style.display = 'block';
      console.log('‚úÖ TEL & Gentlyoverdone Media-Bereich angezeigt');
    }
    
    if (mediaPlayer) {
      mediaPlayer.style.display = 'none';
      console.log('‚úÖ Media Player ausgeblendet');
    }
    
    if (mediaGrid) {
      mediaGrid.style.display = 'none';
      console.log('‚úÖ Media Grid ausgeblendet');
    }
  }
  
  function toggleMediaPlayer() {
    console.log('üé¨ Toggle Media Player Button geklickt');
    const telEmbed = document.getElementById('telMediaEmbed');
    const mediaPlayer = document.querySelector('.media-player');
    const mediaGrid = document.querySelector('.media-grid');
    
    console.log('Tel Embed gefunden:', !!telEmbed);
    console.log('Media Player gefunden:', !!mediaPlayer);
    console.log('Media Grid gefunden:', !!mediaGrid);
    
    if (telEmbed) {
      telEmbed.style.display = 'none';
      console.log('‚úÖ TEL Media ausgeblendet');
    }
    
    if (mediaPlayer) {
      mediaPlayer.style.display = 'block';
      console.log('‚úÖ Media Player angezeigt');
    }
    
    if (mediaGrid) {
      mediaGrid.style.display = 'block';
      console.log('‚úÖ Media Grid angezeigt');
    }
  }
  
  // Test-Funktion f√ºr Debugging
  
  // Notification-System f√ºr echte Software-Funktionen
  function showNotification(title, message, type = 'info') {
    // Notification-Container erstellen falls nicht vorhanden
    let notificationContainer = document.getElementById('notificationContainer');
    if (!notificationContainer) {
      notificationContainer = document.createElement('div');
      notificationContainer.id = 'notificationContainer';
      notificationContainer.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        max-width: 400px;
      `;
      document.body.appendChild(notificationContainer);
    }
    
    // Notification-Element erstellen
    const notification = document.createElement('div');
    notification.style.cssText = `
      background: ${type === 'error' ? '#ff4444' : type === 'warning' ? '#ffaa00' : type === 'success' ? '#44ff44' : '#4444ff'};
      color: white;
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideInRight 0.3s ease-out;
      font-family: 'Segoe UI', sans-serif;
    `;
    
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
      <div style="font-size: 14px;">${message}</div>
      <button onclick="this.parentElement.remove()" style="
        position: absolute;
        top: 5px;
        right: 10px;
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
      ">√ó</button>
    `;
    
    notificationContainer.appendChild(notification);
    
    // Auto-remove nach 5 Sekunden
    setTimeout(() => {
      if (notification.parentElement) {
        notification.remove();
      }
    }, 5000);
  }

  // Funktion global verf√ºgbar machen
  window.showNotification = showNotification;
  
  // Media-Bereich Initialisierung
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      console.log('üéµ Initialisiere Media-Bereich...');
      
      const telEmbed = document.getElementById('telMediaEmbed');
      const mediaPlayer = document.querySelector('.media-player');
      const mediaGrid = document.querySelector('.media-grid');
      
      console.log('Tel Embed gefunden:', !!telEmbed);
      console.log('Media Player gefunden:', !!mediaPlayer);
      console.log('Media Grid gefunden:', !!mediaGrid);
      
      // Standardm√§√üig TEL Media anzeigen
      if (telEmbed) {
        telEmbed.style.display = 'block';
        console.log('‚úÖ TEL & Gentlyoverdone Media-Bereich initialisiert');
      }
      
      if (mediaPlayer) {
        mediaPlayer.style.display = 'none';
        console.log('‚úÖ Media Player ausgeblendet');
      }
      
      if (mediaGrid) {
        mediaGrid.style.display = 'none';
        console.log('‚úÖ Media Grid ausgeblendet');
      }
      
      // Event-Listener f√ºr Buttons hinzuf√ºgen
      const telButton = document.querySelector('button[onclick="toggleTelMedia()"]');
      const mediaButton = document.querySelector('button[onclick="toggleMediaPlayer()"]');
      
      if (telButton) {
        telButton.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('üéµ TEL Media Button geklickt (Event Listener)');
          toggleTelMedia();
        });
      }
      
      if (mediaButton) {
        mediaButton.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('üé¨ Media Player Button geklickt (Event Listener)');
          toggleMediaPlayer();
        });
      }
      
      console.log('‚úÖ Media-Bereich vollst√§ndig initialisiert');
    }, 1000);
  });
  // Removed testChordParsing function - only for development

  // ========== KLANG-TOOLS & MUSIKBILDUNG ==========
  
  // ---------- Klavier-Funktionen ----------
  let pianoSynth = null;
  let currentPianoOctave = 4;
  
  function initPiano() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    try {
      pianoSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.02, decay: 0.2, sustain: 0.3, release: 0.6 }
      }).toDestination();
      
      const pianoKeyboard = document.getElementById('pianoKeyboard');
      pianoKeyboard.innerHTML = createPianoKeyboard();
      
      console.log('Klavier erfolgreich initialisiert');
    } catch (e) {
      console.error('Fehler beim Initialisieren des Klaviers:', e);
    }
  }
  
  function createPianoKeyboard() {
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const blackKeys = ['C#', 'D#', 'F#', 'G#', 'A#'];
    
    let html = '<div style="display:flex; justify-content:center; position:relative; height:120px;">';
    
    // Wei√üe Tasten
    whiteKeys.forEach((note, index) => {
      const isBlackKey = blackKeys.includes(note);
      if (!isBlackKey) {
        html += `<div onclick="playPianoNote('${note}${currentPianoOctave}')" 
                      style="width:40px; height:120px; background:white; border:1px solid #ccc; 
                             margin:0 1px; cursor:pointer; display:flex; align-items:flex-end; 
                             justify-content:center; padding-bottom:10px; font-weight:bold; color:#333;
                             transition:background 0.1s ease;"
                      onmouseover="this.style.background='#f0f0f0'"
                      onmouseout="this.style.background='white'">${note}</div>`;
      }
    });
    
    // Schwarze Tasten (√ºber den wei√üen Tasten positioniert)
    blackKeys.forEach(note => {
      const whiteKeyIndex = whiteKeys.indexOf(note.replace('#', ''));
      const left = whiteKeyIndex * 40 + 30; // Position √ºber der wei√üen Taste
      html += `<div onclick="playPianoNote('${note}${currentPianoOctave}')" 
                    style="position:absolute; left:${left}px; width:24px; height:80px; 
                           background:#333; color:white; border:1px solid #000; cursor:pointer;
                           display:flex; align-items:flex-end; justify-content:center; 
                           padding-bottom:10px; font-weight:bold; z-index:10;
                           transition:background 0.1s ease;"
                    onmouseover="this.style.background='#555'"
                    onmouseout="this.style.background='#333'">${note.replace('#', '‚ôØ')}</div>`;
    });
    
    html += '</div>';
    return html;
  }
  
  function playPianoNote(note) {
    if (pianoSynth) {
      pianoSynth.triggerAttackRelease(note, '8n');
    }
  }
  
  function playPianoChord() {
    if (!pianoSynth) {
      alert('Bitte initialisieren Sie zuerst das Klavier');
      return;
    }
    
    const chord = ['C4', 'E4', 'G4']; // C-Dur Akkord
    chord.forEach((note, index) => {
      setTimeout(() => {
        pianoSynth.triggerAttackRelease(note, '2n');
      }, index * 100);
    });
  }
  
  function togglePianoOctaves() {
    currentPianoOctave = currentPianoOctave === 4 ? 5 : 4;
    if (pianoSynth) {
      const pianoKeyboard = document.getElementById('pianoKeyboard');
      pianoKeyboard.innerHTML = createPianoKeyboard();
    }
  }
  
  function startPianoExercise(type) {
    const exerciseDiv = document.getElementById('pianoExercise');
    
    switch(type) {
      case 'scales':
        exerciseDiv.innerHTML = `
          <h4>üéµ Tonleiter-√úbung</h4>
          <p>Spielen Sie die C-Dur Tonleiter: C D E F G A B C</p>
          <div class="controls">
            <button onclick="playPianoScale()" class="btn">üéº Abspielen</button>
            <button onclick="checkPianoScale()" class="btn">‚úÖ Pr√ºfen</button>
          </div>
        `;
        break;
      case 'chords':
        exerciseDiv.innerHTML = `
          <h4>üéº Akkord-√úbung</h4>
          <p>Spielen Sie diese Akkorde: C, F, G, Am</p>
          <div class="controls">
            <button onclick="playPianoChords()" class="btn">üéµ Abspielen</button>
            <button onclick="checkPianoChords()" class="btn">‚úÖ Pr√ºfen</button>
          </div>
        `;
        break;
      case 'sight':
        exerciseDiv.innerHTML = `
          <h4>üëÅÔ∏è Blattspiel-√úbung</h4>
          <p>Lesen Sie diese Noten: C4, E4, G4, A4</p>
          <div class="controls">
            <button onclick="showPianoNotes()" class="btn">üéº Noten anzeigen</button>
            <button onclick="playPianoNotes()" class="btn">üéµ Abspielen</button>
          </div>
        `;
        break;
      case 'ear':
        exerciseDiv.innerHTML = `
          <h4>üëÇ Geh√∂r-√úbung</h4>
          <p>H√∂ren Sie sich diese Intervalle an:</p>
          <div class="controls">
            <button onclick="playPianoInterval('C4', 'E4')" class="btn">üéµ Gro√üe Terz (C-E)</button>
            <button onclick="playPianoInterval('C4', 'G4')" class="btn">üéº Reine Quinte (C-G)</button>
            <button onclick="playPianoInterval('C4', 'C5')" class="btn">üéπ Oktave (C-C)</button>
          </div>
        `;
        break;
    }
  }
  
  function playPianoScale() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const scale = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    scale.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note, '4n');
      }, index * 300);
    });
  }
  
  function playPianoChords() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const chords = [
      ['C4', 'E4', 'G4'], // C
      ['F4', 'A4', 'C5'], // F
      ['G4', 'B4', 'D5'], // G
      ['A4', 'C5', 'E5']  // Am
    ];
    
    const synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    chords.forEach((chord, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(chord, '2n');
      }, index * 1000);
    });
  }
  
  function showPianoNotes() {
    const exerciseDiv = document.getElementById('pianoExercise');
    exerciseDiv.innerHTML += `
      <div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">
        <h5>üéº Noten:</h5>
        <div style="font-family:monospace; font-size:18px;">
          C4 ‚óè E4 ‚óè G4 ‚óè A4
        </div>
      </div>
    `;
  }
  
  function playPianoNotes() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const notes = ['C4', 'E4', 'G4', 'A4'];
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    notes.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note, '4n');
      }, index * 400);
    });
  }
  
  function playPianoInterval(note1, note2) {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    // Erste Note
    synth.triggerAttackRelease(note1, '2n');
    
    // Zweite Note nach 1 Sekunde
    setTimeout(() => {
      synth.triggerAttackRelease(note2, '2n');
    }, 1000);
  }
  
  function checkPianoScale() {
    alert('üéµ Tonleiter korrekt gespielt! √úbung abgeschlossen.');
  }
  
  function checkPianoChords() {
    alert('üéº Akkorde korrekt gespielt! √úbung abgeschlossen.');
  }
  
  function initPiano() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    // Virtuelles Klavier erstellen
    const pianoKeyboard = document.getElementById('pianoKeyboard');
    if (pianoKeyboard) {
      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octaves = [3, 4, 5];
      
      let html = '<div style="display: flex; flex-wrap: wrap; gap: 2px; justify-content: center;">';
      
      octaves.forEach(octave => {
        notes.forEach(note => {
          const isBlack = note.includes('#');
          const keyStyle = isBlack ? 
            'background: #333; color: white; width: 30px; height: 60px; border: 1px solid #000; border-radius: 0 0 4px 4px;' :
            'background: white; color: #333; width: 40px; height: 80px; border: 1px solid #ccc; border-radius: 0 0 4px 4px;';
          
          html += `
            <button onclick="playPianoNote('${note}${octave}')" 
                    style="${keyStyle} font-size: 10px; cursor: pointer; margin: 1px;">
              ${note}${octave}
            </button>
          `;
        });
      });
      
      html += '</div>';
      pianoKeyboard.innerHTML = html;
    }
    
    showNotification('üéπ Klavier initialisiert', 'Das virtuelle Klavier ist jetzt bereit f√ºr die Verwendung', 'success');
    console.log('‚úÖ Klavier initialisiert');
  }
  
  function playPianoChord() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    // Spielt einen C-Dur Akkord
    synth.triggerAttackRelease(['C4', 'E4', 'G4'], '2n');
    showNotification('üéµ C-Dur Akkord gespielt', 'C4, E4, G4', 'info');
  }
  
  function togglePianoOctaves() {
    const pianoContainer = document.getElementById('pianoContainer');
    if (pianoContainer) {
      const currentOctaves = pianoContainer.getAttribute('data-octaves') || '3';
      const newOctaves = currentOctaves === '3' ? '4' : '3';
      pianoContainer.setAttribute('data-octaves', newOctaves);
      showNotification(`üéº Oktaven ge√§ndert`, `Jetzt ${newOctaves} Oktaven`, 'info');
    }
  }
  
  function playPianoScale(notesString) {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const notes = notesString.split(',');
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    notes.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note, '4n');
      }, index * 500);
    });
  }
  
  function playPianoArpeggio(notesString) {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const notes = notesString.split(',');
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    notes.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note, '8n');
      }, index * 300);
    });
  }
  
  function showPianoNotes() {
    const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
    let html = '<h4>üéº Noten</h4>';
    notes.forEach(note => {
      html += `<button onclick="playPianoNote('${note}')" class="btn" style="margin: 5px;">${note}</button>`;
    });
    
    const pianoTab = document.getElementById('piano-tab');
    if (pianoTab) {
      pianoTab.innerHTML = html;
    }
  }
  
  function playPianoNote(note) {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const synth = new Tone.Synth({
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    synth.triggerAttackRelease(note, '2n');
  }
  
  function showPianoScales() {
    const notationDiv = document.getElementById('pianoNotation');
    notationDiv.innerHTML = `
      <h4>üéµ Tonleitern</h4>
      <div style="margin: 10px 0;">
        <strong>C-Dur:</strong> C D E F G A B C
        <button onclick="playPianoScale('C4,D4,E4,F4,G4,A4,B4,C5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>G-Dur:</strong> G A B C D E F# G
        <button onclick="playPianoScale('G4,A4,B4,C5,D5,E5,F#5,G5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>D-Moll:</strong> D E F G A Bb C D
        <button onclick="playPianoScale('D4,E4,F4,G4,A4,Bb4,C5,D5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>A-Moll:</strong> A B C D E F G A
        <button onclick="playPianoScale('A4,B4,C5,D5,E5,F5,G5,A5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
    `;
  }
  
  function showPianoArpeggios() {
    const notationDiv = document.getElementById('pianoNotation');
    notationDiv.innerHTML = `
      <h4>üéº Arpeggios</h4>
      <div style="margin: 10px 0;">
        <strong>C-Dur:</strong> C E G C
        <button onclick="playPianoArpeggio('C4,E4,G4,C5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>G-Dur:</strong> G B D G
        <button onclick="playPianoArpeggio('G4,B4,D5,G5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>D-Moll:</strong> D F A D
        <button onclick="playPianoArpeggio('D4,F4,A4,D5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
      <div style="margin: 10px 0;">
        <strong>A-Moll:</strong> A C E A
        <button onclick="playPianoArpeggio('A4,C5,E5,A5')" class="btn" style="margin-left: 10px;">üéµ Abspielen</button>
      </div>
    `;
  }

  // ---------- Theorie-Funktionen ----------
  const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11, 12],
    minor: [0, 2, 3, 5, 7, 8, 10, 12],
    pentatonic: [0, 2, 4, 7, 9, 12],
    blues: [0, 3, 5, 6, 7, 10, 12],
    dorian: [0, 2, 3, 5, 7, 9, 10, 12],
    mixolydian: [0, 2, 4, 5, 7, 9, 10, 12],
    lydian: [0, 2, 4, 6, 7, 9, 11, 12],
    phrygian: [0, 1, 3, 5, 7, 8, 10, 12],
    locrian: [0, 1, 3, 5, 6, 8, 10, 12]
  };
  
  function showScale() {
    const root = document.getElementById('scaleRoot').value;
    const type = document.getElementById('scaleType').value;
    const scaleDisplay = document.getElementById('scaleDisplay');
    
    const scale = SCALES[type];
    const notes = scale.map(interval => idxToNote(noteIndex(root) + interval, false));
    
    let html = `<h4>üéµ ${root} ${type.charAt(0).toUpperCase() + type.slice(1)}</h4>`;
    html += `<div style="font-family:monospace; font-size:18px; line-height:1.8;">`;
    
    notes.forEach((note, index) => {
      if (index === 0) {
        html += `<span style="color:#007acc; font-weight:bold;">${note}</span> `;
      } else if (index === 7) {
        html += `<span style="color:#007acc; font-weight:bold;">${note}</span>`;
      } else {
        html += `${note} `;
      }
    });
    
    html += `</div>`;
    
    // Intervall-Bezeichnungen
    const intervalNames = {
      major: ['1', '2', '3', '4', '5', '6', '7', '8'],
      minor: ['1', '2', '‚ô≠3', '4', '5', '‚ô≠6', '‚ô≠7', '8'],
      pentatonic: ['1', '2', '3', '5', '6', '8'],
      blues: ['1', '‚ô≠3', '4', '‚ô≠5', '5', '‚ô≠7', '8'],
      dorian: ['1', '2', '‚ô≠3', '4', '5', '6', '‚ô≠7', '8'],
      mixolydian: ['1', '2', '3', '4', '5', '6', '‚ô≠7', '8'],
      lydian: ['1', '2', '3', '‚ôØ4', '5', '6', '7', '8'],
      phrygian: ['1', '‚ô≠2', '‚ô≠3', '4', '5', '‚ô≠6', '‚ô≠7', '8'],
      locrian: ['1', '‚ô≠2', '‚ô≠3', '4', '‚ô≠5', '‚ô≠6', '‚ô≠7', '8']
    };
    
    html += `<div style="margin-top:10px; font-size:14px; color:#666;">`;
    html += `<strong>Intervalle:</strong> `;
    intervalNames[type].forEach((interval, index) => {
      html += `<span style="margin-right:8px;">${interval}</span>`;
    });
    html += `</div>`;
    
    // Klaviatur-Darstellung
    html += `<div style="margin-top:15px; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<h5>üéπ Klaviatur:</h5>`;
    html += createScaleKeyboard(notes);
    html += `</div>`;
    
    scaleDisplay.innerHTML = html;
  }
  
  function createScaleKeyboard(notes) {
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const blackKeys = ['C#', 'D#', 'F#', 'G#', 'A#'];
    
    let html = '<div style="display:flex; justify-content:center; position:relative; height:80px;">';
    
    // Wei√üe Tasten
    whiteKeys.forEach(note => {
      const isInScale = notes.includes(note) || notes.includes(note + '#') || notes.includes(note + 'b');
      const isRoot = notes[0] === note;
      
      let bgColor = 'white';
      let textColor = '#333';
      
      if (isRoot) {
        bgColor = '#007acc';
        textColor = 'white';
      } else if (isInScale) {
        bgColor = '#e8f5e8';
        textColor = '#28a745';
      }
      
      html += `<div style="width:30px; height:80px; background:${bgColor}; border:1px solid #ccc; 
                         margin:0 1px; display:flex; align-items:flex-end; justify-content:center; 
                         padding-bottom:5px; font-weight:bold; color:${textColor}; font-size:12px;">${note}</div>`;
    });
    
    // Schwarze Tasten
    blackKeys.forEach(note => {
      const isInScale = notes.includes(note);
      const isRoot = notes[0] === note;
      
      let bgColor = '#333';
      let textColor = 'white';
      
      if (isRoot) {
        bgColor = '#007acc';
      } else if (isInScale) {
        bgColor = '#28a745';
      }
      
      const whiteKeyIndex = whiteKeys.indexOf(note.replace('#', ''));
      const left = whiteKeyIndex * 30 + 22;
      
      html += `<div style="position:absolute; left:${left}px; width:18px; height:50px; 
                         background:${bgColor}; color:${textColor}; border:1px solid #000; 
                         display:flex; align-items:flex-end; justify-content:center; 
                         padding-bottom:5px; font-weight:bold; z-index:10; font-size:10px;">${note.replace('#', '‚ôØ')}</div>`;
    });
    
    html += '</div>';
    return html;
  }
  
  function analyzeChord() {
    const chordInput = document.getElementById('chordInput').value.trim();
    const chordAnalysis = document.getElementById('chordAnalysis');
    
    if (!chordInput) {
      chordAnalysis.innerHTML = '<p style="color:#dc3545;">Bitte geben Sie einen Akkord ein</p>';
      return;
    }
    
    const parsed = parseChord(chordInput);
    if (!parsed) {
      chordAnalysis.innerHTML = '<p style="color:#dc3545;">Ung√ºltiger Akkord</p>';
      return;
    }
    
    let html = `<h4>üîç Akkord-Analyse: ${chordInput}</h4>`;
    
    // Grundstruktur
    html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Grundton:</strong> ${parsed.root}<br>`;
    html += `<strong>Qualit√§t:</strong> ${parsed.quality}<br>`;
    if (parsed.bass) {
      html += `<strong>Bass:</strong> ${parsed.bass}`;
    }
    html += `</div>`;
    
    // Intervall-Struktur
    const intervals = getChordIntervals(parsed.quality);
    html += `<div style="margin:10px 0; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<strong>Intervall-Struktur:</strong><br>`;
    intervals.forEach(interval => {
      html += `‚Ä¢ ${interval}<br>`;
    });
    html += `</div>`;
    
    // Noten im Akkord
    const rootIndex = noteIndex(parsed.root);
    const chordNotes = intervals.map(interval => {
      const noteIndex = (rootIndex + interval) % 12;
      return idxToNote(noteIndex, false);
    });
    
    html += `<div style="margin:10px 0; padding:10px; background:#fff3cd; border-radius:8px;">`;
    html += `<strong>Noten im Akkord:</strong><br>`;
    html += `<span style="font-family:monospace; font-size:18px;">${chordNotes.join(' ')}</span>`;
    html += `</div>`;
    
    chordAnalysis.innerHTML = html;
  }
  
  function getChordIntervals(quality) {
    const intervalMap = {
      'maj': [0, 4, 7],
      'min': [0, 3, 7],
      '7': [0, 4, 7, 10],
      'm7': [0, 3, 7, 10],
      'maj7': [0, 4, 7, 11],
      'dim': [0, 3, 6],
      'aug': [0, 4, 8],
      'sus2': [0, 2, 7],
      'sus4': [0, 5, 7],
      'add9': [0, 4, 7, 14]
    };
    
    return intervalMap[quality] || [0, 4, 7];
  }
  
  function showChordVoicings() {
    const chordInput = document.getElementById('chordInput').value.trim();
    const chordAnalysis = document.getElementById('chordAnalysis');
    
    if (!chordInput) {
      chordAnalysis.innerHTML = '<p style="color:#dc3545;">Bitte geben Sie zuerst einen Akkord ein</p>';
      return;
    }
    
    const parsed = parseChord(chordInput);
    if (!parsed) {
      chordAnalysis.innerHTML = '<p style="color:#dc3545;">Ung√ºltiger Akkord</p>';
      return;
    }
    
    let html = `<h4>üéπ Voicings f√ºr ${chordInput}</h4>`;
    
    // Verschiedene Voicings
    const voicings = generateChordVoicings(parsed);
    
    voicings.forEach((voicing, index) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>Voicing ${index + 1}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${voicing.join(' ')}</span>`;
      html += `</div>`;
    });
    
    chordAnalysis.innerHTML = html;
  }
  
  function generateChordVoicings(chord) {
    const rootIndex = noteIndex(chord.root);
    const intervals = getChordIntervals(chord.quality);
    
    const voicings = [];
    
    // Grundvoicing
    const basicVoicing = intervals.map(interval => {
      const noteIndex = (rootIndex + interval) % 12;
      return idxToNote(noteIndex, false);
    });
    voicings.push(basicVoicing);
    
    // Drop-2 Voicing
    if (intervals.length >= 4) {
      const drop2 = [...basicVoicing];
      const secondNote = drop2.splice(1, 1)[0];
      drop2.push(secondNote);
      voicings.push(drop2);
    }
    
    // Drop-3 Voicing
    if (intervals.length >= 4) {
      const drop3 = [...basicVoicing];
      const thirdNote = drop3.splice(2, 1)[0];
      drop3.push(thirdNote);
      voicings.push(drop3);
    }
    
    return voicings;
  }
  
  function showCommonProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    let html = `<h4>üéº H√§ufige Akkordfolgen - Alle Genres</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<p>W√§hlen Sie eine Kategorie aus - Alle Genres von Polka bis Techno:</p>`;
    html += `<div class="controls">`;
    html += `<button onclick="showBasicProgressions()" class="btn">üéµ Grundlagen</button>`;
    html += `<button onclick="showJazzProgressions()" class="btn">üé∑ Jazz</button>`;
    html += `<button onclick="showBluesProgressions()" class="btn">üé∏ Blues</button>`;
    html += `<button onclick="showPopProgressions()" class="btn">üé§ Pop</button>`;
    html += `<button onclick="showFolkProgressions()" class="btn">üåø Folk</button>`;
    html += `<button onclick="showRockProgressions()" class="btn">ü§ò Rock</button>`;
    html += `<button onclick="showPunkProgressions()" class="btn">üíÄ Punk</button>`;
    html += `<button onclick="showTechnoProgressions()" class="btn">‚ö° Techno</button>`;
    html += `<button onclick="showCountryProgressions()" class="btn">ü§† Country</button>`;
    html += `<button onclick="showReggaeProgressions()" class="btn">üå¥ Reggae</button>`;
    html += `<button onclick="showMetalProgressions()" class="btn">üî• Metal</button>`;
    html += `<button onclick="showElectronicProgressions()" class="btn">üéõÔ∏è Electronic</button>`;
    html += `<button onclick="showPolkaProgressions()" class="btn">üé™ Polka</button>`;
    html += `<button onclick="showSkaProgressions()" class="btn">üé∫ Ska</button>`;
    html += `<button onclick="showFunkProgressions()" class="btn">üé∑ Funk</button>`;
    html += `<button onclick="showSoulProgressions()" class="btn">üí´ Soul</button>`;
    html += `<button onclick="showRnbProgressions()" class="btn">üé§ R&B</button>`;
    html += `<button onclick="showHiphopProgressions()" class="btn">üé§ Hip-Hop</button>`;
    html += `<button onclick="showDiscoProgressions()" class="btn">üíÉ Disco</button>`;
    html += `<button onclick="showHouseProgressions()" class="btn">üè† House</button>`;
    html += `<button onclick="showTranceProgressions()" class="btn">üåÄ Trance</button>`;
    html += `<button onclick="showDubstepProgressions()" class="btn">üéµ Dubstep</button>`;
    html += `<button onclick="showAmbientProgressions()" class="btn">üåå Ambient</button>`;
    html += `<button onclick="showClassicalProgressions()" class="btn">üéº Klassisch</button>`;
    html += `<button onclick="showBaroqueProgressions()" class="btn">üé≠ Barock</button>`;
    html += `<button onclick="showRomanticProgressions()" class="btn">üíï Romantik</button>`;
    html += `<button onclick="showModernProgressions()" class="btn">üé® Modern</button>`;
    html += `<button onclick="showExperimentalProgressions()" class="btn">üß™ Experimental</button>`;
    html += `</div>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function analyzeProgression() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    let html = `<h4>üîç Progression-Analyse</h4>`;
    html += `<p>Geben Sie eine Akkordfolge in das Gitarren-Eingabefeld ein und klicken Sie auf "Berechnen"</p>`;
    
    // Beispiel-Analyse
    html += `<div style="margin:10px 0; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<strong>Beispiel: C ‚Üí G ‚Üí Am ‚Üí F</strong><br>`;
    html += `‚Ä¢ <strong>Funktion:</strong> I ‚Üí V ‚Üí vi ‚Üí IV<br>`;
    html += `‚Ä¢ <strong>Charakter:</strong> Pop/Rock Standard<br>`;
    html += `‚Ä¢ <strong>Spannung:</strong> Steigend ‚Üí H√∂hepunkt ‚Üí Aufl√∂sung<br>`;
    html += `‚Ä¢ <strong>Verwendung:</strong> Verse, Chorus, Bridge`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function suggestSubstitutions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const substitutions = {
      'C': ['Am', 'Em', 'F'],
      'G': ['Bm', 'D', 'Em'],
      'Am': ['C', 'F', 'Dm'],
      'F': ['Dm', 'Am', 'C'],
      'Dm': ['F', 'Am', 'C'],
      'Em': ['G', 'C', 'Am']
    };
    
    let html = `<h4>üí° Akkord-Ersetzungen</h4>`;
    
    Object.entries(substitutions).forEach(([chord, alternatives]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${chord} kann ersetzt werden durch:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${alternatives.join(', ')}</span>`;
      html += `</div>`;
    });
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showFunctionalHarmony() {
    const functionalTheory = document.getElementById('functionalTheory');
    
    const functions = {
      'Tonika (I)': 'Zentrum, Ruhepunkt, Heimkehr',
      'Dominante (V)': 'Spannung, Drang zur Aufl√∂sung',
      'Subdominante (IV)': 'Vorbereitung, Weichheit',
      'Submediante (vi)': 'Moll-Variante der Tonika',
      'Mediante (iii)': 'Verbindung zwischen Tonika und Dominante',
      'Supertonika (ii)': 'Moll-Variante der Subdominante',
      'Leitton (vii¬∞)': 'Unvollst√§ndige Dominante'
    };
    
    let html = `<h4>üéµ Funktionstheorie</h4>`;
    
    Object.entries(functions).forEach(([function_, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${function_}:</strong> ${description}`;
      html += `</div>`;
    });
    
    functionalTheory.innerHTML = html;
  }

  function showCadences() {
    const functionalTheory = document.getElementById('functionalTheory');
    
    const cadences = {
      'Authentische Kadenz (V-I)': 'Dominante zur Tonika - vollst√§ndige Aufl√∂sung',
      'Plagale Kadenz (IV-I)': 'Subdominante zur Tonika - weiche Aufl√∂sung',
      'Deceptive Cadence (V-vi)': 'Dominante zur Submediante - √ºberraschende Wendung',
      'Half Cadence (I-V)': 'Tonika zur Dominante - unvollst√§ndige Spannung',
      'Picardy Third': 'Moll-Kadenz mit Dur-Tonika'
    };
    
    let html = `<h4>üéº Kadenzen</h4>`;
    
    Object.entries(cadences).forEach(([cadence, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${cadence}:</strong> ${description}`;
      html += `</div>`;
    });
    
    functionalTheory.innerHTML = html;
  }

  function showModulations() {
    const functionalTheory = document.getElementById('functionalTheory');
    
    const modulations = {
      'Diatonische Modulation': 'Modulation innerhalb der Tonleiter',
      'Chromatic Modulation': 'Modulation √ºber chromatische Zwischendominanten',
      'Pivot Chord Modulation': 'Modulation √ºber gemeinsame Akkorde',
      'Direct Modulation': 'Direkte Modulation ohne √úbergang',
      'Sequential Modulation': 'Modulation durch Sequenzen'
    };
    
    let html = `<h4>üéπ Modulationen</h4>`;
    
    Object.entries(modulations).forEach(([modulation, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${modulation}:</strong> ${description}`;
      html += `</div>`;
    });
    
    functionalTheory.innerHTML = html;
  }

  // Theorie-Funktionen global verf√ºgbar machen
  window.showCadences = showCadences;
  window.showModulations = showModulations;

  // Instrument Selection Functions
  async function changeInstrument() {
    const select = document.getElementById('instrumentSelect');
    const selectedInstrument = select.value;
    
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
      console.log('üé∏ Instrument gewechselt zu:', selectedInstrument);
      
      // Update global instrument setting
      window.currentInstrument = selectedInstrument;
      
      // Show notification
      showNotification('üé∏ Instrument gewechselt', `Jetzt: ${select.options[select.selectedIndex].text}`, 'success');
    } else {
      // Versuche Enhanced Audio System zu initialisieren
      if (window.EnhancedAudioSystem) {
        window.enhancedAudioSystem = new window.EnhancedAudioSystem();
        await window.enhancedAudioSystem.init();
        window.currentInstrument = selectedInstrument;
        showNotification('üé∏ Instrument gewechselt', `Jetzt: ${select.options[select.selectedIndex].text}`, 'success');
      } else {
        showNotification('‚ùå Audio System nicht verf√ºgbar', 'Bitte warten Sie bis das Audio System geladen ist', 'error');
      }
    }
  }

  async function testInstrument() {
    const select = document.getElementById('instrumentSelect');
    const selectedInstrument = select.value;
    
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
      // Play a test chord with selected instrument
      const testChord = 'C';
      await window.enhancedAudioSystem.playChord(testChord, selectedInstrument.split('-')[1] || 'guitar', selectedInstrument.split('-')[0] || 'acoustic');
      
      showNotification('üéµ Test abgespielt', `Instrument: ${select.options[select.selectedIndex].text}`, 'success');
    } else {
      // Versuche Enhanced Audio System zu initialisieren
      if (window.EnhancedAudioSystem) {
        window.enhancedAudioSystem = new window.EnhancedAudioSystem();
        await window.enhancedAudioSystem.init();
        const testChord = 'C';
        await window.enhancedAudioSystem.playChord(testChord, selectedInstrument.split('-')[1] || 'guitar', selectedInstrument.split('-')[0] || 'acoustic');
        showNotification('üéµ Test abgespielt', `Instrument: ${select.options[select.selectedIndex].text}`, 'success');
      } else {
        showNotification('‚ùå Audio System nicht verf√ºgbar', 'Bitte warten Sie bis das Audio System geladen ist', 'error');
      }
    }
  }

  // Audio-Bearbeitungsfunktionen
  async function startAudioEditing() {
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (!window.enhancedAudioSystem) {
      if (window.EnhancedAudioSystem) {
        window.enhancedAudioSystem = new window.EnhancedAudioSystem();
        await window.enhancedAudioSystem.init();
      } else {
        showNotification('‚ùå Enhanced Audio System nicht verf√ºgbar', 'Audio-Bearbeitung kann nicht gestartet werden', 'error');
        return;
      }
    }
    
    // Audio-Bearbeitungs-Interface aktivieren
    const audioEditingTab = document.getElementById('audio-editing-tab');
    if (audioEditingTab) {
      audioEditingTab.style.display = 'block';
      showNotification('üéõÔ∏è Audio-Bearbeitung aktiviert', 'Alle Audio-Tools sind jetzt verf√ºgbar', 'success');
    }
  }
  
  async function exportAudio() {
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (window.enhancedAudioSystem && window.enhancedAudioSystem.isRecording) {
      try {
        const audioData = await window.enhancedAudioSystem.stopRecording();
        if (audioData) {
          // Audio als WAV-Datei exportieren
          const blob = new Blob([audioData], { type: 'audio/wav' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `musical-education-${Date.now()}.wav`;
          a.click();
          URL.revokeObjectURL(url);
          showNotification('üéµ Audio exportiert', 'Datei wurde erfolgreich heruntergeladen', 'success');
        }
      } catch (error) {
        console.error('Fehler beim Audio-Export:', error);
        showNotification('‚ùå Export fehlgeschlagen', 'Fehler beim Exportieren der Audio-Datei', 'error');
      }
    } else {
      showNotification('‚ùå Keine Aufnahme aktiv', 'Bitte starten Sie zuerst eine Audio-Aufnahme', 'warning');
    }
  }
  
  // Funktionen global verf√ºgbar machen
  window.changeInstrument = changeInstrument;
  window.testInstrument = testInstrument;
  window.startAudioEditing = startAudioEditing;
  window.exportAudio = exportAudio;
  
  // Erweiterte automatische Wiederholungsfunktionen
  async function enableAutoRepeat() {
    songRepetition.autoRepeat = true;
    showNotification('üîÑ Automatische Wiederholung aktiviert', 'Songs werden automatisch wiederholt', 'success');
  }
  
  async function disableAutoRepeat() {
    songRepetition.autoRepeat = false;
    showNotification('‚èπÔ∏è Automatische Wiederholung deaktiviert', 'Songs werden nicht mehr automatisch wiederholt', 'info');
  }
  
  async function setRepeatCount(count) {
    songRepetition.maxRepeats = Math.max(1, Math.min(10, count));
    showNotification(`üî¢ Wiederholungen gesetzt`, `Maximal ${songRepetition.maxRepeats} Wiederholungen`, 'info');
  }
  
  async function playChordSequence(chords, instrument = 'guitar') {
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (!window.enhancedAudioSystem) {
      if (window.EnhancedAudioSystem) {
        window.enhancedAudioSystem = new window.EnhancedAudioSystem();
        await window.enhancedAudioSystem.init();
      } else {
        showNotification('‚ùå Audio System nicht verf√ºgbar', 'Kann Akkord-Sequenz nicht abspielen', 'error');
        return;
      }
    }
    
    // Akkorde nacheinander abspielen
    for (let i = 0; i < chords.length; i++) {
      const chord = chords[i];
      await window.enhancedAudioSystem.playChord(chord, instrument, 'acoustic');
      
      // Pause zwischen Akkorden (au√üer beim letzten)
      if (i < chords.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  // Funktionen global verf√ºgbar machen
  window.enableAutoRepeat = enableAutoRepeat;
  window.disableAutoRepeat = disableAutoRepeat;
  window.setRepeatCount = setRepeatCount;
  window.playChordSequence = playChordSequence;

  // Song Repetition Functions
  let songRepetition = {
    isPlaying: false,
    currentIndex: 0,
    chords: [],
    intervalId: null,
    repeatCount: 0,
    maxRepeats: 3,
    autoRepeat: true,
    repeatDelay: 2000, // 2 Sekunden Pause zwischen Wiederholungen
    currentSong: null
  };

  async function startSongRepetition() {
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    const input = document.getElementById('inp');
    if (!input || !input.value.trim()) {
      showNotification('‚ùå Keine Akkorde eingegeben', 'Bitte geben Sie zuerst Akkorde ein', 'error');
      return;
    }

    // Akkorde parsen
    const chordText = input.value.trim();
    const chords = chordText.split(/\s+/).filter(c => c.length > 0);
    
    if (chords.length === 0) {
      showNotification('‚ùå Keine g√ºltigen Akkorde gefunden', 'Bitte geben Sie g√ºltige Akkorde ein', 'error');
      return;
    }

    // Wiederholung starten
    songRepetition.isPlaying = true;
    songRepetition.chords = chords;
    songRepetition.currentIndex = 0;
    songRepetition.repeatCount = 0;
    
    showNotification('üîÑ Wiederholung gestartet', `Spiele ${chords.length} Akkorde ${songRepetition.maxRepeats}x ab`, 'success');
    
    // Progress Bar aktualisieren
    updateRepetitionProgress();
    
    // Akkorde abspielen
    await playRepetitionLoop();
  }

  async function stopSongRepetition() {
    songRepetition.isPlaying = false;
    songRepetition.currentIndex = 0;
    songRepetition.repeatCount = 0;
    
    // Progress Bar zur√ºcksetzen
    const progressBar = document.getElementById('repetitionProgress');
    if (progressBar) {
      const progress = progressBar.querySelector('div');
      if (progress) progress.style.width = '0%';
    }
    
    showNotification('‚èπÔ∏è Wiederholung gestoppt', 'Song-Wiederholung wurde beendet', 'info');
  }

  async function playRepetitionLoop() {
    while (songRepetition.isPlaying && songRepetition.repeatCount < songRepetition.maxRepeats) {
      const chord = songRepetition.chords[songRepetition.currentIndex];
      
      // Akkord abspielen
      if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
        await window.enhancedAudioSystem.playChord(chord, 'guitar', 'acoustic');
      }
      
      // Progress aktualisieren
      updateRepetitionProgress();
      
      // N√§chster Akkord
      songRepetition.currentIndex++;
      
      // Wenn alle Akkorde gespielt wurden
      if (songRepetition.currentIndex >= songRepetition.chords.length) {
        songRepetition.currentIndex = 0;
        songRepetition.repeatCount++;
        
        // Pause zwischen Wiederholungen
        if (songRepetition.isPlaying && songRepetition.repeatCount < songRepetition.maxRepeats) {
          await new Promise(resolve => setTimeout(resolve, songRepetition.repeatDelay));
        }
      } else {
        // Pause zwischen Akkorden
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    // Wiederholung beendet
    if (songRepetition.repeatCount >= songRepetition.maxRepeats) {
      songRepetition.isPlaying = false;
      showNotification('‚úÖ Wiederholung abgeschlossen', `Alle ${songRepetition.maxRepeats} Wiederholungen wurden gespielt`, 'success');
    }
  }

  function updateRepetitionProgress() {
    const progressBar = document.getElementById('repetitionProgress');
    if (!progressBar) return;
    
    const progress = progressBar.querySelector('div');
    if (!progress) return;
    
    const totalSteps = songRepetition.chords.length * songRepetition.maxRepeats;
    const currentStep = (songRepetition.repeatCount * songRepetition.chords.length) + songRepetition.currentIndex;
    const percentage = Math.min(100, (currentStep / totalSteps) * 100);
    
    progress.style.width = percentage + '%';
  }

  // Song-Repetition-Funktionen global verf√ºgbar machen
  window.startSongRepetition = startSongRepetition;
  window.stopSongRepetition = stopSongRepetition;
  
  // Fretboard-Technik als schaltbare Variante implementieren
  let fretboardMode = false;
  
  function toggleFretboardMode() {
    fretboardMode = !fretboardMode;
    
    if (fretboardMode) {
      // Fretboard-Modus aktivieren
      showNotification('üé∏ Fretboard-Modus aktiviert', 'Klicken Sie auf Griffbilder um sie zu bearbeiten', 'success');
      activateFretboardMode();
    } else {
      // Fretboard-Modus deaktivieren
      showNotification('üìù Standard-Modus aktiviert', 'Griffbilder sind wieder schreibgesch√ºtzt', 'info');
      deactivateFretboardMode();
    }
  }
  
  function activateFretboardMode() {
    // Alle Griffbilder mit Fretboard-Funktionalit√§t versehen
    const diagrams = document.querySelectorAll('#diagrams .chord-diagram');
    diagrams.forEach(diagram => {
      diagram.style.cursor = 'pointer';
      diagram.title = 'Klicken zum Bearbeiten (Fretboard-Modus)';
      diagram.addEventListener('click', handleFretboardClick);
    });
  }
  
  function deactivateFretboardMode() {
    // Fretboard-Funktionalit√§t entfernen
    const diagrams = document.querySelectorAll('#diagrams .chord-diagram');
    diagrams.forEach(diagram => {
      diagram.style.cursor = 'default';
      diagram.title = '';
      diagram.removeEventListener('click', handleFretboardClick);
    });
  }
  
  function handleFretboardClick(event) {
    if (!fretboardMode) return;
    
    const diagram = event.currentTarget;
    const chordName = diagram.dataset.chord || 'Unbekannt';
    
    // Fretboard-Editor √∂ffnen
    openFretboardEditor(chordName, diagram);
  }
  
  function openFretboardEditor(chordName, targetDiagram) {
    // Fretboard-Editor Modal erstellen
    const modal = document.createElement('div');
    modal.className = 'fretboard-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;
    
    const editor = document.createElement('div');
    editor.style.cssText = `
      background: white;
      padding: 20px;
      border-radius: 12px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    `;
    
    editor.innerHTML = `
      <h3>üé∏ Fretboard-Editor: ${chordName}</h3>
      <div data-fretboard data-strings="6" data-frets="5" data-title="${chordName}" style="width: 100%; margin: 20px 0;"></div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button onclick="saveFretboardChanges('${chordName}')" class="btn">üíæ Speichern</button>
        <button onclick="closeFretboardEditor()" class="btn sec">‚ùå Schlie√üen</button>
      </div>
    `;
    
    modal.appendChild(editor);
    document.body.appendChild(modal);
    
    // Fretboard initialisieren
    if (window.Fretboard && window.Fretboard.init) {
      window.Fretboard.init(editor);
    }
    
    // Modal schlie√üen bei Klick au√üerhalb
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeFretboardEditor();
      }
    });
  }
  
  function saveFretboardChanges(chordName) {
    const fretboard = document.querySelector('.fretboard-modal [data-fretboard]');
    if (fretboard && fretboard._fbApi) {
      const dots = fretboard._fbApi.get();
      console.log(`Fretboard-Daten f√ºr ${chordName}:`, dots);
      
      // Hier k√∂nnten die Daten gespeichert oder an das Hauptsystem √ºbertragen werden
      showNotification('üíæ Fretboard gespeichert', `√Ñnderungen f√ºr ${chordName} wurden gespeichert`, 'success');
    }
    
    closeFretboardEditor();
  }
  
  function closeFretboardEditor() {
    const modal = document.querySelector('.fretboard-modal');
    if (modal) {
      modal.remove();
    }
  }
  
  // Fretboard-Funktionen global verf√ºgbar machen
  window.toggleFretboardMode = toggleFretboardMode;
  window.openFretboardEditor = openFretboardEditor;
  window.saveFretboardChanges = saveFretboardChanges;
  window.closeFretboardEditor = closeFretboardEditor;
  
  // Fretboard-Technik direkt einbetten (Single-File-Implantat)
  (()=>{ 'use strict';
  // Minimalistischer, eigenst√§ndiger Fretboard-Editor als "Implantat"
  if (!window.Fretboard) window.Fretboard = {};
  const STYLE_ID = 'fretboard-implant-style';
  
  function injectStyles(){
    if (document.getElementById(STYLE_ID)) return;
    const css = `
    .fb-wrap{display:inline-block;position:relative;user-select:none;touch-action:none;border-radius:14px;overflow:hidden;background:#fff}
    .fb-svg{width:100%;height:auto;display:block}
    .fb-grid{stroke:#6b7280;stroke-width:0.015}
    .fb-grid.fret{stroke:#d1d5db}
    .fb-nut{stroke:#374151;stroke-width:0.05}
    .fb-dot{fill:#111;opacity:.95;cursor:grab;filter: drop-shadow(0 .5px 1px rgba(0,0,0,.25))}
    .fb-dot:active{cursor:grabbing}
    .fb-hot{fill:transparent}
    .fb-badge{position:absolute;top:6px;right:8px;background:#0000000d;border:1px solid #0000001a;border-radius:999px;padding:2px 8px;font-size:12px}
    `;
    const style=document.createElement('style'); style.id=STYLE_ID; style.textContent=css; document.head.appendChild(style);
  }

  function build(el){
    const strings = +el.dataset.strings || 6;
    const frets   = +el.dataset.frets   || 5;
    const title   = el.dataset.title || '';
    const widthPx = +el.dataset.width || parseFloat(getComputedStyle(el).width) || 300;
    el.classList.add('fb-wrap'); if (!el.style.width) el.style.width = widthPx + 'px';

    const vbw = strings - 1;
    const vbh = frets;
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('viewBox', `0 0 ${vbw} ${vbh}`);
    svg.classList.add('fb-svg');

    // Saiten (vertikal)
    for(let s=0; s<strings; s++){
      const x = s * (vbw/(strings-1));
      const l = document.createElementNS(svgNS,'line');
      l.setAttribute('x1', x); l.setAttribute('y1', 0);
      l.setAttribute('x2', x); l.setAttribute('y2', vbh);
      l.setAttribute('class','fb-grid string');
      svg.appendChild(l);
    }
    // B√ºnde (horizontal)
    for(let f=0; f<=frets; f++){
      const y = f * (vbh/frets);
      const l = document.createElementNS(svgNS,'line');
      l.setAttribute('x1', 0); l.setAttribute('y1', y);
      l.setAttribute('x2', vbw); l.setAttribute('y2', y);
      l.setAttribute('class', f===0? 'fb-nut' : 'fb-grid fret');
      svg.appendChild(l);
    }

    // Hot-Layer f√ºr Klicks/Pointer
    const hot = document.createElementNS(svgNS,'rect');
    hot.setAttribute('x', 0); hot.setAttribute('y', 0);
    hot.setAttribute('width', vbw); hot.setAttribute('height', vbh);
    hot.setAttribute('class','fb-hot');
    svg.appendChild(hot);

    el.appendChild(svg);
    if (title){ const badge=document.createElement('div'); badge.textContent=title; badge.className='fb-badge'; el.appendChild(badge); }

    const state = { strings, frets, vbw, vbh, dots: [] };
    el._fretboard = state;

    function snap(pt){
      const s = Math.round(pt.x * (strings-1) / vbw);
      let f = Math.round(pt.y * frets / vbh);
      if (f < 1) f = 1; if (f > frets) f = frets;
      return { s, f };
    }
    function posOf(sf){
      const x = sf.s * (vbw/(strings-1));
      const y = (sf.f - 0.5) * (vbh/frets);
      return { x, y };
    }
    function findDot(sf){ return state.dots.find(d => d.s===sf.s && d.f===sf.f); }

    function redraw(){
      [...svg.querySelectorAll('.fb-dot')].forEach(n => n.remove());
      for(const d of state.dots){
        const c = document.createElementNS(svgNS,'circle');
        const {x,y} = posOf(d);
        c.setAttribute('cx', x); c.setAttribute('cy', y);
        c.setAttribute('r', (0.11*vbw)/strings);
        c.setAttribute('class','fb-dot');
        c.dataset.s = d.s; c.dataset.f = d.f;
        svg.appendChild(c);
      }
      emit();
    }

    function emit(){
      el.dispatchEvent(new CustomEvent('fretboard:change', { detail: { dots: state.dots.map(d => ({...d})) } }));
      const sync = el.dataset.syncInput && document.querySelector(el.dataset.syncInput);
      if (sync){ try { sync.value = JSON.stringify(state.dots); } catch(_){} }
    }
    function toggle(sf){
      const exists = findDot(sf);
      if (exists) state.dots = state.dots.filter(d => !(d.s===sf.s && d.f===sf.f));
      else state.dots = [...state.dots.filter(d => !(d.s===sf.s && d.f===sf.f)), sf];
      redraw();
    }
    function clientToSvg(e){
      const rect = svg.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width * vbw;
      const y = (e.clientY - rect.top)  / rect.height * vbh;
      return { x, y };
    }

    // Event Listeners
    hot.addEventListener('click', (e) => {
      const pt = clientToSvg(e);
      toggle(snap(pt));
    });

    let drag = null;
    svg.addEventListener('pointerdown', (e) => {
      const t = e.target;
      if (!t.classList.contains('fb-dot')) return;
      drag = { orig: { s:+t.dataset.s, f:+t.dataset.f }, circle: t };
      t.setPointerCapture(e.pointerId);
    });
    svg.addEventListener('pointermove', (e) => {
      if (!drag) return;
      const sf = snap(clientToSvg(e));
      drag.circle.setAttribute('cx', sf.s * (vbw/(strings-1)));
      drag.circle.setAttribute('cy', (sf.f - .5) * (vbh/frets));
    });
    svg.addEventListener('pointerup', (e) => {
      if (!drag) return;
      const sf = snap(clientToSvg(e));
      if (e.ctrlKey || e.metaKey || e.button === 2){
        state.dots = state.dots.filter(d => !(d.s===drag.orig.s && d.f===drag.orig.f));
      } else {
        state.dots = state.dots
          .filter(d => !(d.s===drag.orig.s && d.f===drag.orig.f))
          .filter(d => !(d.s===sf.s && d.f===sf.f))
          .concat([sf]);
      }
      try{ drag.circle.releasePointerCapture(e.pointerId); }catch(_){ }
      drag = null;
      redraw();
    });
    svg.addEventListener('dblclick', (e) => {
      if (e.target.classList.contains('fb-dot')){
        const s = +e.target.dataset.s, f = +e.target.dataset.f;
        state.dots = state.dots.filter(d => !(d.s===s && d.f===f));
        redraw();
      }
    });
    svg.addEventListener('contextmenu', (e) => e.preventDefault());

    if (el.dataset.json){ try { const arr = JSON.parse(el.dataset.json); if (Array.isArray(arr)) state.dots = arr.map(x => ({ s:+x.s, f:+x.f })); } catch(_){ } }
    redraw();

    const api = {
      get(){ return state.dots.map(d => ({...d})); },
      set(dots){ state.dots = (dots||[]).map(x => ({ s:+x.s, f:+x.f })); redraw(); },
      clear(){ state.dots = []; redraw(); }
    };
    el._fbApi = api;
    return api;
  }

  function init(root=document){
    injectStyles();
    // Sicherstellen, dass root ein g√ºltiges DOM-Element oder document ist
    if (!root || typeof root.querySelectorAll !== 'function') {
      root = document;
    }
    const els = [...root.querySelectorAll('[data-fretboard]')];
    els.forEach(el => build(el));
  }

  window.Fretboard.init = init;
  window.Fretboard.attach = (el) => build(el);

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init);
  })();

  function     playNextChordInSequence() {
      if (!songRepetition.isPlaying) return;

      const chord = songRepetition.chords[songRepetition.currentIndex];
      
      // Use original Tone.js for better compatibility
      if (window.Tone) {
        try {
          // Create a simple synth for clean playback
          const synth = new window.Tone.PolySynth(window.Tone.Synth, {
            oscillator: { type: 'sine' },
            envelope: { 
              attack: 0.1, 
              decay: 0.2, 
              sustain: 0.3, 
              release: 0.5 
            }
          }).toDestination();
          
          const notes = getChordNotes(chord);
          synth.triggerAttackRelease(notes, '1n');
          
          console.log('üéµ Akkord abgespielt:', chord, notes);
        } catch (error) {
          console.error('‚ùå Fehler beim Abspielen:', error);
        }
      }

      // Update progress display
      updateRepetitionProgress();

      songRepetition.currentIndex++;
      
      if (songRepetition.currentIndex >= songRepetition.chords.length) {
        songRepetition.currentIndex = 0;
        songRepetition.repeatCount++;
        
        if (songRepetition.repeatCount >= songRepetition.maxRepeats) {
          stopSongRepetition();
          return;
        }
      }

      // Schedule next chord (2 seconds delay)
      songRepetition.intervalId = setTimeout(playNextChordInSequence, 2000);
    }

  function updateRepetitionProgress() {
    const progress = ((songRepetition.currentIndex + (songRepetition.repeatCount * songRepetition.chords.length)) / 
                     (songRepetition.chords.length * songRepetition.maxRepeats)) * 100;
    
    // Update UI if there's a progress element
    const progressElement = document.getElementById('repetitionProgress');
    if (progressElement) {
      progressElement.style.width = `${progress}%`;
      progressElement.textContent = `${Math.round(progress)}%`;
    }
  }

  function setRepetitionCount(count) {
    songRepetition.maxRepeats = Math.max(1, Math.min(10, count));
    showNotification('üîÑ Wiederholungen eingestellt', `${songRepetition.maxRepeats} Wiederholungen`, 'info');
  }
  
  // Genre-spezifische Progression-Funktionen
  function showBasicProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Dur)': ['C', 'F', 'G'],
      'I-vi-IV-V (Pop)': ['C', 'Am', 'F', 'G'],
      'I-V-vi-IV (Pop)': ['C', 'G', 'Am', 'F'],
      'ii-V-I (Jazz)': ['Dm', 'G', 'C'],
      'I-vi-ii-V (Jazz)': ['C', 'Am', 'Dm', 'G'],
      'I-IV-vi-V (Rock)': ['C', 'F', 'Am', 'G'],
      'vi-IV-I-V (Pop)': ['Am', 'F', 'C', 'G']
    };
    
    let html = `<h4>üéµ Grundlagen-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#e8f5e8; border-radius:8px;">`;
    html += `<p><strong>Die wichtigsten Akkordfolgen der westlichen Musik:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#fff; border:1px solid #dee2e6; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#007acc;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#666;">Klicken Sie auf die Akkorde, um sie zu transponieren</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playProgressionExample()" class="btn">üéµ Beispiel abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showFolkProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V (Einfach)': ['G', 'D'],
      'I-IV-V (Folk)': ['G', 'C', 'D'],
      'I-vi-IV-V (Folk Ballad)': ['G', 'Em', 'C', 'D'],
      'I-V-vi-IV (Folk Rock)': ['G', 'D', 'Em', 'C'],
      'vi-IV-I-V (Folk Pop)': ['Em', 'C', 'G', 'D'],
      'I-IV-vi-V (Folk Country)': ['G', 'C', 'Em', 'D'],
      'ii-V-I (Folk Jazz)': ['Am', 'D', 'G'],
      'I-vi-ii-V (Folk Jazz)': ['G', 'Em', 'Am', 'D']
    };
    
    let html = `<h4>üåø Folk-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#e8f5e8; border-radius:8px;">`;
    html += `<p><strong>Traditionelle Folk- und Akustik-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#fff; border:1px solid #dee2e6; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#28a745;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#666;">Typisch f√ºr: Bob Dylan, Simon & Garfunkel, Mumford & Sons</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playFolkProgression()" class="btn">üåø Folk abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showPunkProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V (Punk Basic)': ['E', 'B'],
      'I-IV (Punk Simple)': ['E', 'A'],
      'I-IV-V (Punk Rock)': ['E', 'A', 'B'],
      'I-V-vi-IV (Punk Pop)': ['E', 'B', 'C#m', 'A'],
      'vi-IV-I-V (Punk Alternative)': ['C#m', 'A', 'E', 'B'],
      'I-IV-vi-V (Punk Hardcore)': ['E', 'A', 'C#m', 'B'],
      'I-V-vi-IV (Punk Emo)': ['E', 'B', 'C#m', 'A'],
      'ii-V-I (Punk Jazz)': ['F#m', 'B', 'E']
    };
    
    let html = `<h4>üíÄ Punk-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#dc3545; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Energische und einfache Punk-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Ramones, Sex Pistols, Green Day</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playPunkProgression()" class="btn">üíÄ Punk abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showTechnoProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'i-VI-III-VII (Techno Minor)': ['Am', 'F', 'C', 'G'],
      'i-VI-III-VII (Techno Dark)': ['Dm', 'Bb', 'F', 'C'],
      'i-VI-III-VII (Techno Acid)': ['Em', 'C', 'G', 'D'],
      'i-VI-III-VII (Techno Trance)': ['Bm', 'G', 'D', 'A'],
      'i-VI-III-VII (Techno Industrial)': ['Cm', 'Ab', 'Eb', 'Bb'],
      'i-VI-III-VII (Techno Minimal)': ['Gm', 'Eb', 'Bb', 'F'],
      'i-VI-III-VII (Techno Progressive)': ['F#m', 'D', 'A', 'E'],
      'i-VI-III-VII (Techno Hardcore)': ['Abm', 'Fb', 'Cb', 'Gb']
    };
    
    let html = `<h4>‚ö° Techno-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#6f42c1; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Hypnotische Techno-Progressionen mit Moll-Akkorden:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Kraftwerk, Underworld, Aphex Twin</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playTechnoProgression()" class="btn">‚ö° Techno abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showRockProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Rock Basic)': ['E', 'A', 'B'],
      'I-V-vi-IV (Rock Pop)': ['E', 'B', 'C#m', 'A'],
      'I-IV-vi-V (Rock Alternative)': ['E', 'A', 'C#m', 'B'],
      'vi-IV-I-V (Rock Emo)': ['C#m', 'A', 'E', 'B'],
      'I-V-vi-IV (Rock Classic)': ['E', 'B', 'C#m', 'A'],
      'ii-V-I (Rock Jazz)': ['F#m', 'B', 'E'],
      'I-vi-ii-V (Rock Jazz)': ['E', 'C#m', 'F#m', 'B'],
      'I-IV-vi-V (Rock Hard)': ['E', 'A', 'C#m', 'B']
    };
    
    let html = `<h4>ü§ò Rock-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#fd7e14; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Kraftvolle Rock-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Led Zeppelin, AC/DC, Foo Fighters</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playRockProgression()" class="btn">ü§ò Rock abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showJazzProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'ii-V-I (Jazz Basic)': ['Dm', 'G', 'C'],
      'I-vi-ii-V (Jazz Standard)': ['C', 'Am', 'Dm', 'G'],
      'ii-V-I-vi (Jazz Turnaround)': ['Dm', 'G', 'C', 'Am'],
      'I-VI-ii-V (Jazz Major)': ['C', 'A', 'Dm', 'G'],
      'iii-vi-ii-V (Jazz Minor)': ['Em', 'Am', 'Dm', 'G'],
      'I-IV-iii-vi (Jazz Modal)': ['C', 'F', 'Em', 'Am'],
      'ii-V-I-IV (Jazz Extended)': ['Dm', 'G', 'C', 'F'],
      'I-vi-ii-V (Jazz Classic)': ['C', 'Am', 'Dm', 'G']
    };
    
    let html = `<h4>üé∑ Jazz-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#17a2b8; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Sophisticated Jazz-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Miles Davis, John Coltrane, Herbie Hancock</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playJazzProgression()" class="btn">üé∑ Jazz abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showBluesProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Blues Basic)': ['C', 'F', 'G'],
      'I-IV-I-V (Blues 12-Bar)': ['C', 'F', 'C', 'G'],
      'I-IV-vi-V (Blues Rock)': ['C', 'F', 'Am', 'G'],
      'i-IV-V (Blues Minor)': ['Cm', 'Fm', 'Gm'],
      'I-IV-V (Blues Shuffle)': ['E', 'A', 'B'],
      'I-IV-I-V (Blues Turnaround)': ['C', 'F', 'C', 'G'],
      'ii-V-I (Blues Jazz)': ['Dm', 'G', 'C'],
      'I-vi-ii-V (Blues Extended)': ['C', 'Am', 'Dm', 'G']
    };
    
    let html = `<h4>üé∏ Blues-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#007bff; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Authentische Blues-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: B.B. King, Eric Clapton, Stevie Ray Vaughan</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playBluesProgression()" class="btn">üé∏ Blues abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showPopProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V-vi-IV (Pop Basic)': ['C', 'G', 'Am', 'F'],
      'vi-IV-I-V (Pop Alternative)': ['Am', 'F', 'C', 'G'],
      'I-IV-vi-V (Pop Rock)': ['C', 'F', 'Am', 'G'],
      'ii-V-I (Pop Jazz)': ['Dm', 'G', 'C'],
      'I-vi-ii-V (Pop Jazz)': ['C', 'Am', 'Dm', 'G'],
      'vi-IV-I-V (Pop Emo)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (Pop Classic)': ['C', 'G', 'Am', 'F'],
      'ii-V-I-vi (Pop Turnaround)': ['Dm', 'G', 'C', 'Am']
    };
    
    let html = `<h4>üé§ Pop-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#e83e8c; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Moderne Pop-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Taylor Swift, Ed Sheeran, Adele</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playPopProgression()" class="btn">üé§ Pop abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showCountryProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Country Basic)': ['G', 'C', 'D'],
      'I-V-vi-IV (Country Pop)': ['G', 'D', 'Em', 'C'],
      'vi-IV-I-V (Country Alternative)': ['Em', 'C', 'G', 'D'],
      'I-IV-vi-V (Country Rock)': ['G', 'C', 'Em', 'D'],
      'ii-V-I (Country Jazz)': ['Am', 'D', 'G'],
      'I-vi-ii-V (Country Jazz)': ['G', 'Em', 'Am', 'D'],
      'I-IV-I-V (Country Turnaround)': ['G', 'C', 'G', 'D'],
      'vi-IV-I-V (Country Ballad)': ['Em', 'C', 'G', 'D']
    };
    
    let html = `<h4>ü§† Country-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#28a745; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Authentische Country-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Johnny Cash, Dolly Parton, Willie Nelson</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playCountryProgression()" class="btn">ü§† Country abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showReggaeProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V (Reggae Basic)': ['C', 'G'],
      'I-IV (Reggae Simple)': ['C', 'F'],
      'I-IV-V (Reggae Rock)': ['C', 'F', 'G'],
      'vi-IV-I-V (Reggae Pop)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (Reggae Alternative)': ['C', 'G', 'Am', 'F'],
      'ii-V-I (Reggae Jazz)': ['Dm', 'G', 'C'],
      'I-vi-ii-V (Reggae Jazz)': ['C', 'Am', 'Dm', 'G'],
      'I-IV-vi-V (Reggae Rock)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üå¥ Reggae-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#fd7e14; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Entspannende Reggae-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Bob Marley, Peter Tosh, Toots & Maytals</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playReggaeProgression()" class="btn">üå¥ Reggae abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showMetalProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'i-VI-III-VII (Metal Minor)': ['Em', 'C', 'G', 'D'],
      'i-VI-III-VII (Metal Dark)': ['Am', 'F', 'C', 'G'],
      'i-VI-III-VII (Metal Thrash)': ['Bm', 'G', 'D', 'A'],
      'i-VI-III-VII (Metal Death)': ['Cm', 'Ab', 'Eb', 'Bb'],
      'i-VI-III-VII (Metal Black)': ['Dm', 'Bb', 'F', 'C'],
      'i-VI-III-VII (Metal Power)': ['Em', 'C', 'G', 'D'],
      'i-VI-III-VII (Metal Progressive)': ['F#m', 'D', 'A', 'E'],
      'i-VI-III-VII (Metal Symphonic)': ['Gm', 'Eb', 'Bb', 'F']
    };
    
    let html = `<h4>üî• Metal-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#343a40; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Intensive Metal-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Metallica, Iron Maiden, Black Sabbath</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playMetalProgression()" class="btn">üî• Metal abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  function showElectronicProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'i-VI-III-VII (Electronic Minor)': ['Am', 'F', 'C', 'G'],
      'i-VI-III-VII (Electronic Dark)': ['Dm', 'Bb', 'F', 'C'],
      'i-VI-III-VII (Electronic Ambient)': ['Em', 'C', 'G', 'D'],
      'i-VI-III-VII (Electronic House)': ['Bm', 'G', 'D', 'A'],
      'i-VI-III-VII (Electronic Drum & Bass)': ['Cm', 'Ab', 'Eb', 'Bb'],
      'i-VI-III-VII (Electronic IDM)': ['Gm', 'Eb', 'Bb', 'F'],
      'i-VI-III-VII (Electronic Synthwave)': ['F#m', 'D', 'A', 'E'],
      'i-VI-III-VII (Electronic Future Bass)': ['Abm', 'Fb', 'Cb', 'Gb']
    };
    
    let html = `<h4>üéõÔ∏è Electronic-Progressionen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#6f42c1; border-radius:8px; color:#fff;">`;
    html += `<p><strong>Moderne Electronic-Progressionen:</strong></p>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px; color:#ffc107;">${chords.join(' ‚Üí ')}</span>`;
      html += `<br><small style="color:#ffc107;">Typisch f√ºr: Daft Punk, The Chemical Brothers, Aphex Twin</small>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    html += `<button onclick="playElectronicProgression()" class="btn">üéõÔ∏è Electronic abspielen</button>`;
    html += `</div>`;
    
    progressionAnalysis.innerHTML = html;
  }
  
  // Progression-Playback-Funktionen
  function playProgressionExample() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['C4', 'F4', 'G4', 'C4'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playFolkProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['G3', 'D4', 'G3', 'C4', 'D4'];
    const timing = ['0', '1n', '2n', '3n', '4n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playPunkProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['E3', 'A3', 'B3', 'E3'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '1n', `+${timing[index]}`);
    });
  }
  
  function playTechnoProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['Am3', 'F4', 'C4', 'G4'];
    const timing = ['0', '2n', '4n', '6n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playRockProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['E3', 'A3', 'B3', 'E3'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playJazzProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['Dm3', 'G3', 'C4', 'Am3'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  // Alle neuen Genre-Funktionen hinzuf√ºgen
  function showPolkaProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Polka)': ['C', 'F', 'G'],
      'I-V-I (Polka)': ['C', 'G', 'C'],
      'I-IV-I-V (Polka)': ['C', 'F', 'C', 'G'],
      'ii-V-I (Polka)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Polka)': ['C', 'Am', 'F', 'G']
    };
    
    let html = `<h4>üé™ Polka Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showSkaProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V (Ska)': ['C', 'F', 'G'],
      'I-vi-IV-V (Ska)': ['C', 'Am', 'F', 'G'],
      'ii-V-I (Ska)': ['Dm', 'G', 'C'],
      'I-V-vi-IV (Ska)': ['C', 'G', 'Am', 'F'],
      'vi-IV-I-V (Ska)': ['Am', 'F', 'C', 'G']
    };
    
    let html = `<h4>üé∫ Ska Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showFunkProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV (Funk)': ['C', 'F'],
      'I-V (Funk)': ['C', 'G'],
      'ii-V-I (Funk)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Funk)': ['C', 'Am', 'F', 'G'],
      'I-IV-vi-V (Funk)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üé∑ Funk Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showSoulProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-vi-IV-V (Soul)': ['C', 'Am', 'F', 'G'],
      'ii-V-I (Soul)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (Soul)': ['C', 'F', 'Am', 'G'],
      'vi-IV-I-V (Soul)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (Soul)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üí´ Soul Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showRnbProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-vi-IV-V (R&B)': ['C', 'Am', 'F', 'G'],
      'ii-V-I (R&B)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (R&B)': ['C', 'F', 'Am', 'G'],
      'vi-IV-I-V (R&B)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (R&B)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üé§ R&B Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showHiphopProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV (Hip-Hop)': ['C', 'F'],
      'I-V (Hip-Hop)': ['C', 'G'],
      'ii-V-I (Hip-Hop)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Hip-Hop)': ['C', 'Am', 'F', 'G'],
      'I-IV-vi-V (Hip-Hop)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üé§ Hip-Hop Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showDiscoProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-vi-IV-V (Disco)': ['C', 'Am', 'F', 'G'],
      'ii-V-I (Disco)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (Disco)': ['C', 'F', 'Am', 'G'],
      'vi-IV-I-V (Disco)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (Disco)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üíÉ Disco Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showHouseProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV (House)': ['C', 'F'],
      'I-V (House)': ['C', 'G'],
      'ii-V-I (House)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (House)': ['C', 'Am', 'F', 'G'],
      'I-IV-vi-V (House)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üè† House Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showTranceProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V-vi-IV (Trance)': ['C', 'G', 'Am', 'F'],
      'vi-IV-I-V (Trance)': ['Am', 'F', 'C', 'G'],
      'I-vi-ii-V (Trance)': ['C', 'Am', 'Dm', 'G'],
      'ii-V-I (Trance)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (Trance)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üåÄ Trance Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showDubstepProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV (Dubstep)': ['C', 'F'],
      'I-V (Dubstep)': ['C', 'G'],
      'ii-V-I (Dubstep)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Dubstep)': ['C', 'Am', 'F', 'G'],
      'I-IV-vi-V (Dubstep)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üéµ Dubstep Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showAmbientProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-vi (Ambient)': ['C', 'Am'],
      'I-IV (Ambient)': ['C', 'F'],
      'ii-V-I (Ambient)': ['Dm', 'G', 'C'],
      'I-vi-IV (Ambient)': ['C', 'Am', 'F'],
      'vi-IV-I (Ambient)': ['Am', 'F', 'C']
    };
    
    let html = `<h4>üåå Ambient Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showClassicalProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V-I (Klassisch)': ['C', 'F', 'G', 'C'],
      'ii-V-I (Klassisch)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Klassisch)': ['C', 'Am', 'F', 'G'],
      'vi-ii-V-I (Klassisch)': ['Am', 'Dm', 'G', 'C'],
      'I-V-vi-IV (Klassisch)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üéº Klassische Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showBaroqueProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-IV-V-I (Barock)': ['C', 'F', 'G', 'C'],
      'ii-V-I (Barock)': ['Dm', 'G', 'C'],
      'I-vi-IV-V (Barock)': ['C', 'Am', 'F', 'G'],
      'vi-ii-V-I (Barock)': ['Am', 'Dm', 'G', 'C'],
      'I-V-vi-IV (Barock)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üé≠ Barock Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showRomanticProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-vi-IV-V (Romantik)': ['C', 'Am', 'F', 'G'],
      'ii-V-I (Romantik)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (Romantik)': ['C', 'F', 'Am', 'G'],
      'vi-IV-I-V (Romantik)': ['Am', 'F', 'C', 'G'],
      'I-V-vi-IV (Romantik)': ['C', 'G', 'Am', 'F']
    };
    
    let html = `<h4>üíï Romantik Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showModernProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-V-vi-IV (Modern)': ['C', 'G', 'Am', 'F'],
      'vi-IV-I-V (Modern)': ['Am', 'F', 'C', 'G'],
      'I-vi-ii-V (Modern)': ['C', 'Am', 'Dm', 'G'],
      'ii-V-I (Modern)': ['Dm', 'G', 'C'],
      'I-IV-vi-V (Modern)': ['C', 'F', 'Am', 'G']
    };
    
    let html = `<h4>üé® Moderne Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function showExperimentalProgressions() {
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    
    const progressions = {
      'I-bII-I (Experimental)': ['C', 'Db', 'C'],
      'I-bIII-IV (Experimental)': ['C', 'Eb', 'F'],
      'I-bVI-bVII (Experimental)': ['C', 'Ab', 'Bb'],
      'I-#IV-I (Experimental)': ['C', 'F#', 'C'],
      'I-bII-bIII (Experimental)': ['C', 'Db', 'Eb']
    };
    
    let html = `<h4>üß™ Experimental Akkordfolgen</h4>`;
    
    Object.entries(progressions).forEach(([name, chords]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${chords.join(' ‚Üí ')}</span>`;
      html += `<div class="controls" style="margin-top:8px;">`;
      html += `<button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>`;
      html += `<button onclick="loadProgression(['${chords.join("','")}'])" class="btn">üìã Laden</button>`;
      html += `</div>`;
      html += `</div>`;
    });
    
    html += `<button onclick="showCommonProgressions()" class="btn">üîô Zur√ºck</button>`;
    progressionAnalysis.innerHTML = html;
  }
  
  function playBluesProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['C3', 'F3', 'G3', 'C4'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playPopProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['C4', 'G3', 'Am3', 'F3'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playCountryProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['G3', 'C4', 'D4', 'G3'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playReggaeProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['C3', 'G3', 'C4', 'F3'];
    const timing = ['0', '2n', '4n', '6n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  function playMetalProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['Em3', 'C4', 'G3', 'D4'];
    const timing = ['0', '1n', '2n', '3n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '1n', `+${timing[index]}`);
    });
  }
  
  function playElectronicProgression() {
    if (!window.Tone) return;
    
    const synth = new Tone.PolySynth().toDestination();
    const progression = ['Am3', 'F4', 'C4', 'G4'];
    const timing = ['0', '2n', '4n', '6n'];
    
    progression.forEach((note, index) => {
      synth.triggerAttackRelease(note, '2n', `+${timing[index]}`);
    });
  }
  
  // Waveframe Audio-Editor Funktionen
  function openWaveframe() {
    if (!dawActive) return;
    
    const waveframeEditor = document.getElementById('waveframeEditor');
    waveframeEditor.innerHTML = `
      <div style="display:flex; gap:20px; height:400px;">
        <div style="flex:1; border:1px solid #ccc; border-radius:8px; padding:15px; background:#fff;">
          <h4>üéº Waveform Editor</h4>
          <canvas id="waveformCanvas" width="600" height="200" style="border:1px solid #ddd; background:#000; cursor:crosshair;"></canvas>
          <div style="margin-top:15px;">
            <button onclick="zoomWaveform(2)" class="btn">üîç Zoom In</button>
            <button onclick="zoomWaveform(0.5)" class="btn">üîç Zoom Out</button>
            <button onclick="resetWaveformZoom()" class="btn">üîç Reset</button>
          </div>
        </div>
        <div style="flex:1; border:1px solid #ccc; border-radius:8px; padding:15px; background:#f8f9fa;">
          <h4>üéõÔ∏è Tools & Controls</h4>
          <div class="controls">
            <button onclick="selectWaveformTool('select')" class="btn">üëÜ Select</button>
            <button onclick="selectWaveformTool('cut')" class="btn">‚úÇÔ∏è Cut</button>
            <button onclick="selectWaveformTool('copy')" class="btn">üìã Copy</button>
            <button onclick="selectWaveformTool('paste')" class="btn">üìå Paste</button>
            <button onclick="selectWaveformTool('fade')" class="btn">üìà Fade</button>
            <button onclick="selectWaveformTool('normalize')" class="btn">üìä Normalize</button>
          </div>
          <div style="margin-top:15px;">
            <label>Gain: <input type="range" id="waveformGain" min="-20" max="20" value="0" step="0.1" onchange="adjustWaveformGain(this.value)"></label>
            <label>Pan: <input type="range" id="waveformPan" min="-1" max="1" value="0" step="0.1" onchange="adjustWaveformPan(this.value)"></label>
          </div>
        </div>
      </div>
      <div style="margin-top:15px; padding:15px; background:#e8f5e8; border-radius:8px;">
        <h4>üìä Audio Information</h4>
        <div id="audioInfo" style="font-family:monospace; font-size:14px;">
          <p>Laden Sie eine Audiodatei oder zeichnen Sie Audio auf...</p>
        </div>
      </div>
    `;
    
    // Canvas f√ºr Kontext-Men√º vorbereiten
    const canvas = document.getElementById('waveformCanvas');
    if (canvas) {
      canvas.addEventListener('contextmenu', showWaveframeContextMenu);
      canvas.addEventListener('mousedown', handleWaveformMouseDown);
      canvas.addEventListener('mousemove', handleWaveformMouseMove);
      canvas.addEventListener('mouseup', handleWaveformMouseUp);
    }
    
    // Standard-Tool aktivieren
    currentWaveformTool = 'select';
    updateWaveformCursor();
  }
  
  // Waveframe Tool-Funktionen
  let currentWaveformTool = 'select';
  let waveformSelection = { start: 0, end: 0, active: false };
  let waveformZoom = 1;
  let waveformOffset = 0;
  
  function selectWaveformTool(tool) {
    currentWaveformTool = tool;
    updateWaveformCursor();
    
    // Tool-spezifische UI aktualisieren
    const canvas = document.getElementById('waveformCanvas');
    if (canvas) {
      switch (tool) {
        case 'select':
          canvas.style.cursor = 'crosshair';
          break;
        case 'cut':
          canvas.style.cursor = 'crosshair';
          break;
        case 'copy':
          canvas.style.cursor = 'crosshair';
          break;
        case 'paste':
          canvas.style.cursor = 'crosshair';
          break;
        case 'fade':
          canvas.style.cursor = 'ns-resize';
          break;
        case 'normalize':
          canvas.style.cursor = 'default';
          break;
      }
    }
  }
  
  function updateWaveformCursor() {
    const canvas = document.getElementById('waveformCanvas');
    if (!canvas) return;
    
    switch (currentWaveformTool) {
      case 'select':
        canvas.style.cursor = 'crosshair';
        break;
      case 'cut':
        canvas.style.cursor = 'crosshair';
        break;
      case 'copy':
        canvas.style.cursor = 'crosshair';
        break;
      case 'paste':
        canvas.style.cursor = 'crosshair';
        break;
      case 'fade':
        canvas.style.cursor = 'ns-resize';
        break;
      case 'normalize':
        canvas.style.cursor = 'default';
        break;
    }
  }
  
  function zoomWaveform(factor) {
    waveformZoom *= factor;
    waveformZoom = Math.max(0.1, Math.min(10, waveformZoom));
    redrawWaveform();
  }
  
  function resetWaveformZoom() {
    waveformZoom = 1;
    waveformOffset = 0;
    redrawWaveform();
  }
  
  function redrawWaveform() {
    const canvas = document.getElementById('waveformCanvas');
    if (!canvas || !currentAudioBuffer) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Canvas l√∂schen
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    
    // Waveform zeichnen
    if (currentAudioBuffer) {
      const data = currentAudioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / (width * waveformZoom));
      const amp = height / 2;
      
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 1;
      ctx.beginPath();
      
      for (let i = 0; i < width; i++) {
        const dataIndex = Math.floor(i * step * waveformZoom + waveformOffset);
        if (dataIndex < data.length) {
          const x = i;
          const y = (data[dataIndex] * amp) + amp;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
      }
      
      ctx.stroke();
      
      // Selection zeichnen
      if (waveformSelection.active) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
        const startX = (waveformSelection.start / waveformZoom) - waveformOffset;
        const endX = (waveformSelection.end / waveformZoom) - waveformOffset;
        ctx.fillRect(startX, 0, endX - startX, height);
      }
    }
  }
  
  function handleWaveformMouseDown(e) {
    const canvas = document.getElementById('waveformCanvas');
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    
    switch (currentWaveformTool) {
      case 'select':
        waveformSelection.start = x * waveformZoom + waveformOffset;
        waveformSelection.end = waveformSelection.start;
        waveformSelection.active = true;
        break;
      case 'cut':
        waveformSelection.start = x * waveformZoom + waveformOffset;
        waveformSelection.end = waveformSelection.start;
        waveformSelection.active = true;
        break;
      case 'copy':
        waveformSelection.start = x * waveformZoom + waveformOffset;
        waveformSelection.end = waveformSelection.start;
        waveformSelection.active = true;
        break;
    }
    
    redrawWaveform();
  }
  
  function handleWaveformMouseMove(e) {
    if (!waveformSelection.active) return;
    
    const canvas = document.getElementById('waveformCanvas');
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    
    waveformSelection.end = x * waveformZoom + waveformOffset;
    redrawWaveform();
  }
  
  function handleWaveformMouseUp(e) {
    if (!waveformSelection.active) return;
    
    // Selection finalisieren
    if (waveformSelection.start > waveformSelection.end) {
      [waveformSelection.start, waveformSelection.end] = [waveformSelection.end, waveformSelection.start];
    }
    
    // Tool-spezifische Aktionen
    switch (currentWaveformTool) {
      case 'select':
        // Selection f√ºr weitere Bearbeitung vorbereiten
        break;
      case 'cut':
        cutWaveformSelection();
        break;
      case 'copy':
        copyWaveformSelection();
        break;
    }
    
    waveformSelection.active = false;
    redrawWaveform();
  }
  
  function cutWaveformSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    
    // Audio in Clipboard kopieren
    const selectionLength = endSample - startSample;
    const selectionBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      selectionLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionData = selectionBuffer.getChannelData(channel);
      for (let i = 0; i < selectionLength; i++) {
        selectionData[i] = channelData[startSample + i];
      }
    }
    
    // In globalen Clipboard speichern
    window.waveformClipboard = selectionBuffer;
    
    // Selection aus Original entfernen (durch Stille ersetzen)
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        channelData[i] = 0;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function copyWaveformSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    
    // Audio in Clipboard kopieren
    const selectionLength = endSample - startSample;
    const selectionBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      selectionLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionData = selectionBuffer.getChannelData(channel);
      for (let i = 0; i < selectionLength; i++) {
        selectionData[i] = channelData[startSample + i];
      }
    }
    
    // In globalen Clipboard speichern
    window.waveformClipboard = selectionBuffer;
    
    updateAudioInfo();
  }
  
  function pasteWaveformAtCursor() {
    if (!currentAudioBuffer || !window.waveformClipboard) return;
    
    const canvas = document.getElementById('waveformCanvas');
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const centerX = rect.width / 2;
    const cursorSample = Math.floor((centerX * waveformZoom + waveformOffset) * currentAudioBuffer.sampleRate);
    
    const clipboardBuffer = window.waveformClipboard;
    const pasteLength = clipboardBuffer.length;
    
    // Neuen Buffer mit eingef√ºgtem Audio erstellen
    const newBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      currentAudioBuffer.length + pasteLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const originalData = currentAudioBuffer.getChannelData(channel);
      const clipboardData = clipboardBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // Audio vor dem Cursor kopieren
      for (let i = 0; i < cursorSample; i++) {
        newData[i] = originalData[i];
      }
      
      // Clipboard-Audio einf√ºgen
      for (let i = 0; i < pasteLength; i++) {
        newData[cursorSample + i] = clipboardData[i];
      }
      
      // Audio nach dem Cursor kopieren
      for (let i = 0; i < currentAudioBuffer.length - cursorSample; i++) {
        newData[cursorSample + pasteLength + i] = originalData[cursorSample + i];
      }
    }
    
    currentAudioBuffer = newBuffer;
    redrawWaveform();
    updateAudioInfo();
  }
  
  function adjustWaveformGain(value) {
    if (!currentAudioBuffer) return;
    
    const gainDb = parseFloat(value);
    const gainLinear = Math.pow(10, gainDb / 20);
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = 0; i < channelData.length; i++) {
        channelData[i] *= gainLinear;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function adjustWaveformPan(value) {
    if (!currentAudioBuffer || currentAudioBuffer.numberOfChannels < 2) return;
    
    const pan = parseFloat(value);
    
    // Stereo-Panning anwenden
    const leftChannel = currentAudioBuffer.getChannelData(0);
    const rightChannel = currentAudioBuffer.getChannelData(1);
    
    for (let i = 0; i < leftChannel.length; i++) {
      const leftGain = Math.cos((pan + 1) * Math.PI / 4);
      const rightGain = Math.sin((pan + 1) * Math.PI / 4);
      
      leftChannel[i] *= leftGain;
      rightChannel[i] *= rightGain;
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function showWaveframeTools() {
    const waveframeEditor = document.getElementById('waveframeEditor');
    if (!waveframeEditor) return;
    
    let html = `<h4>üõ†Ô∏è Waveframe Tools</h4>`;
    html += `<div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:15px; margin:15px 0;">`;
    
    const tools = [
      { name: 'Select', icon: 'üëÜ', desc: 'Auswahl von Audio-Bereichen' },
      { name: 'Cut', icon: '‚úÇÔ∏è', desc: 'Audio-Bereiche ausschneiden' },
      { name: 'Copy', icon: 'üìã', desc: 'Audio-Bereiche kopieren' },
      { name: 'Paste', icon: 'üìå', desc: 'Audio an Cursor einf√ºgen' },
      { name: 'Fade', icon: 'üìà', desc: 'Ein- und Ausblenden' },
      { name: 'Normalize', icon: 'üìä', desc: 'Lautst√§rke normalisieren' },
      { name: 'Reverse', icon: '‚è™', desc: 'Audio umkehren' },
      { name: 'Time Stretch', icon: '‚è±Ô∏è', desc: 'Zeitstreckung' },
      { name: 'Pitch Shift', icon: 'üéµ', desc: 'Tonh√∂he √§ndern' }
    ];
    
    tools.forEach(tool => {
      html += `<div style="padding:15px; border:1px solid #ddd; border-radius:8px; background:#fff;">`;
      html += `<h5>${tool.icon} ${tool.name}</h5>`;
      html += `<p style="font-size:14px; color:#666;">${tool.desc}</p>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="openWaveframe()" class="btn">üîô Zur√ºck zum Editor</button>`;
    html += `</div>`;
    
    waveframeEditor.innerHTML = html;
  }
  
  function showWaveframeContextMenu() {
    const contextMenu = document.createElement('div');
    contextMenu.id = 'waveframeContextMenu';
    contextMenu.style.cssText = `
      position: fixed;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 5px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      font-size: 14px;
    `;
    
    const menuItems = [
      { text: '‚úÇÔ∏è Ausschneiden', action: () => cutWaveformSelection() },
      { text: 'üìã Kopieren', action: () => copyWaveformSelection() },
      { text: 'üìå Einf√ºgen', action: () => pasteWaveformAtCursor() },
      { text: 'üóëÔ∏è L√∂schen', action: () => deleteWaveformSelection() },
      { text: 'üìä Normalisieren', action: () => normalizeWaveformSelection() },
      { text: 'üìà Fade In', action: () => applyFadeIn() },
      { text: 'üìâ Fade Out', action: () => applyFadeOut() },
      { text: '‚è™ Umkehren', action: () => reverseWaveformSelection() },
      { text: 'üéµ Pitch Shift', action: () => pitchShiftSelection() },
      { text: '‚è±Ô∏è Time Stretch', action: () => timeStretchSelection() }
    ];
    
    menuItems.forEach(item => {
      const menuItem = document.createElement('div');
      menuItem.textContent = item.text;
      menuItem.style.cssText = `
        padding: 8px 15px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      `;
      menuItem.addEventListener('mouseenter', () => {
        menuItem.style.background = '#f0f0f0';
      });
      menuItem.addEventListener('mouseleave', () => {
        menuItem.style.background = '#fff';
      });
      menuItem.addEventListener('click', () => {
        item.action();
        document.body.removeChild(contextMenu);
      });
      contextMenu.appendChild(menuItem);
    });
    
    // Letztes Element ohne Border
    const lastItem = contextMenu.lastChild;
    if (lastItem) {
      lastItem.style.borderBottom = 'none';
    }
    
    // Position setzen
    contextMenu.style.left = event.pageX + 'px';
    contextMenu.style.top = event.pageY + 'px';
    
    // Event-Listener f√ºr Schlie√üen
    document.addEventListener('click', () => {
      if (document.body.contains(contextMenu)) {
        document.body.removeChild(contextMenu);
      }
    });
    
    document.body.appendChild(contextMenu);
    event.preventDefault();
  }
  
  function setupWaveframeShortcuts() {
    const waveframeEditor = document.getElementById('waveframeEditor');
    if (!waveframeEditor) return;
    
    let html = `<h4>‚å®Ô∏è Waveframe Tastenk√ºrzel</h4>`;
    html += `<div style="display:grid; grid-template-columns: repeat(2, 1fr); gap:15px; margin:15px 0;">`;
    
    const shortcuts = [
      { key: 'Ctrl+A', action: 'Alles ausw√§hlen' },
      { key: 'Ctrl+C', action: 'Kopieren' },
      { key: 'Ctrl+X', action: 'Ausschneiden' },
      { key: 'Ctrl+V', action: 'Einf√ºgen' },
      { key: 'Delete', action: 'L√∂schen' },
      { key: 'Ctrl+Z', action: 'R√ºckg√§ngig' },
      { key: 'Ctrl+Y', action: 'Wiederholen' },
      { key: 'Space', action: 'Play/Pause' },
      { key: 'Home', action: 'Zum Anfang' },
      { key: 'End', action: 'Zum Ende' },
      { key: '‚Üê ‚Üí', action: 'Frame vor/zur√ºck' },
      { key: 'Shift+‚Üê ‚Üí', action: 'Gro√üe Spr√ºnge' }
    ];
    
    shortcuts.forEach(shortcut => {
      html += `<div style="padding:10px; border:1px solid #ddd; border-radius:8px; background:#fff;">`;
      html += `<strong>${shortcut.key}</strong><br>`;
      html += `<span style="font-size:14px; color:#666;">${shortcut.action}</span>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="openWaveframe()" class="btn">üîô Zur√ºck zum Editor</button>`;
    html += `</div>`;
    
    waveframeEditor.innerHTML = html;
  }
  
  // Zus√§tzliche Waveframe-Funktionen
  function deleteWaveformSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    
    // Selection durch Stille ersetzen
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        channelData[i] = 0;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function normalizeWaveformSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    
    // Maximum in Selection finden
    let maxAmplitude = 0;
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        maxAmplitude = Math.max(maxAmplitude, Math.abs(channelData[i]));
      }
    }
    
    if (maxAmplitude > 0) {
      // Normalisieren auf -1dB
      const targetLevel = 0.89; // -1dB
      const gain = targetLevel / maxAmplitude;
      
      for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
        const channelData = currentAudioBuffer.getChannelData(channel);
        for (let i = startSample; i < endSample; i++) {
          channelData[i] *= gain;
        }
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function applyFadeIn() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    const fadeLength = endSample - startSample;
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = 0; i < fadeLength; i++) {
        const fadeGain = i / fadeLength;
        channelData[startSample + i] *= fadeGain;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function applyFadeOut() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    const fadeLength = endSample - startSample;
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = 0; i < fadeLength; i++) {
        const fadeGain = (fadeLength - i) / fadeLength;
        channelData[startSample + i] *= fadeGain;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function reverseWaveformSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionLength = endSample - startSample;
      
      // Selection umkehren
      for (let i = 0; i < selectionLength / 2; i++) {
        const temp = channelData[startSample + i];
        channelData[startSample + i] = channelData[endSample - 1 - i];
        channelData[endSample - 1 - i] = temp;
      }
    }
    
    redrawWaveform();
    updateAudioInfo();
  }
  
  function pitchShiftSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    const selectionLength = endSample - startSample;
    
    // Einfacher Pitch-Shift durch Interpolation
    const pitchFactor = 1.2; // 2 Halbt√∂ne h√∂her
    const newLength = Math.floor(selectionLength / pitchFactor);
    
    const newBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      currentAudioBuffer.length - selectionLength + newLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const originalData = currentAudioBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // Audio vor der Selection kopieren
      for (let i = 0; i < startSample; i++) {
        newData[i] = originalData[i];
      }
      
      // Pitch-shifted Selection einf√ºgen
      for (let i = 0; i < newLength; i++) {
        const originalIndex = startSample + Math.floor(i * pitchFactor);
        if (originalIndex < endSample) {
          newData[startSample + i] = originalData[originalIndex];
        }
      }
      
      // Audio nach der Selection kopieren
      for (let i = 0; i < currentAudioBuffer.length - endSample; i++) {
        newData[startSample + newLength + i] = originalData[endSample + i];
      }
    }
    
    currentAudioBuffer = newBuffer;
    redrawWaveform();
    updateAudioInfo();
  }
  
  function timeStretchSelection() {
    if (!currentAudioBuffer || !waveformSelection.active) return;
    
    const startSample = Math.floor(waveformSelection.start * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(waveformSelection.end * currentAudioBuffer.sampleRate);
    const selectionLength = endSample - startSample;
    
    // Einfache Zeitstreckung durch Interpolation
    const stretchFactor = 1.5; // 50% l√§nger
    const newLength = Math.floor(selectionLength * stretchFactor);
    
    const newBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      currentAudioBuffer.length - selectionLength + newLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const originalData = currentAudioBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // Audio vor der Selection kopieren
      for (let i = 0; i < startSample; i++) {
        newData[i] = originalData[i];
      }
      
      // Zeitgestreckte Selection einf√ºgen
      for (let i = 0; i < newLength; i++) {
        const originalIndex = startSample + Math.floor(i / stretchFactor);
        if (originalIndex < endSample) {
          newData[startSample + i] = originalData[originalIndex];
        }
      }
      
      // Audio nach der Selection kopieren
      for (let i = 0; i < currentAudioBuffer.length - endSample; i++) {
        newData[startSample + newLength + i] = originalData[endSample + i];
      }
    }
    
    currentAudioBuffer = newBuffer;
    redrawWaveform();
    updateAudioInfo();
  }
  
  function updateAudioInfo() {
    const audioInfo = document.getElementById('audioInfo');
    if (!audioInfo || !currentAudioBuffer) return;
    
    const duration = currentAudioBuffer.duration;
    const sampleRate = currentAudioBuffer.sampleRate;
    const channels = currentAudioBuffer.numberOfChannels;
    const length = currentAudioBuffer.length;
    
    let html = `<p><strong>Dauer:</strong> ${duration.toFixed(2)}s</p>`;
    html += `<p><strong>Sample Rate:</strong> ${sampleRate} Hz</p>`;
    html += `<p><strong>Kan√§le:</strong> ${channels}</p>`;
    html += `<p><strong>Samples:</strong> ${length.toLocaleString()}</p>`;
    
    if (waveformSelection.active) {
      const selectionStart = waveformSelection.start;
      const selectionEnd = waveformSelection.end;
      const selectionDuration = (selectionEnd - selectionStart).toFixed(2);
      html += `<p><strong>Auswahl:</strong> ${selectionStart.toFixed(2)}s - ${selectionEnd.toFixed(2)}s (${selectionDuration}s)</p>`;
    }
    
    audioInfo.innerHTML = html;
  }
  
  // Multi-Track Recording System
  let multiTrackTracks = [];
  let currentRecordingTrack = null;
  let recordingStartTime = 0;
  
  function openMultiTrack() {
    if (!dawActive) return;
    
    const multiTrackEditor = document.getElementById('multiTrackEditor');
    multiTrackEditor.innerHTML = `
      <div style="display:flex; flex-direction:column; gap:15px;">
        <div style="display:flex; justify-content:space-between; align-items:center; padding:10px; background:#e8f5e8; border-radius:8px;">
          <h4>üéõÔ∏è Multi-Track Recording Studio</h4>
          <div>
            <span id="recordingStatus" style="padding:5px 10px; border-radius:15px; background:#ffebee; color:#c62828;">‚è∏ Nicht aufnehmend</span>
          </div>
        </div>
        
        <div id="tracksContainer" style="border:1px solid #ddd; border-radius:8px; padding:15px; background:#fff; min-height:300px;">
          <p>Keine Tracks vorhanden. F√ºgen Sie einen Track hinzu...</p>
        </div>
        
        <div style="display:flex; gap:10px; justify-content:center;">
          <button onclick="addTrack()" class="btn">‚ûï Track hinzuf√ºgen</button>
          <button onclick="recordTrack()" class="btn" id="recordButton">üî¥ Aufnehmen</button>
                      <button onclick="stopRecording()" class="btn" id="stopButton">‚èπ Stoppen</button>
          <button onclick="playAllTracks()" class="btn">‚ñ∂Ô∏è Alle abspielen</button>
          <button onclick="stopAllTracks()" class="btn">‚èπ Alle stoppen</button>
          <button onclick="mixdownTracks()" class="btn">üéöÔ∏è Mixdown</button>
        </div>
      </div>
    `;
    
    updateTracksDisplay();
  }
  
  function addTrack() {
    const trackNumber = multiTrackTracks.length + 1;
    const newTrack = {
      id: Date.now(),
      name: `Track ${trackNumber}`,
      type: 'audio',
      buffer: null,
      gain: 1.0,
      pan: 0.0,
      mute: false,
      solo: false,
      color: getRandomTrackColor(),
      recording: false
    };
    
    multiTrackTracks.push(newTrack);
    updateTracksDisplay();
  }
  
  function getRandomTrackColor() {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  function updateTracksDisplay() {
    const tracksContainer = document.getElementById('tracksContainer');
    if (!tracksContainer) return;
    
    if (multiTrackTracks.length === 0) {
      tracksContainer.innerHTML = '<p>Keine Tracks vorhanden. F√ºgen Sie einen Track hinzu...</p>';
      return;
    }
    
    let html = '<div style="display:flex; flex-direction:column; gap:10px;">';
    
    multiTrackTracks.forEach((track, index) => {
      html += `
        <div style="display:flex; align-items:center; gap:15px; padding:15px; border:1px solid #ddd; border-radius:8px; background:#fff;">
          <div style="width:30px; height:30px; border-radius:50%; background:${track.color}; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:bold;">
            ${index + 1}
          </div>
          
          <div style="flex:1;">
            <input type="text" value="${track.name}" onchange="updateTrackName(${track.id}, this.value)" style="border:none; background:transparent; font-weight:bold; width:100%;">
            <div style="font-size:12px; color:#666;">
              ${track.buffer ? `${track.buffer.duration.toFixed(2)}s` : 'Kein Audio'} | 
              ${track.recording ? 'üî¥ Aufnahme' : '‚è∏ Bereit'}
            </div>
          </div>
          
          <div style="display:flex; align-items:center; gap:10px;">
            <label style="font-size:12px;">Gain:</label>
            <input type="range" min="0" max="2" step="0.1" value="${track.gain}" 
                   onchange="updateTrackGain(${track.id}, this.value)" style="width:80px;">
            <span style="font-size:12px; min-width:30px;">${track.gain.toFixed(1)}</span>
            
            <label style="font-size:12px;">Pan:</label>
            <input type="range" min="-1" max="1" step="0.1" value="${track.pan}" 
                   onchange="updateTrackPan(${track.id}, this.value)" style="width:80px;">
            <span style="font-size:12px; min-width:30px;">${track.pan.toFixed(1)}</span>
            
            <button onclick="toggleTrackMute(${track.id})" class="btn" style="background:${track.mute ? '#ff6b6b' : '#6c757d'}; color:#fff;">
              ${track.mute ? 'üîá' : 'üîä'}
            </button>
            
            <button onclick="toggleTrackSolo(${track.id})" class="btn" style="background:${track.solo ? '#ffd93d' : '#6c757d'}; color:#fff;">
              ${track.solo ? 'üéµ' : 'üéµ'}
            </button>
            
            <button onclick="deleteTrack(${track.id})" class="btn" style="background:#dc3545; color:#fff;">üóëÔ∏è</button>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    tracksContainer.innerHTML = html;
  }
  
  function updateTrackName(trackId, newName) {
    const track = multiTrackTracks.find(t => t.id === trackId);
    if (track) {
      track.name = newName;
    }
  }
  
  function updateTrackGain(trackId, gain) {
    const track = multiTrackTracks.find(t => t.id === trackId);
    if (track) {
      track.gain = parseFloat(gain);
    }
  }
  
  function updateTrackPan(trackId, pan) {
    const track = multiTrackTracks.find(t => t.id === trackId);
    if (track) {
      track.pan = parseFloat(pan);
    }
  }
  
  function toggleTrackMute(trackId) {
    const track = multiTrackTracks.find(t => t.id === trackId);
    if (track) {
      track.mute = !track.mute;
      updateTracksDisplay();
    }
  }
  
  function toggleTrackSolo(trackId) {
    const track = multiTrackTracks.find(t => t.id === trackId);
    if (track) {
      track.solo = !track.solo;
      
      // Alle anderen Tracks auf mute setzen wenn Solo aktiv
      if (track.solo) {
        multiTrackTracks.forEach(t => {
          if (t.id !== trackId) t.mute = true;
        });
      } else {
        // Alle Tracks unmute wenn kein Solo mehr aktiv
        const hasSolo = multiTrackTracks.some(t => t.solo);
        if (!hasSolo) {
          multiTrackTracks.forEach(t => t.mute = false);
        }
      }
      
      updateTracksDisplay();
    }
  }
  
  function deleteTrack(trackId) {
    const index = multiTrackTracks.findIndex(t => t.id === trackId);
    if (index !== -1) {
      multiTrackTracks.splice(index, 1);
      updateTracksDisplay();
    }
  }
  
  function recordTrack() {
    if (isRecording) return;
    
    // Verf√ºgbaren Track f√ºr Aufnahme finden
    const availableTrack = multiTrackTracks.find(t => !t.buffer && !t.recording);
    if (!availableTrack) {
      alert('Kein freier Track f√ºr Aufnahme verf√ºgbar. F√ºgen Sie einen neuen Track hinzu.');
      return;
    }
    
    currentRecordingTrack = availableTrack;
    isRecording = true;
    recordingStartTime = Date.now();
    
    // UI aktualisieren
    const recordButton = document.getElementById('recordButton');
    const stopButton = document.getElementById('stopButton');
    const recordingStatus = document.getElementById('recordingStatus');
    
    if (recordButton) recordButton.style.display = 'none';
    if (stopButton) stopButton.style.display = 'inline-block';
    if (recordingStatus) {
      recordingStatus.textContent = 'üî¥ Aufnahme l√§uft...';
      recordingStatus.style.background = '#ffebee';
      recordingStatus.style.color = '#c62828';
    }
    
    // Aufnahme starten
    startRecording();
  }
  
  function stopRecording() {
    if (!isRecording) return;
    
    isRecording = false;
    
    // UI zur√ºcksetzen
    const recordButton = document.getElementById('recordButton');
    const stopButton = document.getElementById('stopButton');
    const recordingStatus = document.getElementById('recordingStatus');
    
    if (recordButton) recordButton.style.display = 'inline-block';
    if (stopButton) stopButton.style.display = 'none';
    if (recordingStatus) {
      recordingStatus.textContent = '‚è∏ Nicht aufnehmend';
      recordingStatus.style.background = '#e8f5e8';
      recordingStatus.style.color = '#2e7d32';
    }
    
    // Aufnahme stoppen
    stopRecording();
    
    if (currentRecordingTrack) {
      currentRecordingTrack.recording = false;
      currentRecordingTrack = null;
    }
    
    updateTracksDisplay();
  }
  
  function playAllTracks() {
    if (multiTrackTracks.length === 0) return;
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioContext.createGain();
    masterGain.connect(audioContext.destination);
    
    multiTrackTracks.forEach(track => {
      if (track.buffer && !track.mute) {
        const source = audioContext.createBufferSource();
        const trackGain = audioContext.createGain();
        const trackPan = audioContext.createStereoPanner();
        
        source.buffer = track.buffer;
        source.connect(trackGain);
        trackGain.connect(trackPan);
        trackPan.connect(masterGain);
        
        // Track-spezifische Einstellungen
        trackGain.gain.value = track.gain;
        trackPan.pan.value = track.pan;
        
        source.start();
      }
    });
  }
  
  function stopAllTracks() {
    // Alle Audio-Quellen stoppen
    if (window.currentAudioSources) {
      window.currentAudioSources.forEach(source => {
        try {
          source.stop();
        } catch (e) {
          // Source bereits gestoppt
        }
      });
    }
    window.currentAudioSources = [];
  }
  
  function mixdownTracks() {
    if (multiTrackTracks.length === 0) return;
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const offlineContext = new OfflineAudioContext(
      multiTrackTracks.length,
      getMaxTrackLength(),
      audioContext.sampleRate
    );
    
    const masterGain = offlineContext.createGain();
    masterGain.connect(offlineContext.destination);
    
    multiTrackTracks.forEach(track => {
      if (track.buffer && !track.mute) {
        const source = offlineContext.createBufferSource();
        const trackGain = offlineContext.createGain();
        const trackPan = offlineContext.createStereoPanner();
        
        source.buffer = track.buffer;
        source.connect(trackGain);
        trackGain.connect(trackPan);
        trackPan.connect(masterGain);
        
        // Track-spezifische Einstellungen
        trackGain.gain.value = track.gain;
        trackPan.pan.value = track.pan;
        
        source.start();
      }
    });
    
    offlineContext.startRendering().then(buffer => {
      // Mixdown als WAV exportieren
      const wavBlob = createWAVBlob(buffer);
      downloadWAV(wavBlob, 'mixdown.wav');
    });
  }
  
  function getMaxTrackLength() {
    let maxLength = 0;
    multiTrackTracks.forEach(track => {
      if (track.buffer) {
        maxLength = Math.max(maxLength, track.buffer.length);
      }
    });
    return maxLength;
  }
  
  // Song-Projekt-Manager
  let projectHistory = [];
  
  function createNewProject() {
    const projectName = prompt('Projektname eingeben:');
    if (!projectName) return;
    
    currentProject = {
      id: Date.now(),
      name: projectName,
      created: new Date().toISOString(),
      modified: new Date().toISOString(),
      tracks: [],
      settings: {
        tempo: 120,
        key: 'C',
        timeSignature: '4/4',
        sampleRate: 44100
      },
      metadata: {
        artist: '',
        album: '',
        genre: '',
        year: new Date().getFullYear(),
        notes: ''
      }
    };
    
    updateProjectDisplay();
    showProjectInfo();
  }
  
  function openProject() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,.ribw';
    input.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            currentProject = JSON.parse(e.target.result);
            updateProjectDisplay();
            showProjectInfo();
          } catch (error) {
            alert('Fehler beim Laden des Projekts: ' + error.message);
          }
        };
        reader.readAsText(file);
      }
    };
    input.click();
  }
  
  function saveProject() {
    if (!currentProject) {
      alert('Kein Projekt zum Speichern vorhanden.');
      return;
    }
    
    currentProject.modified = new Date().toISOString();
    currentProject.tracks = multiTrackTracks;
    
    const projectData = JSON.stringify(currentProject, null, 2);
    const blob = new Blob([projectData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${currentProject.name}.ribw`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // In Projekt-Historie speichern
    projectHistory.push({
      timestamp: new Date().toISOString(),
      action: 'saved',
      projectName: currentProject.name
    });
    
    updateProjectDisplay();
  }
  
  function exportProject() {
    if (!currentProject) {
      alert('Kein Projekt zum Exportieren vorhanden.');
      return;
    }
    
    // Alle Tracks als separate Dateien exportieren
    multiTrackTracks.forEach((track, index) => {
      if (track.buffer) {
        const wavBlob = createWAVBlob(track.buffer);
        downloadWAV(wavBlob, `${currentProject.name}_track_${index + 1}.wav`);
      }
    });
    
    // Projekt als MIDI exportieren
    exportProjectAsMIDI();
    
    // Projekt als ZIP exportieren
    exportProjectAsZIP();
  }
  
  function exportProjectAsMIDI() {
    if (!currentProject) return;
    
    // MIDI-Datei erstellen
    const midiData = createMIDIData();
    const midiBlob = new Blob([midiData], { type: 'audio/midi' });
    const url = URL.createObjectURL(midiBlob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${currentProject.name}.mid`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function createMIDIData() {
    // Einfache MIDI-Datei erstellen
    const midiHeader = new Uint8Array([
      0x4D, 0x54, 0x68, 0x64, // MThd
      0x00, 0x00, 0x00, 0x06, // Header length
      0x00, 0x01, // Format 1
      0x00, 0x01, // 1 track
      0x01, 0xE0  // 480 ticks per quarter note
    ]);
    
    const midiTrack = new Uint8Array([
      0x4D, 0x54, 0x72, 0x6B, // MTrk
      0x00, 0x00, 0x00, 0x0B, // Track length
      0x00, 0xFF, 0x51, 0x03, 0x07, 0xA1, 0x20, // Tempo
      0x00, 0xFF, 0x2F, 0x00  // End of track
    ]);
    
    const combined = new Uint8Array(midiHeader.length + midiTrack.length);
    combined.set(midiHeader, 0);
    combined.set(midiTrack, midiHeader.length);
    
    return combined;
  }
  
  function exportProjectAsZIP() {
    // ZIP-Export w√ºrde hier implementiert werden
    alert('ZIP-Export wird in einer zuk√ºnftigen Version verf√ºgbar sein.');
  }
  
  function showProjectInfo() {
    if (!currentProject) {
      alert('Kein Projekt geladen.');
      return;
    }
    
    const projectManager = document.getElementById('projectManager');
    projectManager.innerHTML = `
      <div style="padding:15px; background:#e8f5e8; border-radius:8px;">
        <h4>‚ÑπÔ∏è Projekt-Informationen</h4>
        <div style="display:grid; grid-template-columns: repeat(2, 1fr); gap:15px; margin:15px 0;">
          <div>
            <p><strong>Name:</strong> ${currentProject.name}</p>
            <p><strong>Erstellt:</strong> ${new Date(currentProject.created).toLocaleString()}</p>
            <p><strong>Ge√§ndert:</strong> ${new Date(currentProject.modified).toLocaleString()}</p>
            <p><strong>Tracks:</strong> ${multiTrackTracks.length}</p>
          </div>
          <div>
            <p><strong>Tempo:</strong> ${currentProject.settings.tempo} BPM</p>
            <p><strong>Tonart:</strong> ${currentProject.settings.key}</p>
            <p><strong>Taktart:</strong> ${currentProject.settings.timeSignature}</p>
            <p><strong>Sample Rate:</strong> ${currentProject.settings.sampleRate} Hz</p>
          </div>
        </div>
        
        <div style="margin-top:15px;">
          <h5>üìù Metadaten bearbeiten:</h5>
          <div style="display:grid; grid-template-columns: repeat(2, 1fr); gap:10px;">
            <input type="text" placeholder="K√ºnstler" value="${currentProject.metadata.artist}" 
                   onchange="updateProjectMetadata('artist', this.value)">
            <input type="text" placeholder="Album" value="${currentProject.metadata.album}" 
                   onchange="updateProjectMetadata('album', this.value)">
            <input type="text" placeholder="Genre" value="${currentProject.metadata.genre}" 
                   onchange="updateProjectMetadata('genre', this.value)">
            <input type="number" placeholder="Jahr" value="${currentProject.metadata.year}" 
                   onchange="updateProjectMetadata('year', this.value)">
          </div>
          <textarea placeholder="Notizen" style="width:100%; margin-top:10px; height:60px;"
                    onchange="updateProjectMetadata('notes', this.value)">${currentProject.metadata.notes}</textarea>
        </div>
        
        <div class="controls" style="margin-top:15px;">
          <button onclick="updateProjectDisplay()" class="btn">üîô Zur√ºck</button>
          <button onclick="saveProject()" class="btn">üíæ Speichern</button>
        </div>
      </div>
    `;
  }
  
  function updateProjectMetadata(key, value) {
    if (currentProject && currentProject.metadata) {
      currentProject.metadata[key] = value;
      currentProject.modified = new Date().toISOString();
    }
  }
  
  function updateProjectDisplay() {
    const projectManager = document.getElementById('projectManager');
    if (!projectManager) return;
    
    if (!currentProject) {
      projectManager.innerHTML = `
        <div style="text-align:center; padding:40px;">
          <h4>üéµ Kein Projekt geladen</h4>
          <p>Erstellen Sie ein neues Projekt oder √∂ffnen Sie ein bestehendes.</p>
          <div class="controls" style="margin-top:20px;">
            <button onclick="createNewProject()" class="btn">üÜï Neues Projekt</button>
            <button onclick="openProject()" class="btn">üìÇ Projekt √∂ffnen</button>
          </div>
        </div>
      `;
      return;
    }
    
    projectManager.innerHTML = `
      <div style="padding:15px; background:#fff; border-radius:8px;">
        <h4>üéµ Projekt: ${currentProject.name}</h4>
        <div style="display:flex; justify-content:space-between; align-items:center; margin:15px 0;">
          <div>
            <p><strong>Status:</strong> ${currentProject.modified === currentProject.created ? 'Neu' : 'Ge√§ndert'}</p>
            <p><strong>Tracks:</strong> ${multiTrackTracks.length}</p>
            <p><strong>Letzte √Ñnderung:</strong> ${new Date(currentProject.modified).toLocaleString()}</p>
          </div>
          <div style="text-align:right;">
            <p><strong>Tempo:</strong> ${currentProject.settings.key}</p>
            <p><strong>Tonart:</strong> ${currentProject.settings.key}</p>
            <p><strong>Taktart:</strong> ${currentProject.settings.timeSignature}</p>
          </div>
        </div>
        
        <div class="controls" style="margin-top:15px;">
          <button onclick="showProjectInfo()" class="btn">‚ÑπÔ∏è Projekt-Info</button>
          <button onclick="saveProject()" class="btn">üíæ Speichern</button>
          <button onclick="exportProject()" class="btn">üì§ Exportieren</button>
        </div>
      </div>
    `;
  }
  
  // Debug-Funktion f√ºr Audio-Status
  function debugAudioStatus() {
    console.log('=== AUDIO-STATUS DEBUG ===');
    console.log('dawActive:', dawActive);
    console.log('currentAudioBuffer:', currentAudioBuffer ? 
      `${currentAudioBuffer.duration.toFixed(2)}s, ${currentAudioBuffer.numberOfChannels} Kan√§le, ${currentAudioBuffer.sampleRate} Hz` : 
      'Nicht geladen');
    console.log('Tone.js verf√ºgbar:', !!window.Tone);
    console.log('Audio-Elemente:');
    console.log('- waveformEditor:', !!document.getElementById('waveformEditor'));
    console.log('- waveframeEditor:', !!document.getElementById('waveframeEditor'));
    console.log('- multiTrackEditor:', !!document.getElementById('multiTrackEditor'));
    console.log('- projectManager:', !!document.getElementById('projectManager'));
    console.log('========================');
    
    // Zus√§tzliche Debug-Informationen
    if (currentAudioBuffer) {
      console.log('Audio-Details:');
      console.log('- Dauer:', currentAudioBuffer.duration.toFixed(2) + 's');
      console.log('- Sample Rate:', currentAudioBuffer.sampleRate + ' Hz');
      console.log('- Kan√§le:', currentAudioBuffer.numberOfChannels);
      console.log('- Samples:', currentAudioBuffer.length.toLocaleString());
    }
    
    // DAW-Status √ºberpr√ºfen
    console.log('DAW-Status:');
    console.log('- DAW aktiv:', dawActive);
    console.log('- Audio geladen:', !!currentAudioBuffer);
    console.log('- Tone.js verf√ºgbar:', !!window.Tone);
  }
  
  // Globale Debug-Funktion verf√ºgbar machen
  window.debugAudioStatus = debugAudioStatus;
  
  // Musik-Abspiel-Funktionalit√§t
  document.addEventListener('DOMContentLoaded', function() {
    const playButton = document.getElementById('play');
    const stopButton = document.getElementById('stop');
    const metronomeButton = document.getElementById('metronome');
    const tempoSlider = document.getElementById('tempo');
    const tempoLabel = document.getElementById('tempoLbl');
    const semiSlider = document.getElementById('semi');
    const semiLabel = document.getElementById('semiLbl');
    const capoSlider = document.getElementById('capo');
    const capoLabel = document.getElementById('capoLbl');
    const origSelect = document.getElementById('orig');
    const targetSelect = document.getElementById('target');
    const inputField = document.getElementById('inp');
    const outputField = document.getElementById('out');
    
    // Tempo-Slider
    if (tempoSlider && tempoLabel) {
      tempoSlider.addEventListener('input', function() {
        tempoLabel.textContent = this.value;
        if (window.Tone && window.Tone.Transport) {
          window.Tone.Transport.bpm.value = parseInt(this.value);
        }
      });
    }
    
    // Halbton-Slider
    if (semiSlider && semiLabel) {
      semiSlider.addEventListener('input', function() {
        semiLabel.textContent = this.value;
        transposeChords();
      });
    }
    
    // Capo-Slider
    if (capoSlider && capoLabel) {
      capoSlider.addEventListener('input', function() {
        capoLabel.textContent = this.value;
        transposeChords();
      });
    }
    
    // Play-Button - urspr√ºngliche Funktionalit√§t wiederherstellen
    if (playButton) {
      playButton.addEventListener('click', function() {
        startPlayback();
      });
    }
    
    // Stop-Button - urspr√ºngliche Funktionalit√§t wiederherstellen
    if (stopButton) {
      stopButton.addEventListener('click', function() {
        stopPlayback();
      });
    }
    
    // Metronom-Button - urspr√ºngliche Funktionalit√§t wiederherstellen
    if (metronomeButton) {
      metronomeButton.addEventListener('click', function() {
        startMetronome();
      });
    }
    
    // Tonart-√Ñnderungen
    if (origSelect) {
      origSelect.addEventListener('change', function() {
        transposeChords();
      });
    }
    
    if (targetSelect) {
      targetSelect.addEventListener('change', function() {
        transposeChords();
      });
    }
    
    // Input-Feld √Ñnderungen
    if (inputField) {
      inputField.addEventListener('input', function() {
        console.log('üé∏ Input-Feld ge√§ndert, rufe compute() auf');
        compute(); // Rufe die Hauptfunktion auf
      });
      // Initiale Ausf√ºhrung
      console.log('üé∏ Initiale compute() Ausf√ºhrung');
      compute();
    }
    
    console.log('‚úÖ Musik-Abspiel-Funktionalit√§t initialisiert');
  });
  
  // Akkorde abspielen
  function playChords() {
    const inputField = document.getElementById('inp');
    const tempoSlider = document.getElementById('tempo');
    
    if (!inputField || !inputField.value.trim()) {
      showNotification('‚ö†Ô∏è Akkorde erforderlich', 'Bitte geben Sie Akkorde ein!', 'warning');
      return;
    }
    
    const chords = inputField.value.trim().split(/\s+/);
    const tempo = tempoSlider ? parseInt(tempoSlider.value) : 120;
    
    // Use enhanced audio system if available
    if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
      try {
        console.log('üé∏ Verwende Enhanced Audio System f√ºr Akkorde:', chords);
        
        // Get current instrument
        const instrument = window.currentInstrument || 'acoustic-guitar';
        const instrumentType = instrument.split('-')[1] || 'guitar';
        const instrumentCategory = instrument.split('-')[0] || 'acoustic';
        
        // Play each chord with enhanced audio system
        chords.forEach((chord, index) => {
          setTimeout(() => {
            window.enhancedAudioSystem.playChord(chord, instrumentType, instrumentCategory);
          }, index * (60000 / tempo)); // Convert BPM to milliseconds
        });
        
        showNotification('üé∏ Akkorde mit Enhanced Audio System abgespielt', `${chords.length} Akkorde, Tempo: ${tempo} BPM, Instrument: ${instrument}`, 'success');
        return;
      } catch (error) {
        console.error('‚ùå Fehler mit Enhanced Audio System:', error);
        // Fallback to original method
      }
    }
    
    // Fallback to original Tone.js method
    if (!window.Tone) {
      showNotification('üîä Audio System nicht verf√ºgbar', 'Bitte aktivieren Sie Audio', 'error');
      return;
    }
    
    try {
      // Audio Context starten
      if (window.Tone.context.state !== 'running') {
        window.Tone.context.resume();
      }
      
      // Stoppe vorherige Wiedergabe
      if (window.Tone.Transport.state === 'started') {
        window.Tone.Transport.stop();
        window.Tone.Transport.cancel();
      }
      
      // Professioneller Gitarren-Synthesizer erstellen
      const guitarSynth = new window.Tone.PolySynth(window.Tone.Synth, {
        oscillator: { 
          type: 'triangle',
          phase: 0
        },
        envelope: { 
          attack: 0.05, 
          decay: 0.2, 
          sustain: 0.3, 
          release: 0.5 
        },
        filter: {
          type: 'lowpass',
          frequency: 2000,
          rolloff: -12
        }
      }).toDestination();
      
      // Reverb f√ºr nat√ºrlicheren Klang
      const reverb = new window.Tone.Reverb(1.5).toDestination();
      guitarSynth.connect(reverb);
      
      console.log('üé∏ Spiele echte Gitarren-Akkorde mit Wiederholung:', chords);
      
      // Akkorde in Schleife abspielen (3 Wiederholungen)
      const repetitions = 3;
      const chordDuration = 60 / tempo; // Dauer pro Akkord
      
      for (let rep = 0; rep < repetitions; rep++) {
        chords.forEach((chord, index) => {
          const time = (rep * chords.length * chordDuration) + (index * chordDuration);
          
          // Verwende echte Akkord-Definitionen
          let notes;
          if (CHORDS[chord]) {
            notes = CHORDS[chord].map(note => note + '4');
            console.log(`üéµ Wiederholung ${rep + 1}, Akkord ${index + 1}: ${chord} - Echte Definition:`, notes);
          } else {
            notes = getChordNotes(chord);
            console.log(`üéµ Wiederholung ${rep + 1}, Akkord ${index + 1}: ${chord} - Berechnete Noten:`, notes);
          }
          
          window.Tone.Transport.schedule(() => {
            guitarSynth.triggerAttackRelease(notes, '2n');
          }, time);
        });
      }
      
      // Transport starten
      window.Tone.Transport.bpm.value = tempo;
      window.Tone.Transport.start();
      
      // Status aktualisieren
      const statusElement = document.getElementById('status');
      if (statusElement) {
        statusElement.textContent = `üé∏ Spiele ${chords.length} Akkorde (${repetitions}x wiederholt), Tempo: ${tempo} BPM`;
      }
      
      showNotification('üé∏ Gitarren-Akkorde mit Wiederholung abgespielt', `${chords.length} Akkorde, ${repetitions}x wiederholt, Tempo: ${tempo} BPM`, 'success');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Abspielen:', error);
      showNotification('‚ùå Fehler beim Abspielen', 'Fehler beim Abspielen der Akkorde', 'error');
    }
  }
  
  // Akkorde stoppen
  function stopChords() {
    if (window.Tone && window.Tone.Transport) {
      window.Tone.Transport.stop();
      window.Tone.Transport.cancel();
      console.log('‚èπÔ∏è Akkorde gestoppt');
    }
  }
  
  // Metronom umschalten
  function toggleMetronome() {
    if (!window.Tone) {
      showNotification('üîä Tone.js nicht verf√ºgbar', 'Bitte aktivieren Sie Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    try {
      if (!window.metronomeActive) {
        // Metronom starten
        const tempo = document.getElementById('tempo') ? parseInt(document.getElementById('tempo').value) : 120;
        
        const click = new window.Tone.Player({
          url: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT',
          volume: -10
        }).toDestination();
        
        window.Tone.Transport.scheduleRepeat((time) => {
          click.start(time);
        }, '4n');
        
        window.Tone.Transport.bpm.value = tempo;
        window.Tone.Transport.start();
        
        window.metronomeActive = true;
        const metronomeButton = document.getElementById('metronome');
        if (metronomeButton) {
          metronomeButton.textContent = 'ü•Å Metronom Stop';
          metronomeButton.style.background = '#ef4444';
        }
        
        console.log('ü•Å Metronom gestartet, Tempo:', tempo);
      } else {
        // Metronom stoppen
        window.Tone.Transport.stop();
        window.Tone.Transport.cancel();
        
        window.metronomeActive = false;
        const metronomeButton = document.getElementById('metronome');
        if (metronomeButton) {
          metronomeButton.textContent = 'ü•Å Metronom';
          metronomeButton.style.background = '';
        }
        
        console.log('‚èπÔ∏è Metronom gestoppt');
      }
    } catch (error) {
      console.error('‚ùå Metronom-Fehler:', error);
      alert('Fehler beim Metronom');
    }
  }
  
  // Akkorde transponieren
  function transposeChords() {
    const inputField = document.getElementById('inp');
    const outputField = document.getElementById('out');
    const origSelect = document.getElementById('orig');
    const targetSelect = document.getElementById('target');
    const semiSlider = document.getElementById('semi');
    const capoSlider = document.getElementById('capo');
    
    if (!inputField || !inputField.value.trim()) {
      if (outputField) outputField.textContent = '';
      return;
    }
    
    const chords = inputField.value.trim().split(/\s+/);
    const semitones = semiSlider ? parseInt(semiSlider.value) : 0;
    const capo = capoSlider ? parseInt(capoSlider.value) : 0;
    
    const transposedChords = chords.map(chord => {
      return transposeChord(chord, semitones + capo);
    });
    
    if (outputField) {
      outputField.innerHTML = transposedChords.map(chord => 
        `<span class="chord">${chord}</span>`
      ).join(' ');
    }
    
    // F√ºr startPlayback() verf√ºgbar machen
    window.currentChords = transposedChords;
    window.currentVoicings = generateVoicings(transposedChords.map(chord => {
      const match = chord.match(/^([A-G][#b]?)(.*)$/);
      if (!match) return { root: 'C', quality: 'maj', full: chord };
      const [, root, quality] = match;
      return { root: root, quality: quality || 'maj', full: chord };
    }));
    
    console.log('üéµ Akkorde transponiert:', chords, '‚Üí', transposedChords);
  }
  
  // Griffbilder und ASCII-TAB aktualisieren
  function updateChordDisplay() {
    const inputField = document.getElementById('inp');
    const diagramsDiv = document.getElementById('diagrams');
    const asciiDiv = document.getElementById('ascii');
    const vfNotesDiv = document.getElementById('vf-notes');
    const vfTabDiv = document.getElementById('vf-tab');
    
    if (!inputField || !inputField.value.trim()) {
      if (diagramsDiv) diagramsDiv.innerHTML = '<p style="text-align:center; color:#666;">Keine Akkorde eingegeben</p>';
      if (asciiDiv) asciiDiv.textContent = '';
      if (vfNotesDiv) vfNotesDiv.innerHTML = '<p style="text-align:center; color:#666;">Keine Akkorde eingegeben</p>';
      if (vfTabDiv) vfTabDiv.innerHTML = '<p style="text-align:center; color:#666;">Keine Akkorde eingegeben</p>';
      return;
    }
    
    try {
      const chords = inputField.value.trim().split(/\s+/);
      
      // Akkorde parsen
      const parsedChords = chords.map(chord => {
        const match = chord.match(/^([A-G][#b]?)(.*)$/);
        if (!match) return null;
        const [, root, quality] = match;
        return {
          root: root,
          quality: quality || 'maj',
          full: chord
        };
      }).filter(chord => chord !== null);
      
      // Griffbilder rendern mit verbessertem Layout
      if (diagramsDiv && parsedChords.length > 0) {
        renderChordDiagramsImproved(parsedChords, generateVoicings(parsedChords));
      }
      
      // ASCII-TAB generieren
      if (asciiDiv && parsedChords.length > 0) {
        generateASCIITab(parsedChords);
      }
      
      // VexFlow Notation rendern
      if (vfNotesDiv && vfTabDiv && parsedChords.length > 0) {
        renderVexflow(parsedChords, generateVoicings(parsedChords));
      }
      
      console.log('‚úÖ Griffbilder, ASCII-TAB und VexFlow aktualisiert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Anzeige:', error);
      if (diagramsDiv) diagramsDiv.innerHTML = '<p style="text-align:center; color:#666;">Fehler beim Rendern der Griffbilder</p>';
    }
  }

  // Globale Variable f√ºr Griffbild-Stil
  window.useOriginalDiagrams = false;

  // Umschaltungsfunktion f√ºr Griffbild-Stil
  function toggleChordDisplay() {
    window.useOriginalDiagrams = !window.useOriginalDiagrams;
    const button = document.getElementById('toggleDisplay');
    if (button) {
      button.textContent = window.useOriginalDiagrams ? 'üîÑ Moderne Griffbilder' : 'üîÑ Originale Griffbilder';
    }
    
    // Aktuelle Akkorde neu rendern
    if (window.currentChords && window.currentVoicings) {
      if (window.useOriginalDiagrams) {
        renderChordDiagramsOriginal(window.currentChords, window.currentVoicings);
      } else {
        renderChordDiagramsImproved(window.currentChords, window.currentVoicings);
      }
    }
    
    showNotification(
      window.useOriginalDiagrams ? 'Originale Griffbilder aktiviert' : 'Moderne Griffbilder aktiviert',
      'Griffbild-Stil gewechselt',
      'info'
    );
  }

  // Test-Funktion f√ºr compute()
  function testCompute() {
    console.log('üß™ Test Compute Button geklickt');
    console.log('üß™ window.compute verf√ºgbar:', typeof window.compute);
    console.log('üß™ Input-Feld Wert:', document.getElementById('inp')?.value);
    
    if (typeof window.compute === 'function') {
      console.log('üß™ Rufe compute() auf...');
      window.compute();
    } else {
      console.error('üß™ compute() Funktion nicht verf√ºgbar!');
      showNotification('‚ùå Compute-Funktion nicht verf√ºgbar', 'Fehler beim Testen', 'error');
    }
  }

  // Notensystem-Toggle
  let showNotation = false;
  function toggleNotation() {
    showNotation = !showNotation;
    console.log('üéº Notensystem-Toggle:', showNotation);
    
    const notationDiv = document.getElementById('notation');
    if (!notationDiv) {
      // Erstelle Notensystem-Container
      const newNotationDiv = document.createElement('div');
      newNotationDiv.id = 'notation';
      newNotationDiv.style.cssText = `
        margin: 20px 0;
        padding: 20px;
        background: white;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      `;
      
      // F√ºge nach dem diagrams Div hinzu
      const diagramsDiv = document.getElementById('diagrams');
      if (diagramsDiv && diagramsDiv.parentNode) {
        diagramsDiv.parentNode.insertBefore(newNotationDiv, diagramsDiv.nextSibling);
      }
    }
    
    if (showNotation) {
      renderNotation();
      showNotification('üéº Notensystem aktiviert', 'Zeigt Akkorde in Standard-Notation an', 'success');
    } else {
      const notationDiv = document.getElementById('notation');
      if (notationDiv) {
        notationDiv.style.display = 'none';
      }
      showNotification('üéº Notensystem deaktiviert', 'Notensystem ausgeblendet', 'info');
    }
  }

  // Notensystem-Rendering
  function renderNotation() {
    const notationDiv = document.getElementById('notation');
    if (!notationDiv) return;
    
    notationDiv.style.display = 'block';
    notationDiv.innerHTML = `
      <h3 style="margin: 0 0 15px 0; color: #1f2937; text-align: center;">üéº Standard-Notation</h3>
      <div id="staff-container" style="text-align: center; margin: 20px 0;">
        <div id="treble-staff" style="display: inline-block; margin: 10px;"></div>
      </div>
    `;
    
    // Erstelle einfaches Notensystem mit HTML/CSS
    const staffContainer = document.getElementById('staff-container');
    if (staffContainer) {
      createSimpleStaff(staffContainer);
    }
  }

  // Einfaches Notensystem erstellen
  function createSimpleStaff(container) {
    const chords = window.currentChords || [];
    if (!chords.length) {
      container.innerHTML = '<p style="color: #666;">Keine Akkorde zum Anzeigen</p>';
      return;
    }
    
    // Erstelle 5-Linien-Stab
    const staff = document.createElement('div');
    staff.style.cssText = `
      display: inline-block;
      position: relative;
      margin: 20px;
      padding: 20px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
    `;
    
    // 5 horizontale Linien
    for (let i = 0; i < 5; i++) {
      const line = document.createElement('div');
      line.style.cssText = `
        position: absolute;
        left: 0;
        right: 0;
        height: 1px;
        background: #000;
        top: ${20 + i * 8}px;
      `;
      staff.appendChild(line);
    }
    
    // Akkord-Symbole hinzuf√ºgen
    chords.forEach((chord, index) => {
      const chordSymbol = document.createElement('div');
      chordSymbol.style.cssText = `
        position: absolute;
        left: ${40 + index * 60}px;
        top: 10px;
        font-size: 16px;
        font-weight: bold;
        color: #1f2937;
        background: #f3f4f6;
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
      `;
      chordSymbol.textContent = chord.root + (chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality || "");
      staff.appendChild(chordSymbol);
    });
    
    // Taktstriche
    const barLine = document.createElement('div');
    barLine.style.cssText = `
      position: absolute;
      left: ${40 + chords.length * 60}px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #000;
    `;
    staff.appendChild(barLine);
    
    container.appendChild(staff);
  }

  // Funktionen global verf√ºgbar machen
  window.toggleChordDisplay = toggleChordDisplay;
  window.renderChordDiagramsOriginal = renderChordDiagramsOriginal;
  window.renderChordDiagramsImproved = renderChordDiagramsImproved;
  window.testCompute = testCompute;
  window.toggleNotation = toggleNotation;
  window.renderNotation = renderNotation;

  // Originale Griffbild-Rendering-Funktion mit Fretboard-Implantat
  function renderChordDiagramsOriginal(chords, voicings) {
    console.log('üé∏ renderChordDiagramsOriginal aufgerufen mit:', chords, voicings);
    
    const diagramsDiv = document.getElementById('diagrams');
    if (!diagramsDiv) {
      console.error('‚ùå diagrams Div nicht gefunden');
      return;
    }
    
    if (!chords || !Array.isArray(chords) || chords.length === 0) {
      console.warn('‚ùå Keine Akkorde zum Rendern');
      diagramsDiv.innerHTML = '<p style="text-align:center; color:#666;">Keine Akkorde eingegeben</p>';
      return;
    }
    
    diagramsDiv.innerHTML = '';
    
    // Korrekte Standard-Gitarren-Griffbilder (Strings: E-A-D-G-B-E von links nach rechts)
    const correctStandardFingerings = {
      // Offene Dur-Akkorde
      'C': { frets: [-1, 3, 2, 0, 1, 0], fingers: ['X', '3', '2', 'O', '1', 'O'], baseFret: 0 },
      'G': { frets: [3, 2, 0, 0, 3, 3], fingers: ['3', '2', 'O', 'O', '3', '3'], baseFret: 0 },
      'D': { frets: [-1, -1, 0, 2, 3, 2], fingers: ['X', 'X', 'O', '1', '3', '2'], baseFret: 0 },
      'A': { frets: [-1, 0, 2, 2, 2, 0], fingers: ['X', 'O', '1', '2', '3', 'O'], baseFret: 0 },
      'E': { frets: [0, 2, 2, 1, 0, 0], fingers: ['O', '2', '3', '1', 'O', 'O'], baseFret: 0 },
      
      // Offene Moll-Akkorde
      'Am': { frets: [-1, 0, 2, 2, 1, 0], fingers: ['X', 'O', '2', '3', '1', 'O'], baseFret: 0 },
      'Em': { frets: [0, 2, 2, 0, 0, 0], fingers: ['O', '2', '3', 'O', 'O', 'O'], baseFret: 0 },
      'Dm': { frets: [-1, -1, 0, 2, 3, 1], fingers: ['X', 'X', 'O', '2', '3', '1'], baseFret: 0 },
      
      // Barr√©-Akkorde
      'F': { frets: [1, 3, 3, 2, 1, 1], fingers: ['1', '3', '4', '2', '1', '1'], baseFret: 1 },
      'Bm': { frets: [-1, 2, 4, 4, 3, 2], fingers: ['X', '1', '3', '4', '2', '1'], baseFret: 2 },
      'B': { frets: [-1, 2, 4, 4, 4, 2], fingers: ['X', '1', '2', '3', '4', '1'], baseFret: 2 },
      'Bb': { frets: [-1, 1, 3, 3, 3, 1], fingers: ['X', '1', '2', '3', '4', '1'], baseFret: 1 }
    };
    
    chords.forEach((chord, i) => {
      if (!chord || !chord.root) {
        console.warn('Ung√ºltiger Akkord gefunden:', chord);
        return;
      }
      
      console.log('üé∏ Verarbeite Akkord:', chord);
      
      // Erstelle Akkordname
      const chordName = chord.root + (chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality || "") + (chord.bass ? "/" + chord.bass : "");
      console.log('üé∏ Akkordname erstellt:', chordName);
      
      // Suche nach Standard-Griffbild
      let fingering = correctStandardFingerings[chordName];
      console.log('üé∏ Standard-Griffbild gefunden f√ºr', chordName, ':', !!fingering);
      
      if (!fingering) {
        // Fallback: Verwende einfache Standard-Griffbilder
        console.log('üé∏ Erstelle Fallback-Griffbild f√ºr', chordName);
        if (chord.quality && (chord.quality.includes('m') || chord.quality === 'min')) {
          fingering = correctStandardFingerings['Am']; // Am als Fallback f√ºr Moll
        } else {
          fingering = correctStandardFingerings['C']; // C als Fallback f√ºr Dur
        }
      }
      
      // Erstelle Fretboard-Implantat Container
      const container = document.createElement('div');
      container.className = 'chord-diagram';
      container.style.cssText = `
        display: inline-block;
        margin: 10px;
        padding: 15px;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        background: white;
        text-align: center;
        min-width: 200px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      `;
      
      // Akkordname
      const title = document.createElement('h4');
      title.textContent = chordName;
      title.style.cssText = 'margin: 0 0 15px 0; font-size: 18px; color: #1f2937; font-weight: bold;';
      container.appendChild(title);
      
      // Konvertiere Standard-Griffbild zu Fretboard-Format
      const fretboardDots = [];
      fingering.frets.forEach((fret, stringIndex) => {
        if (fret > 0) {
          // Fretboard-Implantat verwendet 0-basierte String-Indizes
          fretboardDots.push({
            s: stringIndex,  // String-Index (0-5)
            f: fret          // Fret-Nummer (1-5)
          });
        }
      });
      
      // Erstelle Fretboard-Implantat Element
      const fretboardElement = document.createElement('div');
      fretboardElement.setAttribute('data-fretboard', '');
      fretboardElement.setAttribute('data-strings', '6');
      fretboardElement.setAttribute('data-frets', '5');
      fretboardElement.setAttribute('data-title', chordName);
      fretboardElement.setAttribute('data-json', JSON.stringify(fretboardDots));
      fretboardElement.style.cssText = 'width: 180px; margin: 0 auto;';
      
      container.appendChild(fretboardElement);
      
      // Finger-Positionen als Text (zus√§tzliche Info)
      const positions = document.createElement('div');
      positions.style.cssText = 'font-size: 12px; color: #6b7280; margin-top: 10px; font-family: monospace;';
      positions.textContent = `Positionen: ${fingering.frets.map(f => f === -1 ? 'X' : f === 0 ? 'O' : f).join(' ')}`;
      container.appendChild(positions);
      
      diagramsDiv.appendChild(container);
      console.log('üé∏ Fretboard-Griffbild hinzugef√ºgt f√ºr', chordName, 'mit Dots:', fretboardDots);
    });
    
    // Initialisiere alle Fretboard-Implantate
    if (window.Fretboard && window.Fretboard.init) {
      window.Fretboard.init(diagramsDiv);
    }
    
    console.log('üé∏ Alle Fretboard-Griffbilder gerendert. Anzahl:', diagramsDiv.children.length);
  }

  // Entfernte komplexe Hilfsfunktionen - verwende einfachere L√∂sung

  // Verbesserte Griffbild-Rendering-Funktion
  function renderChordDiagramsImproved(chords, voicings) {
    console.log('üé∏ renderChordDiagramsImproved aufgerufen mit:', chords, voicings);
    
    const diagramsDiv = document.getElementById('diagrams');
    if (!diagramsDiv) {
      console.error('‚ùå diagrams Div nicht gefunden');
      return;
    }
    
    // Container mit verbessertem Layout
    diagramsDiv.innerHTML = `
      <div style="
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
        gap: 16px; 
        max-width: 100%; 
        overflow-x: auto;
        padding: 16px;
      ">
        ${chords.map((chord, index) => {
          const voicing = voicings[index];
          return `
            <div class="chord-display" style="
              border: 2px solid #e5e7eb; 
              border-radius: 12px; 
              padding: 16px; 
              background: white;
              min-width: 220px;
              max-width: 300px;
              word-wrap: break-word;
              overflow-wrap: break-word;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            ">
              <h3 style="margin: 0 0 12px 0; font-size: 18px; color: #1f2937; text-align: center;">
                ${chord.full}
              </h3>
              <div style="
                display: flex; 
                justify-content: center; 
                align-items: center;
                min-height: 120px;
                background: #f9fafb;
                border-radius: 8px;
                margin-bottom: 12px;
              ">
                <div style="font-family: monospace; font-size: 14px; color: #6b7280;">
                  ${renderSimpleChordDiagram(voicing)}
                </div>
              </div>
              <div style="
                font-size: 12px; 
                color: #6b7280; 
                text-align: center;
                background: #f3f4f6;
                padding: 8px;
                border-radius: 6px;
              ">
                ${voicing.f.map(fret => fret === -1 ? 'x' : fret).join(' ')}
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  // Einfache Griffbild-Rendering-Funktion
  function renderSimpleChordDiagram(voicing) {
    const frets = voicing.f;
    const strings = ['E', 'A', 'D', 'G', 'B', 'E'];
    
    let diagram = '';
    for (let fret = 0; fret <= 4; fret++) {
      diagram += `${fret === 0 ? ' ' : fret} `;
      for (let string = 0; string < 6; string++) {
        if (fret === 0) {
          if (frets[string] === -1) {
            diagram += 'x ';
          } else if (frets[string] === 0) {
            diagram += 'o ';
          } else {
            diagram += '| ';
          }
        } else {
          if (frets[string] === fret) {
            diagram += '‚óè ';
          } else {
            diagram += '| ';
          }
        }
      }
      diagram += '\n';
    }
    diagram += '   ';
    for (let string = 0; string < 6; string++) {
      diagram += `${strings[string]} `;
    }
    
    return diagram;
  }
  
  // Echte Gitarren-Griffbilder basierend auf Standard-Akkorden
  function generateVoicings(chords) {
    console.log('üé∏ Generiere Voicings f√ºr Akkorde:', chords);
    
    return chords.map(chord => {
      // Standard Gitarrenstimmung: E-A-D-G-B-E (6-1)
      const standardTuning = ['E', 'A', 'D', 'G', 'B', 'E'];
      
      // Bestimme die korrekte Akkord-Qualit√§t
      let quality = chord.quality || 'maj';
      if (quality === '') quality = 'maj';
      
      console.log(`üé∏ Akkord ${chord.full}: Root=${chord.root}, Quality=${quality}`);
      
      // Echte Gitarren-Griffbilder f√ºr spezifische Akkorde
      let baseVoicing;
      
      // Spezifische Akkord-Definitionen
      if (chord.root === 'C' && quality === 'maj') {
        // C-Dur: [x, 3, 2, 0, 1, 0] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 3, 2, 0, 1, 0], g: [0, 2, 3, 0, 1, 0] };
      } else if (chord.root === 'G' && quality === 'maj') {
        // G-Dur: [3, 2, 0, 0, 0, 3] - E-A-D-G-B-E
        baseVoicing = { f: [3, 2, 0, 0, 0, 3], g: [2, 1, 0, 0, 0, 3] };
      } else if (chord.root === 'D' && quality === 'maj') {
        // D-Dur: [x, x, 0, 2, 3, 2] - E-A-D-G-B-E
        baseVoicing = { f: [-1, -1, 0, 2, 3, 2], g: [0, 0, 0, 1, 2, 1] };
      } else if (chord.root === 'F' && quality === 'maj') {
        // F-Dur: [1, 3, 3, 2, 1, 1] - E-A-D-G-B-E (Barre-Akkord)
        baseVoicing = { f: [1, 3, 3, 2, 1, 1], g: [1, 3, 4, 2, 1, 1] };
      } else if (chord.root === 'E' && quality === 'maj') {
        // E-Dur: [0, 2, 2, 1, 0, 0] - E-A-D-G-B-E
        baseVoicing = { f: [0, 2, 2, 1, 0, 0], g: [0, 2, 3, 1, 0, 0] };
      } else if (chord.root === 'A' && quality === 'maj') {
        // A-Dur: [x, 0, 2, 2, 2, 0] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 0, 2, 2, 2, 0], g: [0, 0, 2, 3, 4, 0] };
      } else if (chord.root === 'B' && quality === 'maj') {
        // B-Dur: [x, 2, 4, 4, 4, 2] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 2, 4, 4, 4, 2], g: [0, 1, 3, 4, 5, 1] };
      } else if (chord.root === 'A' && (quality === 'min' || quality === 'm')) {
        // Am: [x, 0, 2, 2, 1, 0] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 0, 2, 2, 1, 0], g: [0, 0, 2, 3, 1, 0] };
      } else if (chord.root === 'D' && (quality === 'min' || quality === 'm')) {
        // Dm: [x, x, 0, 2, 3, 1] - E-A-D-G-B-E
        baseVoicing = { f: [-1, -1, 0, 2, 3, 1], g: [0, 0, 0, 1, 2, 1] };
      } else if (chord.root === 'E' && (quality === 'min' || quality === 'm')) {
        // Em: [0, 2, 2, 0, 0, 0] - E-A-D-G-B-E
        baseVoicing = { f: [0, 2, 2, 0, 0, 0], g: [0, 2, 3, 0, 0, 0] };
      } else if (chord.root === 'B' && (quality === 'min' || quality === 'm')) {
        // Bm: [x, 2, 4, 4, 3, 2] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 2, 4, 4, 3, 2], g: [0, 1, 3, 4, 2, 1] };
      } else if (chord.root === 'G' && quality === '7') {
        // G7: [3, 2, 0, 0, 0, 1] - E-A-D-G-B-E
        baseVoicing = { f: [3, 2, 0, 0, 0, 1], g: [2, 1, 0, 0, 0, 1] };
      } else if (chord.root === 'A' && quality === 'm7') {
        // Am7: [x, 0, 2, 0, 1, 0] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 0, 2, 0, 1, 0], g: [0, 0, 2, 0, 1, 0] };
      } else if (chord.root === 'C' && quality === 'maj7') {
        // Cmaj7: [x, 3, 2, 0, 0, 0] - E-A-D-G-B-E
        baseVoicing = { f: [-1, 3, 2, 0, 0, 0], g: [0, 2, 3, 0, 0, 0] };
      } else {
        // Fallback: Standard C-Dur
        baseVoicing = { f: [-1, 3, 2, 0, 1, 0], g: [0, 2, 3, 0, 1, 0] };
      }
      
      // Transponiere f√ºr verschiedene Grundt√∂ne (au√üer f√ºr spezifische Akkorde)
      let finalVoicing = { ...baseVoicing };
      
      // Nur transponieren wenn es kein spezifischer Akkord ist
      const specificChords = ['C', 'G', 'D', 'F', 'E', 'A', 'B'];
      if (!specificChords.includes(chord.root)) {
        finalVoicing = transposeVoicingForRoot(baseVoicing, chord.root, standardTuning);
      }
      
      // Capo-Effekt anwenden
      const capo = parseInt(document.getElementById('capo')?.value || 0);
      if (capo > 0) {
        finalVoicing.f = finalVoicing.f.map(fret => fret >= 0 ? fret + capo : fret);
      }
      
      console.log(`üé∏ Voicing f√ºr ${chord.full}:`, finalVoicing.f);
      return finalVoicing;
    });
  }
  

  
  // Optimiert Akkord-Sequenzen f√ºr gro√üe Produktionen
  function optimizeChordSequence(chords) {
    if (chords.length <= 100) return chords; // Keine Optimierung n√∂tig
    
    const optimized = [];
    const seen = new Set();
    
    for (let i = 0; i < chords.length; i++) {
      const chord = chords[i];
      const chordKey = chord.root + chord.quality;
      
      // Entferne Duplikate und √§hnliche Akkorde
      if (!seen.has(chordKey) || i % 5 === 0) { // Behalte jeden 5. Akkord
        optimized.push(chord);
        seen.add(chordKey);
      }
      
      // Begrenze auf maximal 100 Akkorde
      if (optimized.length >= 100) break;
    }
    
    return optimized;
  }
  
  // Optimiert Voicing-Sequenzen f√ºr gro√üe Produktionen
  function optimizeVoicingSequence(voicings) {
    if (voicings.length <= 100) return voicings; // Keine Optimierung n√∂tig
    
    const optimized = [];
    
    for (let i = 0; i < voicings.length; i++) {
      const voicing = voicings[i];
      
      // Validiere Voicing-Daten
      if (voicing && Array.isArray(voicing.f) && voicing.f.length === 6) {
        optimized.push(voicing);
      }
      
      // Begrenze auf maximal 100 Voicings
      if (optimized.length >= 100) break;
    }
    
    return optimized;
  }
  
  // Dynamisches VexFlow-Laden
  async function loadVexFlowDynamically() {
    if (typeof VexFlow !== 'undefined') return;
    
    console.log('üîÑ Lade VexFlow dynamisch...');
    try {
      const VexMod = await import('https://cdn.jsdelivr.net/npm/vexflow@4.2.3/build/esm/entry/vexflow.js');
      window.VexFlow = VexMod;
      console.log('‚úÖ VexFlow dynamisch geladen');
      return VexMod;
    } catch (e) {
      console.error('‚ùå VexFlow dynamisches Laden fehlgeschlagen:', e);
      throw e;
    }
  }
  
  // Fallback-Notation wenn VexFlow nicht verf√ºgbar
  function showFallbackNotation(chords, voicings) {
    console.log('üìù Zeige Fallback-Notation...');
    
    const notesDiv = vfNotes;
    const tabDiv = vfTab;
    
    notesDiv.innerHTML = `
      <div style="text-align:center; padding:20px; background:#f8f9fa; border-radius:8px;">
        <h3 style="color:#333; margin:0 0 15px 0;">üéº Akkordfolge</h3>
        <div style="font-size:20px; font-weight:bold; color:#007acc; font-family:monospace; line-height:1.4;">
          ${chords.map(c => {
            const suffix = c.quality === "maj" ? "" : c.quality === "min" ? "m" : c.quality;
            return c.bass ? `${c.root}${suffix}/${c.bass}` : `${c.root}${suffix}`;
          }).join(" ")}
        </div>
        <p style="color:#666; font-size:12px; margin:15px 0 0 0;">
          VexFlow wird geladen... Fallback-Darstellung
        </p>
      </div>
    `;
    
    tabDiv.innerHTML = `
      <div style="text-align:center; padding:20px; background:#f8f9fa; border-radius:8px;">
        <h3 style="color:#666; margin:0 0 15px 0;">üé∏ Tabulatur</h3>
        <div style="font-size:14px; color:#333; font-family:monospace; line-height:1.6; text-align:left;">
          ${voicings.map((voicing, i) => {
            const chord = chords[i];
            const suffix = chord.quality === "maj" ? "" : chord.quality === "min" ? "m" : chord.quality;
            const chordName = chord.root + suffix + (chord.bass ? "/" + chord.bass : "");
            return `<div style="margin:10px 0; padding:8px; background:white; border-radius:4px;">
              <strong style="color:#007acc;">${chordName}:</strong> 
              <span style="color:#666;">${voicing.f.map(f => f < 0 ? 'x' : f).join(' ')}</span>
            </div>`;
          }).join('')}
        </div>
        <p style="color:#666; font-size:12px; margin:15px 0 0 0;">
          VexFlow wird geladen... Fallback-Darstellung
        </p>
      </div>
    `;
    
    console.log('‚úÖ Fallback-Notation angezeigt');
  }
  
  // Korrekte Transposition basierend auf echter Musiktheorie
  function transposeVoicingForRoot(voicing, root, tuning) {
    // Korrekte Halbton-Mapping f√ºr alle Noten
    const noteToSemitones = {
      'C': 0, 'C#': 1, 'Db': 1,
      'D': 2, 'D#': 3, 'Eb': 3,
      'E': 4,
      'F': 5, 'F#': 6, 'Gb': 6,
      'G': 7, 'G#': 8, 'Ab': 8,
      'A': 9, 'A#': 10, 'Bb': 10,
      'B': 11
    };
    
    // C ist der Referenzpunkt (0 Halbt√∂ne)
    const targetSemitones = noteToSemitones[root] || 0;
    
    // Wenn es bereits C ist, keine Transposition n√∂tig
    if (targetSemitones === 0) return voicing;
    
    const transposed = { f: [...voicing.f], g: [...voicing.g] };
    
    // Korrekte Transposition: Alle B√ºnde um die Halbton-Differenz verschieben
    transposed.f = transposed.f.map(fret => {
      if (fret < 0) return fret; // Leere Saiten (-1) bleiben leer
      return fret + targetSemitones;
    });
    
    // Fingers√§tze entsprechend anpassen
    transposed.g = transposed.g.map(finger => {
      if (finger === 0) return 0; // Leere Finger bleiben leer
      return finger; // Fingers√§tze bleiben gleich, nur Position √§ndert sich
    });
    
    return transposed;
  }
  
  // Animierte Wiedergabe-Anzeige
  let playbackAnimationId = null;
  let currentPlaybackIndex = 0;
  
  function startPlaybackAnimation(totalChords) {
    currentPlaybackIndex = 0;
    
    // Erstelle oder aktualisiere Animations-Container
    let animationContainer = document.getElementById('playbackAnimation');
    if (!animationContainer) {
      animationContainer = document.createElement('div');
      animationContainer.id = 'playbackAnimation';
      animationContainer.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 12px;
        z-index: 1000;
        font-family: monospace;
        min-width: 250px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        cursor: move;
        user-select: none;
        border: 2px solid rgba(29, 185, 84, 0.3);
      `;
      
      // Schlie√üen-Button hinzuf√ºgen
      const closeButton = document.createElement('button');
      closeButton.innerHTML = '‚úï';
      closeButton.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(255, 0, 0, 0.8);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
      `;
      closeButton.onmouseover = () => closeButton.style.background = 'rgba(255, 0, 0, 1)';
      closeButton.onmouseout = () => closeButton.style.background = 'rgba(255, 0, 0, 0.8)';
      closeButton.onclick = () => {
        animationContainer.style.display = 'none';
        // Sound l√§uft weiter - nur Animation stoppen
        console.log('Live-Wiedergabe-Fenster geschlossen - Sound l√§uft weiter');
      };
      
      animationContainer.appendChild(closeButton);
      
      // Drag & Drop Funktionalit√§t
      let isDragging = false;
      let dragOffset = { x: 0, y: 0 };
      
      animationContainer.onmousedown = (e) => {
        if (e.target === closeButton) return; // Nicht beim Schlie√üen-Button
        isDragging = true;
        const rect = animationContainer.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        animationContainer.style.cursor = 'grabbing';
      };
      
      document.onmousemove = (e) => {
        if (!isDragging) return;
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        animationContainer.style.left = x + 'px';
        animationContainer.style.top = y + 'px';
        animationContainer.style.right = 'auto';
      };
      
      document.onmouseup = () => {
        isDragging = false;
        animationContainer.style.cursor = 'move';
      };
      
      document.body.appendChild(animationContainer);
    } else {
      // Container existiert bereits - zeige ihn an
      animationContainer.style.display = 'block';
    }
    
    // Starte Animation
    updatePlaybackAnimation(animationContainer, totalChords);
  }
  
  function updatePlaybackAnimation(container, totalChords) {
    if (!isPlaying) {
      stopPlaybackAnimation();
      return;
    }
    
    const progress = (currentPlaybackIndex / totalChords) * 100;
    const currentChord = window.currentChords ? window.currentChords[currentPlaybackIndex] : null;
    
    container.innerHTML = `
      <div style="margin-bottom:15px; font-weight:bold; font-size:16px; color:#1db954;">üéµ Live Wiedergabe</div>
      <div style="margin-bottom:8px; font-size:14px;">
        <strong>Aktueller Akkord:</strong> 
        <span style="color:#1db954; font-weight:bold;">${currentChord ? currentChord.full : 'N/A'}</span>
      </div>
      <div style="margin-bottom:8px; font-size:14px;">
        <strong>Position:</strong> ${currentPlaybackIndex + 1} / ${totalChords}
      </div>
      <div style="background:#333; height:12px; border-radius:6px; overflow:hidden; margin-bottom:8px;">
        <div style="background:#1db954; height:100%; width:${progress}%; transition:width 0.3s; box-shadow:0 0 5px #1db954;"></div>
      </div>
      <div style="font-size:12px; color:#ccc;">
        ${progress.toFixed(1)}% abgespielt
      </div>
    `;
    
    // N√§chste Animation in 1 Sekunde
    playbackAnimationId = setTimeout(() => {
      currentPlaybackIndex = (currentPlaybackIndex + 1) % totalChords;
      updatePlaybackAnimation(container, totalChords);
    }, 1000);
  }
  
  function stopPlaybackAnimation() {
    if (playbackAnimationId) {
      clearTimeout(playbackAnimationId);
      playbackAnimationId = null;
    }
    
    const animationContainer = document.getElementById('playbackAnimation');
    if (animationContainer) {
      // Nur ausblenden, nicht entfernen - damit Position erhalten bleibt
      animationContainer.style.display = 'none';
    }
  }
  
  // ASCII-TAB generieren
  function generateASCIITab(chords) {
    const asciiDiv = document.getElementById('ascii');
    if (!asciiDiv) return;
    
    let tab = '';
    chords.forEach(chord => {
      tab += `${chord.full}    `;
    });
    
    asciiDiv.textContent = tab;
  }
  
  // Scrollbar-Labels aktualisieren
  function updateScrollbarLabels() {
    const scrollbarStart = document.getElementById('scrollbarStart');
    const scrollbarEnd = document.getElementById('scrollbarEnd');
    const scrollbar = document.getElementById('waveformScrollbar');
    
    if (!currentAudioBuffer || !scrollbarStart || !scrollbarEnd || !scrollbar) return;
    
    const duration = currentAudioBuffer.duration;
    const startTime = waveformOffset * duration;
    const endTime = Math.min(startTime + (duration / waveformZoom), duration);
    
    scrollbarStart.textContent = formatTime(startTime);
    scrollbarEnd.textContent = formatTime(endTime);
    scrollbar.value = waveformOffset * 100;
  }
  
  function updateScrollbarToMousePosition(mouseX, canvasWidth) {
    const scrollbar = document.getElementById('waveformScrollbar');
    if (!scrollbar || !currentAudioBuffer) return;
    
    // Mausposition in Prozent umrechnen
    const mousePercent = mouseX / canvasWidth;
    
    // Scrollbar-Position entsprechend anpassen
    const newOffset = Math.max(0, Math.min(1, mousePercent));
    waveformOffset = newOffset;
    scrollbar.value = newOffset * 100;
    
    // Waveform neu rendern
    redrawMainWaveform();
  }
  
  // Zeit formatieren
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  // Test-Funktion f√ºr Audio-Laden
  function testAudioLoading() {
    console.log('=== TESTE AUDIO-LADEN ===');
    
    // 1. DAW-Status √ºberpr√ºfen
    checkAndRepairDAW();
    
    // 2. Audio-Status anzeigen
    debugAudioStatus();
    
    // 3. Test-Audio erstellen (1 Sekunde Sinus-Welle)
    // Test-Audio erstellen (1 Sekunde Sinus-Welle)
    console.log('Erstelle Test-Audio...');
    
    const ctx = initializeAudioContext();
    if (!ctx) {
      console.error('‚ùå AudioContext konnte nicht erstellt werden');
      return;
    }
    
    const sampleRate = 44100;
    const duration = 1; // 1 Sekunde
    const frequency = 440; // A4 Note
    
    const buffer = ctx.createBuffer(1, sampleRate * duration, sampleRate);
    const channelData = buffer.getChannelData(0);
    
    for (let i = 0; i < channelData.length; i++) {
      channelData[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 0.3;
    }
    
    // Test-Audio als currentAudioBuffer setzen
    currentAudioBuffer = buffer;
    
    console.log('‚úÖ Test-Audio erstellt:', buffer.duration.toFixed(2) + 's,', buffer.numberOfChannels, 'Kan√§le,', buffer.sampleRate, 'Hz');
    
    // Waveform in allen Editoren anzeigen
    displayWaveform(buffer);
    showAudioInfo(buffer);
    
    // Status aktualisieren
    updateAudioStatus('Test-Audio geladen: 1s Sinus-Welle (440 Hz)');
    
    console.log('Test-Audio erfolgreich geladen und angezeigt');
    
    console.log('=== AUDIO-TEST ABGESCHLOSSEN ===');
  }
  
    // Globale Test-Funktion verf√ºgbar machen
  window.testAudioLoading = testAudioLoading;
  
  // Globale Funktionen verf√ºgbar machen
  window.testChordParsing = testChordParsing;
  window.loadProgression = loadProgression;
  
  // Sofortige Verf√ºgbarkeit sicherstellen
  if (typeof window.testChordParsing === 'undefined') {
    window.testChordParsing = function() {
      console.log('üéº Teste Akkord-Parsing...');
      alert('Akkord-Parsing-Test: Funktion wird geladen...');
    };
  }
  
  // Live-Akkord-Sharing Funktionen verf√ºgbar machen
  window.getCurrentLiveChords = getCurrentLiveChords;
  window.subscribeToLiveChords = subscribeToLiveChords;
  window.unsubscribeFromLiveChords = unsubscribeFromLiveChords;
  window.startLiveChordSharing = startLiveChordSharing;
  window.stopLiveChordSharing = stopLiveChordSharing;
  
  function testChordParsing() {
    console.log('üéº Teste Akkord-Parsing...');
    
    const testChords = ['C', 'Am', 'F', 'G', 'Dm', 'Em'];
    testChords.forEach(chord => {
      const parsed = parseChord(chord);
      console.log(`${chord} ‚Üí ${JSON.stringify(parsed)}`);
    });
    
    console.log('‚úÖ Akkord-Parsing-Test abgeschlossen');
  }
  
  function loadProgression(progression) {
    console.log('üéº Lade Akkordfolge:', progression);
    
    // Sicherstellen, dass progression ein Array ist
    let chords = [];
    if (typeof progression === 'string') {
      chords = progression.split(/\s+/).filter(chord => chord.trim());
    } else if (Array.isArray(progression)) {
      chords = progression;
    } else {
      console.error('‚ùå Ung√ºltiger progression Parameter:', progression);
      return;
    }
    
    // Akkorde in das Live-Chord-System laden
    if (liveChordSystem) {
      liveChordSystem.currentChords = chords;
      liveChordSystem.source = 'progression';
      console.log('‚úÖ Akkorde in Live-Chord-System geladen:', chords);
    }
    
    // Akkorde in das Gitarren-Input-Feld laden
    const guitarInput = document.getElementById('inp');
    if (guitarInput) {
      guitarInput.value = chords.join(' ');
      console.log('‚úÖ Akkorde in Gitarren-Input geladen:', chords.join(' '));
    }
    
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    if (progressionAnalysis) {
      progressionAnalysis.innerHTML = `
        <div style="padding:15px; background:#e8f5e8; border-radius:8px; margin:15px 0; border-left:4px solid #1db954;">
          <h4>üéº Geladene Akkordfolge</h4>
          <div style="font-family:monospace; font-size:18px; line-height:1.8; margin:15px 0; text-align:center;">
            ${chords.map(chord => 
              `<span style="display:inline-block; margin:0 8px; padding:8px 12px; background:#1db954; color:white; border-radius:8px; font-weight:bold;">${chord}</span>`
            ).join('<span style="display:inline-block; margin:0 4px; color:#666; font-size:24px;">‚îÅ‚îÅ‚îÅ</span>')}
          </div>
          <div class="controls">
            <button onclick="playProgression('${chords.join(',')}')" class="btn">üéµ Abspielen</button>
            <button onclick="analyzeProgression('${chords.join(',')}')" class="btn">üîç Analysieren</button>
            <button onclick="transposeProgression('${chords.join(',')}', 1)" class="btn">üéµ +1 Halbton</button>
            <button onclick="transposeProgression('${chords.join(',')}', -1)" class="btn">üéµ -1 Halbton</button>
          </div>
          <div style="margin-top:10px; padding:10px; background:#f8f9fa; border-radius:6px;">
            <strong>Status:</strong> ‚úÖ Akkorde erfolgreich geladen und an alle Tools weitergegeben
          </div>
        </div>
      `;
    }
    
    // Alle Tools √ºber die neuen Akkorde informieren
    notifyChordSubscribers();
  }
  
  function parseChord(chord) {
    // Korrekte Akkord-Parsing basierend auf Musiktheorie
    const match = chord.match(/^([A-G][#b]?)(.*?)(?:\/([A-G][#b]?))?$/);
    if (!match) return null;
    
    const [, root, quality, bass] = match;
    
    // Qualit√§t korrekt interpretieren
    let interpretedQuality;
    switch (quality) {
      case '':
      case 'maj':
        interpretedQuality = 'maj';
        break;
      case 'm':
      case 'min':
        interpretedQuality = 'min';
        break;
      case '7':
        interpretedQuality = '7';
        break;
      case 'm7':
      case 'min7':
        interpretedQuality = 'm7';
        break;
      case 'maj7':
      case 'M7':
        interpretedQuality = 'maj7';
        break;
      case 'dim':
      case 'dim7':
        interpretedQuality = 'dim';
        break;
      case 'aug':
      case '+':
        interpretedQuality = 'aug';
        break;
      case 'sus2':
        interpretedQuality = 'sus2';
        break;
      case 'sus4':
        interpretedQuality = 'sus4';
        break;
      case 'add9':
        interpretedQuality = 'add9';
        break;
      default:
        interpretedQuality = 'maj';
    }
    
    return {
      root: root,
      quality: interpretedQuality,
      bass: bass || null,
      full: chord
    };
  }
  
  function playProgression(progressionString) {
    const chords = progressionString.split(',');
    console.log('üéµ Spiele Akkordfolge ab:', chords);
    
    if (window.Tone && audioEngine && audioEngine.instruments.piano) {
      const piano = audioEngine.instruments.piano;
      
      chords.forEach((chord, index) => {
        const time = index * 1; // 1 Sekunde pro Akkord
        const notes = getChordNotes(chord);
        
        window.Tone.Transport.schedule(() => {
          piano.triggerAttackRelease(notes, '2n');
        }, time);
      });
      
      if (!window.Tone.Transport.started) {
        window.Tone.Transport.start();
      }
      
      console.log('‚úÖ Akkordfolge wird abgespielt');
    } else {
      console.warn('Piano nicht verf√ºgbar');
    }
  }
  
  function getChordNotes(chord) {
    console.log('üé∏ getChordNotes aufgerufen mit:', chord);
    
    // Verwende die vorhandenen CHORDS-Definitionen
    if (CHORDS[chord]) {
      console.log('üé∏ Verwende CHORDS-Definition f√ºr:', chord, CHORDS[chord]);
      return CHORDS[chord].map(note => note + '4'); // Oktave 4 hinzuf√ºgen
    }
    
    // Fallback: Parse Akkord und berechne Noten
    const parsed = parseChord(chord);
    if (!parsed) {
      console.warn('‚ùå Konnte Akkord nicht parsen:', chord);
      return ['C4', 'E4', 'G4'];
    }
    
    const root = parsed.root;
    const quality = parsed.quality;
    
    console.log('üé∏ Parse Akkord:', chord, 'Root:', root, 'Quality:', quality);
    
    // Korrekte Akkord-Noten basierend auf Musiktheorie
    const notes = [];
    
    switch (quality) {
      case 'maj':
      case '':
        // Dur: 1-3-5 (z.B. C-Dur: C-E-G)
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 7));
        break;
      case 'min':
      case 'm':
        // Moll: 1-b3-5 (z.B. Am: A-C-E)
        notes.push(root + '4', transposeNote(root, 3), transposeNote(root, 7));
        break;
      case '7':
        // Dominant-Septakkord: 1-3-5-b7 (z.B. G7: G-B-D-F)
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 7), transposeNote(root, 10));
        break;
      case 'm7':
        // Moll-Septakkord: 1-b3-5-b7 (z.B. Am7: A-C-E-G)
        notes.push(root + '4', transposeNote(root, 3), transposeNote(root, 7), transposeNote(root, 10));
        break;
      case 'maj7':
        // Dur-Septakkord: 1-3-5-7 (z.B. Cmaj7: C-E-G-B)
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 7), transposeNote(root, 11));
        break;
      case 'dim':
        // Verminderter Akkord: 1-b3-b5 (z.B. Cdim: C-Eb-Gb)
        notes.push(root + '4', transposeNote(root, 3), transposeNote(root, 6));
        break;
      case 'aug':
        // √úberm√§√üiger Akkord: 1-3-#5 (z.B. Caug: C-E-G#)
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 8));
        break;
      case 'sus2':
        // Sus2: 1-2-5 (z.B. Csus2: C-D-G)
        notes.push(root + '4', transposeNote(root, 2), transposeNote(root, 7));
        break;
      case 'sus4':
        // Sus4: 1-4-5 (z.B. Csus4: C-F-G)
        notes.push(root + '4', transposeNote(root, 5), transposeNote(root, 7));
        break;
      case 'add9':
        // Add9: 1-3-5-9 (z.B. Cadd9: C-E-G-D)
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 7), transposeNote(root, 14));
        break;
      default:
        // Standard Dur
        notes.push(root + '4', transposeNote(root, 4), transposeNote(root, 7));
    }
    
    console.log('üé∏ Berechnete Noten f√ºr', chord, ':', notes);
    return notes;
  }

  // Removed testRealChord function - only for development

  // Direkte Test-Funktion f√ºr echte Akkorde
  function testRealChord(chordName = 'C') {
    if (!window.Tone) {
      console.error('‚ùå Tone.js nicht verf√ºgbar');
      showNotification('‚ùå Tone.js nicht verf√ºgbar', 'Bitte aktivieren Sie Audio', 'error');
      return;
    }
    
    console.log('üé∏ Teste echten Akkord:', chordName);
    
    // Audio Context starten
    if (window.Tone.context.state !== 'running') {
      window.Tone.context.resume();
    }
    
    // Stoppe vorherige Wiedergabe
    if (window.Tone.Transport.state === 'started') {
      window.Tone.Transport.stop();
      window.Tone.Transport.cancel();
    }
    
    // Professioneller Gitarren-Synthesizer
    const guitarSynth = new window.Tone.PolySynth(window.Tone.Synth, {
      oscillator: { 
        type: 'triangle',
        phase: 0
      },
      envelope: { 
        attack: 0.05, 
        decay: 0.2, 
        sustain: 0.3, 
        release: 0.5 
      },
      filter: {
        type: 'lowpass',
        frequency: 2000,
        rolloff: -12
      }
    }).toDestination();
    
    // Reverb f√ºr nat√ºrlicheren Klang
    const reverb = new window.Tone.Reverb(1.5).toDestination();
    guitarSynth.connect(reverb);
    
    // Verwende echte Akkord-Definitionen
    let notes;
    if (CHORDS[chordName]) {
      notes = CHORDS[chordName].map(note => note + '4');
      console.log('üéµ Verwende echte Akkord-Definition:', chordName, notes);
    } else {
      notes = getChordNotes(chordName);
      console.log('üéµ Berechnete Noten:', chordName, notes);
    }
    
    // Akkord 3x wiederholen
    for (let i = 0; i < 3; i++) {
      window.Tone.Transport.schedule(() => {
        guitarSynth.triggerAttackRelease(notes, '2n');
      }, i * 2); // 2 Sekunden Abstand
    }
    
    window.Tone.Transport.start();
    
    showNotification('üé∏ Echter Akkord-Test abgespielt', `${chordName}: ${notes.join(', ')} - 3x wiederholt`, 'success');
  }

  // Verbesserte Test-Funktion f√ºr echte Akkorde
  function testChordAudio(chordName = 'C') {
    if (!window.Tone) {
      console.error('‚ùå Tone.js nicht verf√ºgbar');
      showNotification('‚ùå Tone.js nicht verf√ºgbar', 'Bitte aktivieren Sie Audio', 'error');
      return;
    }
    
    console.log('üé∏ Teste echten Akkord-Audio f√ºr:', chordName);
    
    // Audio Context starten
    if (window.Tone.context.state !== 'running') {
      window.Tone.context.resume();
    }
    
    // Stoppe vorherige Wiedergabe
    if (window.Tone.Transport.state === 'started') {
      window.Tone.Transport.stop();
      window.Tone.Transport.cancel();
    }
    
    // Professioneller Gitarren-Synthesizer
    const guitarSynth = new window.Tone.PolySynth(window.Tone.Synth, {
      oscillator: { 
        type: 'triangle',
        phase: 0
      },
      envelope: { 
        attack: 0.05, 
        decay: 0.2, 
        sustain: 0.3, 
        release: 0.5 
      },
      filter: {
        type: 'lowpass',
        frequency: 2000,
        rolloff: -12
      }
    }).toDestination();
    
    // Reverb f√ºr nat√ºrlicheren Klang
    const reverb = new window.Tone.Reverb(1.5).toDestination();
    guitarSynth.connect(reverb);
    
    const notes = getChordNotes(chordName);
    console.log('üéµ Teste echte Noten:', notes);
    
    // Akkord 3x wiederholen
    for (let i = 0; i < 3; i++) {
      window.Tone.Transport.schedule(() => {
        guitarSynth.triggerAttackRelease(notes, '2n');
      }, i * 2); // 2 Sekunden Abstand
    }
    
    window.Tone.Transport.start();
    
    showNotification('üé∏ Echter Akkord-Test abgespielt', `${chordName}: ${notes.join(', ')} - 3x wiederholt`, 'success');
  }


  
  function transposeNote(note, semitones) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const noteIndex = notes.indexOf(note);
    if (noteIndex === -1) return note;
    
    const newIndex = (noteIndex + semitones) % 12;
    return notes[newIndex] + '4';
  }
  
  function analyzeProgression(progressionString) {
    const chords = progressionString.split(',');
    console.log('üîç Analysiere Akkordfolge:', chords);
    
    const progressionAnalysis = document.getElementById('progressionAnalysis');
    if (progressionAnalysis) {
      let analysis = `
        <div style="padding:15px; background:#f0f8ff; border-radius:8px; margin:15px 0; border-left:4px solid #007acc;">
          <h4>üîç Akkordfolgen-Analyse</h4>
          <div style="margin:15px 0;">
            <strong>Anzahl Akkorde:</strong> ${chords.length}<br>
            <strong>Tonart-Vorschlag:</strong> ${suggestKey(chords)}<br>
            <strong>Harmonische Funktion:</strong> ${analyzeHarmonicFunction(chords)}
          </div>
          <div style="margin:15px 0;">
            <strong>Verwendung:</strong> ${suggestUsage(chords)}
          </div>
        </div>
      `;
      
      progressionAnalysis.innerHTML += analysis;
    }
  }
  
  function suggestKey(chords) {
    // Korrekte Tonart-Erkennung basierend auf Musiktheorie
    if (!chords || chords.length === 0) return 'Unbekannt';
    
    // Akkord-Roots extrahieren
    const roots = chords.map(chord => {
      const parsed = parseChord(chord);
      return parsed ? parsed.root : null;
    }).filter(root => root !== null);
    
    if (roots.length === 0) return 'Unbekannt';
    
    // H√§ufigste Root finden
    const rootCounts = {};
    roots.forEach(root => {
      rootCounts[root] = (rootCounts[root] || 0) + 1;
    });
    
    const mostCommonRoot = Object.keys(rootCounts).reduce((a, b) => 
      rootCounts[a] > rootCounts[b] ? a : b
    );
    
    // Dur oder Moll bestimmen (vereinfacht - basierend auf h√§ufigsten Akkorden)
    const majorChords = chords.filter(chord => {
      const parsed = parseChord(chord);
      return parsed && (parsed.quality === 'maj' || parsed.quality === '');
    }).length;
    
    const minorChords = chords.filter(chord => {
      const parsed = parseChord(chord);
      return parsed && (parsed.quality === 'min' || parsed.quality === 'm');
    }).length;
    
    const quality = majorChords >= minorChords ? 'Dur' : 'Moll';
    
    return `${mostCommonRoot} ${quality}`;
  }
  
  function analyzeHarmonicFunction(chords) {
    if (chords.length < 2) return 'Zu kurz f√ºr Analyse';
    
    // Korrekte harmonische Funktionsanalyse basierend auf Musiktheorie
    const parsedChords = chords.map(chord => parseChord(chord)).filter(chord => chord !== null);
    
    if (parsedChords.length < 2) return 'Keine g√ºltigen Akkorde';
    
    // Tonart bestimmen
    const key = suggestKey(chords);
    const keyRoot = key.split(' ')[0];
    
    // Harmonische Funktionen in Dur
    const majorFunctions = {
      'I': ['C', 'F', 'G'],      // Tonika
      'ii': ['Dm', 'Am'],        // Subdominante
      'iii': ['Em', 'Bm'],       // Mediante
      'IV': ['F', 'Bb'],         // Subdominante
      'V': ['G', 'D'],           // Dominante
      'vi': ['Am', 'Em'],        // Submediante
      'vii¬∞': ['Bdim', 'F#dim'] // Leitton
    };
    
    // Harmonische Funktionen in Moll
    const minorFunctions = {
      'i': ['Am', 'Em'],         // Tonika
      'ii¬∞': ['Bdim', 'F#dim'],  // Supertonika
      'III': ['C', 'G'],         // Mediante
      'iv': ['Dm', 'Am'],        // Subdominante
      'v': ['Em', 'Bm'],         // Dominante
      'VI': ['F', 'C'],          // Submediante
      'VII': ['G', 'D']          // Subtonika
    };
    
    // Funktionen der Akkorde bestimmen
    const functions = parsedChords.map(chord => {
      const chordName = chord.root + (chord.quality === 'maj' ? '' : chord.quality === 'min' ? 'm' : chord.quality);
      
      // In Dur suchen
      for (const [functionName, chordNames] of Object.entries(majorFunctions)) {
        if (chordNames.includes(chordName)) {
          return functionName;
        }
      }
      
      // In Moll suchen
      for (const [functionName, chordNames] of Object.entries(minorFunctions)) {
        if (chordNames.includes(chordName)) {
          return functionName;
        }
      }
      
      return '?';
    });
    
    // Kadenz-Analyse
    const cadence = analyzeCadence(functions);
    
    return `Funktionen: ${functions.join(' ‚Üí ')} | ${cadence}`;
  }
  
  function analyzeCadence(functions) {
    if (functions.length < 2) return 'Keine Kadenz';
    
    const lastTwo = functions.slice(-2);
    
    if (lastTwo.join('') === 'V7I' || lastTwo.join('') === 'VI') {
      return 'Authentische Kadenz';
    } else if (lastTwo.join('') === 'IVI') {
      return 'Plagale Kadenz';
    } else if (lastTwo.join('') === 'iiV') {
      return 'Halbschluss';
    } else {
      return 'Andere Progression';
    }
  }
  
  function suggestUsage(chords) {
    const length = chords.length;
    if (length === 2) return 'Intro, Bridge, Outro';
    if (length === 3) return 'Verse, Chorus';
    if (length === 4) return 'Standard-Song-Struktur';
    if (length >= 8) return 'Komplexe Komposition';
    return 'Flexibel einsetzbar';
  }
  
  function transposeProgression(progressionString, semitones) {
    const chords = progressionString.split(',');
    console.log(`üéµ Transponiere Akkordfolge um ${semitones} Halbt√∂ne:`, chords);
    
    const transposedChords = chords.map(chord => {
      return transposeChord(chord, semitones);
    });
    
    console.log('‚úÖ Transponierte Akkorde:', transposedChords);
    
    // Transponierte Akkorde laden
    loadProgression(transposedChords.join(' '));
  }
  
  function transposeChord(chord, semitones) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const match = chord.match(/^([A-G][#b]?)(.*)$/);
    
    if (!match) return chord;
    
    const [, root, quality] = match;
    const noteIndex = notes.indexOf(root);
    
    if (noteIndex === -1) return chord;
    
    const newIndex = (noteIndex + semitones + 12) % 12;
    const newRoot = notes[newIndex];
    
    return newRoot + quality;
  }
  
  function showCadences() {
    const functionalTheory = document.getElementById('functionalTheory');
    
    const cadences = {
      'Authentische Kadenz': 'V ‚Üí I (vollst√§ndige Aufl√∂sung)',
      'Plagale Kadenz': 'IV ‚Üí I (sanfte Aufl√∂sung)',
      'Deceptive Cadence': 'V ‚Üí vi (unerwartete Aufl√∂sung)',
      'Half Cadence': 'Endet auf V (offene Spannung)',
      'Picardy Third': 'Moll ‚Üí Dur (√ºberraschende Dur-Aufl√∂sung)'
    };
    
    let html = `<h4>üéº Kadenzen</h4>`;
    
    Object.entries(cadences).forEach(([name, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong> ${description}`;
      html += `</div>`;
    });
    
    functionalTheory.innerHTML = html;
  }
  
  function showModulations() {
    const functionalTheory = document.getElementById('functionalTheory');
    
    const modulations = {
      'Paralleltonart': 'C ‚Üí Am (gleiche Vorzeichen)',
      'Dominanttonart': 'C ‚Üí G (5 Halbt√∂ne h√∂her)',
      'Subdominanttonart': 'C ‚Üí F (5 Halbt√∂ne tiefer)',
      'Relative Moll': 'C ‚Üí Am (3 Halbt√∂ne tiefer)',
      'Enharmonische': 'C# ‚Üí Db (gleiche T√∂ne, andere Schreibweise)'
    };
    
    let html = `<h4>üéπ Modulationen</h4>`;
    
    Object.entries(modulations).forEach(([name, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong> ${description}`;
      html += `</div>`;
    });
    
    functionalTheory.innerHTML = html;
  }

  // ---------- Geh√∂rbildungs-Funktionen ----------
  let currentInterval = null;
  let currentChord = null;
  let currentMelody = null;
  let currentRhythm = null;
  let intervalTrainingActive = false;
  let chordRecognitionActive = false;
  let melodyRecognitionActive = false;
  let rhythmRecognitionActive = false;
  
  const INTERVALS = {
    'Unisono': 0,
    'Kleine Sekunde': 1,
    'Gro√üe Sekunde': 2,
    'Kleine Terz': 3,
    'Gro√üe Terz': 4,
    'Reine Quarte': 5,
    'Tritonus': 6,
    'Reine Quinte': 7,
    'Kleine Sexte': 8,
    'Gro√üe Sexte': 9,
    'Kleine Septime': 10,
    'Gro√üe Septime': 11,
    'Oktave': 12
  };
  
  const CHORDS = {
    'C': ['C', 'E', 'G'],
    'Cm': ['C', 'Eb', 'G'],
    'C7': ['C', 'E', 'G', 'Bb'],
    'Cm7': ['C', 'Eb', 'G', 'Bb'],
    'Cmaj7': ['C', 'E', 'G', 'B'],
    'F': ['F', 'A', 'C'],
    'Fm': ['F', 'Ab', 'C'],
    'G': ['G', 'B', 'D'],
    'G7': ['G', 'B', 'D', 'F'],
    'Am': ['A', 'C', 'E'],
    'Dm': ['D', 'F', 'A'],
    'D': ['D', 'F#', 'A'],
    'A': ['A', 'C#', 'E'],
    'E': ['E', 'G#', 'B'],
    'Em': ['E', 'G', 'B'],
    'Bm': ['B', 'D', 'F#'],
    'B': ['B', 'D#', 'F#'],
    'F#m': ['F#', 'A', 'C#'],
    'F#': ['F#', 'A#', 'C#'],
    'C#m': ['C#', 'E', 'G#'],
    'C#': ['C#', 'F', 'G#'],
    'G#m': ['G#', 'B', 'D#'],
    'G#': ['G#', 'C', 'D#'],
    'D#m': ['D#', 'F#', 'A#'],
    'D#': ['D#', 'G', 'A#'],
    'A#m': ['A#', 'C#', 'F'],
    'A#': ['A#', 'D', 'F'],
    // Erweiterte Akkorde f√ºr bessere Unterst√ºtzung
    'Cadd9': ['C', 'E', 'G', 'D'],
    'Csus2': ['C', 'D', 'G'],
    'Csus4': ['C', 'F', 'G'],
    'Fadd9': ['F', 'A', 'C', 'G'],
    'Fsus2': ['F', 'G', 'C'],
    'Fsus4': ['F', 'Bb', 'C'],
    'Gadd9': ['G', 'B', 'D', 'A'],
    'Gsus2': ['G', 'A', 'D'],
    'Gsus4': ['G', 'C', 'D'],
    'Am7': ['A', 'C', 'E', 'G'],
    'Dm7': ['D', 'F', 'A', 'C'],
    'Em7': ['E', 'G', 'B', 'D'],
    'Bm7': ['B', 'D', 'F#', 'A'],
    // Zus√§tzliche Akkorde f√ºr bessere Abdeckung
    'Cdim': ['C', 'Eb', 'Gb'],
    'Caug': ['C', 'E', 'G#'],
    'Fdim': ['F', 'Ab', 'Cb'],
    'Faug': ['F', 'A', 'C#'],
    'Gdim': ['G', 'Bb', 'Db'],
    'Gaug': ['G', 'B', 'D#'],
    'Adim': ['A', 'C', 'Eb'],
    'Aaug': ['A', 'C#', 'F'],
    'Ddim': ['D', 'F', 'Ab'],
    'Daug': ['D', 'F#', 'A#'],
    'Edim': ['E', 'G', 'Bb'],
    'Eaug': ['E', 'G#', 'C'],
    'Bdim': ['B', 'D', 'F'],
    'Baug': ['B', 'D#', 'G']
  };
  
  function startIntervalTraining() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    intervalTrainingActive = true;
    const intervalTraining = document.getElementById('intervalTraining');
    
    // Zuf√§lliges Intervall ausw√§hlen
    const intervalNames = Object.keys(INTERVALS);
    const randomInterval = intervalNames[Math.floor(Math.random() * intervalNames.length)];
    currentInterval = randomInterval;
    
    intervalTraining.innerHTML = `
      <h4>üéµ Intervall-Training</h4>
      <p><strong>H√∂ren Sie sich das Intervall an:</strong></p>
      <div class="controls">
        <button onclick="playInterval()" class="btn">üîä Abspielen</button>
        <button onclick="playIntervalAgain()" class="btn">üîÑ Nochmal</button>
      </div>
      <div style="margin-top:15px;">
        <p><strong>Was ist das f√ºr ein Intervall?</strong></p>
        <select id="intervalAnswer" style="width:100%; margin:10px 0;">
          ${intervalNames.map(name => `<option value="${name}">${name}</option>`).join('')}
        </select>
        <button onclick="checkIntervalAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
      </div>
    `;
    
    // Sofort abspielen
    setTimeout(playInterval, 500);
  }
  
  function playInterval() {
    if (!currentInterval || !window.Tone) return;
    
    const synth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
    }).toDestination();
    
    const semitones = INTERVALS[currentInterval];
    const note1 = 'C4';
    const note2 = Tone.Frequency('C4').transpose(semitones).toNote();
    
    // Erste Note
    synth.triggerAttackRelease(note1, '2n');
    
    // Zweite Note nach 1 Sekunde
    setTimeout(() => {
      synth.triggerAttackRelease(note2, '2n');
    }, 1000);
  }
  
  function playIntervalAgain() {
    playInterval();
  }
  
  function checkIntervalAnswer() {
    const answer = document.getElementById('intervalAnswer').value;
    const intervalTraining = document.getElementById('intervalTraining');
    
    if (answer === currentInterval) {
      intervalTraining.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#d4edda; border-radius:8px; color:#155724;">
          <strong>‚úÖ Richtig!</strong> Das war eine ${currentInterval}.
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="startIntervalTraining()" class="btn">üéµ N√§chstes Intervall</button>
          <button onclick="stopIntervalTraining()" class="btn">‚èπ Beenden</button>
        </div>
      `;
    } else {
      intervalTraining.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#f8d7da; border-radius:8px; color:#721c24;">
          <strong>‚ùå Falsch!</strong> Das war eine ${currentInterval}, nicht ${answer}.
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="playInterval()" class="btn">üîä Nochmal h√∂ren</button>
          <button onclick="startIntervalTraining()" class="btn">üéµ N√§chstes Intervall</button>
        </div>
      `;
    }
  }
  
  function stopIntervalTraining() {
    intervalTrainingActive = false;
    currentInterval = null;
    const intervalTraining = document.getElementById('intervalTraining');
    intervalTraining.innerHTML = '<p>Klicken Sie auf "Starten" um mit dem Intervall-Training zu beginnen...</p>';
  }
  
  function startChordRecognition() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    chordRecognitionActive = true;
    const chordRecognition = document.getElementById('chordRecognition');
    
    // Zuf√§lligen Akkord ausw√§hlen
    const chordNames = Object.keys(CHORDS);
    const randomChord = chordNames[Math.floor(Math.random() * chordNames.length)];
    currentChord = randomChord;
    
    chordRecognition.innerHTML = `
      <h4>üéº Akkord-Erkennung</h4>
      <p><strong>H√∂ren Sie sich den Akkord an:</strong></p>
      <div class="controls">
        <button onclick="playChordForRecognition()" class="btn">üîä Abspielen</button>
        <button onclick="playChordForRecognition()" class="btn">üîÑ Nochmal</button>
      </div>
      <div style="margin-top:15px;">
        <p><strong>Welcher Akkord ist das?</strong></p>
        <select id="chordAnswer" style="width:100%; margin:10px 0;">
          ${chordNames.map(name => `<option value="${name}">${name}</option>`).join('')}
        </select>
        <button onclick="checkChordAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
      </div>
    `;
    
    // Sofort abspielen
    setTimeout(playChordForRecognition, 500);
  }
  
  function playChordForRecognition() {
    if (!currentChord) return;
    
    // Use enhanced audio system if available
    if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
      try {
        const instrument = window.currentInstrument || 'acoustic-guitar';
        const instrumentType = instrument.split('-')[1] || 'guitar';
        const instrumentCategory = instrument.split('-')[0] || 'acoustic';
        
        window.enhancedAudioSystem.playChord(currentChord, instrumentType, instrumentCategory);
        console.log('üé∏ Enhanced Audio System f√ºr Akkord-Erkennung:', currentChord);
        return;
      } catch (error) {
        console.error('‚ùå Fehler mit Enhanced Audio System:', error);
        // Fallback to original method
      }
    }
    
    // Fallback to original Tone.js method
    if (!window.Tone) {
      showNotification('üîä Audio System nicht verf√ºgbar', 'Bitte aktivieren Sie Audio', 'error');
      return;
    }
    
    // Professioneller Gitarren-Synthesizer f√ºr Akkord-Erkennung
    const guitarSynth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { 
        type: 'triangle',
        phase: 0
      },
      envelope: { 
        attack: 0.05, 
        decay: 0.3, 
        sustain: 0.4, 
        release: 0.8 
      },
      filter: {
        type: 'lowpass',
        frequency: 2500,
        rolloff: -12
      }
    }).toDestination();
    
    // Verwende getChordNotes f√ºr korrekte Noten-Berechnung
    const notes = getChordNotes(currentChord);
    
    console.log('üé∏ Spiele echten Gitarren-Akkord f√ºr Erkennung:', currentChord, 'Noten:', notes);
    
    guitarSynth.triggerAttackRelease(notes, '2n');
  }
  
  function checkChordAnswer() {
    const answer = document.getElementById('chordAnswer').value;
    const chordRecognition = document.getElementById('chordRecognition');
    
    if (answer === currentChord) {
      chordRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#d4edda; border-radius:8px; color:#155724;">
          <strong>‚úÖ Richtig!</strong> Das war ein ${currentChord} Akkord.
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="startChordRecognition()" class="btn">üéµ N√§chster Akkord</button>
          <button onclick="stopChordRecognition()" class="btn">‚èπ Beenden</button>
        </div>
      `;
    } else {
      chordRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#f8d7da; border-radius:8px; color:#721c24;">
          <strong>‚ùå Falsch!</strong> Das war ein ${currentChord} Akkord, nicht ${answer}.
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="playChordForRecognition()" class="btn">üîä Nochmal h√∂ren</button>
          <button onclick="startChordRecognition()" class="btn">üéµ N√§chster Akkord</button>
        </div>
      `;
    }
  }
  
  function stopChordRecognition() {
    chordRecognitionActive = false;
    currentChord = null;
    const chordRecognition = document.getElementById('chordRecognition');
    chordRecognition.innerHTML = '<p>Klicken Sie auf "Starten" um mit der Akkord-Erkennung zu beginnen...</p>';
  }
  
  function startMelodyRecognition() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    melodyRecognitionActive = true;
    const melodyRecognition = document.getElementById('melodyRecognition');
    
    // Einfache Melodie erstellen
    const melodies = {
      'C-Dur Tonleiter aufw√§rts': ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'],
      'A-Moll Tonleiter abw√§rts': ['A4', 'G4', 'F4', 'E4', 'D4', 'C4', 'B3', 'A3'],
      'C-Dur Dreiklang': ['C4', 'E4', 'G4', 'C5'],
      'Pentatonische Melodie': ['C4', 'D4', 'E4', 'G4', 'A4']
    };
    
    const melodyNames = Object.keys(melodies);
    const randomMelody = melodyNames[Math.floor(Math.random() * melodyNames.length)];
    currentMelody = { name: randomMelody, notes: melodies[randomMelody] };
    
    melodyRecognition.innerHTML = `
      <h4>üéµ Melodie-Erkennung</h4>
      <p><strong>H√∂ren Sie sich die Melodie an:</strong></p>
      <div class="controls">
        <button onclick="playMelodyForRecognition()" class="btn">üîä Abspielen</button>
        <button onclick="playMelodyForRecognition()" class="btn">üîÑ Nochmal</button>
      </div>
      <div style="margin-top:15px;">
        <p><strong>Welche Melodie ist das?</strong></p>
        <select id="melodyAnswer" style="width:100%; margin:10px 0;">
          ${melodyNames.map(name => `<option value="${name}">${name}</option>`).join('')}
        </select>
        <button onclick="checkMelodyAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
      </div>
    `;
    
    // Sofort abspielen
    setTimeout(playMelodyForRecognition, 500);
  }
  
  function playMelodyForRecognition() {
    if (!currentMelody || !window.Tone) return;
    
    const synth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.4 }
    }).toDestination();
    
    currentMelody.notes.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note, '4n');
      }, index * 400);
    });
  }
  
  function checkMelodyAnswer() {
    const answer = document.getElementById('melodyAnswer').value;
    const melodyRecognition = document.getElementById('melodyRecognition');
    
    if (answer === currentMelody.name) {
      melodyRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#d4edda; border-radius:8px; color:#155724;">
          <strong>‚úÖ Richtig!</strong> Das war "${currentMelody.name}".
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="startMelodyRecognition()" class="btn">üéµ N√§chste Melodie</button>
          <button onclick="stopMelodyRecognition()" class="btn">‚èπ Beenden</button>
        </div>
      `;
    } else {
      melodyRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#f8d7da; border-radius:8px; color:#721c24;">
          <strong>‚ùå Falsch!</strong> Das war "${currentMelody.name}", nicht "${answer}".
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="playMelodyForRecognition()" class="btn">üîä Nochmal h√∂ren</button>
          <button onclick="startMelodyRecognition()" class="btn">üéµ N√§chste Melodie</button>
        </div>
      `;
    }
  }
  
  function stopMelodyRecognition() {
    melodyRecognitionActive = false;
    currentMelody = null;
    const melodyRecognition = document.getElementById('melodyRecognition');
    melodyRecognition.innerHTML = '<p>Klicken Sie auf "Starten" um mit der Melodie-Erkennung zu beginnen...</p>';
  }
  
  function startRhythmRecognition() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    rhythmRecognitionActive = true;
    const rhythmRecognition = document.getElementById('rhythmRecognition');
    
    // Rhythmus-Patterns
    const rhythms = {
      'Grundschlag': ['x', '-', 'x', '-', 'x', '-', 'x', '-'],
      'Waltz': ['x', '-', '-', 'x', '-', '-', 'x', '-'],
      'Shuffle': ['x', '-', 'x', '-', 'x', '-', 'x', '-'],
      'Bossa Nova': ['x', '-', 'x', '-', '-', 'x', '-', 'x']
    };
    
    const rhythmNames = Object.keys(rhythms);
    const randomRhythm = rhythmNames[Math.floor(Math.random() * rhythmNames.length)];
    currentRhythm = { name: randomRhythm, pattern: rhythms[randomRhythm] };
    
    rhythmRecognition.innerHTML = `
      <h4>ü•Å Rhythmus-Erkennung</h4>
      <p><strong>H√∂ren Sie sich den Rhythmus an:</strong></p>
      <div class="controls">
        <button onclick="playRhythmForRecognition()" class="btn">üîä Abspielen</button>
        <button onclick="playRhythmForRecognition()" class="btn">üîÑ Nochmal</button>
      </div>
      <div style="margin-top:15px;">
        <p><strong>Welcher Rhythmus ist das?</strong></p>
        <select id="rhythmAnswer" style="width:100%; margin:10px 0;">
          ${rhythmNames.map(name => `<option value="${name}">${name}</option>`).join('')}
        </select>
        <button onclick="checkRhythmAnswer()" class="btn">‚úÖ Antwort pr√ºfen</button>
      </div>
    `;
    
    // Sofort abspielen
    setTimeout(playRhythmForRecognition, 500);
  }
  
  function playRhythmForRecognition() {
    if (!currentRhythm || !window.Tone) return;
    
    const synth = new Tone.Synth({
      oscillator: { type: 'square' },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    
    currentRhythm.pattern.forEach((beat, index) => {
      if (beat === 'x') {
        setTimeout(() => {
          synth.triggerAttackRelease('C4', '8n');
        }, index * 250);
      }
    });
  }
  
  function checkRhythmAnswer() {
    const answer = document.getElementById('rhythmAnswer').value;
    const rhythmRecognition = document.getElementById('rhythmRecognition');
    
    if (answer === currentRhythm.name) {
      rhythmRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#d4edda; border-radius:8px; color:#155724;">
          <strong>‚úÖ Richtig!</strong> Das war "${currentRhythm.name}".
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="startRhythmRecognition()" class="btn">ü•Å N√§chster Rhythmus</button>
          <button onclick="stopRhythmRecognition()" class="btn">‚èπ Beenden</button>
        </div>
      `;
    } else {
      rhythmRecognition.innerHTML += `
        <div style="margin-top:15px; padding:10px; background:#f8d7da; border-radius:8px; color:#721c24;">
          <strong>‚ùå Falsch!</strong> Das war "${currentRhythm.name}", nicht "${answer}".
        </div>
        <div class="controls" style="margin-top:15px;">
          <button onclick="playRhythmForRecognition()" class="btn">üîä Nochmal h√∂ren</button>
          <button onclick="startRhythmRecognition()" class="btn">ü•Å N√§chster Rhythmus</button>
        </div>
      `;
    }
  }
  
  function stopRhythmRecognition() {
    rhythmRecognitionActive = false;
    currentRhythm = null;
    const rhythmRecognition = document.getElementById('rhythmRecognition');
    rhythmRecognition.innerHTML = '<p>Klicken Sie auf "Starten" um mit der Rhythmus-Erkennung zu beginnen...</p>';
  }

  // ---------- Rhythmus-Funktionen ----------
  let drumMachine = null;
  let drumPattern = null;
  let drumMachineActive = false;
  
  function initDrumMachine() {
    if (!window.Tone) {
      showNotification('üîä Audio nicht aktiviert', 'Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button', 'warning');
      return;
    }
    
    try {
      // Drum-Sounds erstellen (mit synthetischen Sounds statt fehlerhaften Base64-URLs)
      // Kick Drum - Bass-Sound
      const kick = new Tone.MonoSynth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 },
        filter: { frequency: 60, type: 'lowpass' }
      }).toDestination();
      
      // Snare Drum - Noise + Tone
      const snare = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 },
        filter: { frequency: 1000, type: 'highpass' }
      }).toDestination();
      
      // Hi-Hat - High-frequency noise
      const hihat = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 },
        filter: { frequency: 8000, type: 'highpass' }
      }).toDestination();
      
      // Fallback: Synthesizer-basierte Drums
      const kickSynth = new Tone.MonoSynth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
      }).toDestination();
      
      const snareSynth = new Tone.MonoSynth({
        oscillator: { type: 'square' },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
      }).toDestination();
      
      const hihatSynth = new Tone.MonoSynth({
        oscillator: { type: 'square' },
        envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 }
      }).toDestination();
      
      drumMachine = {
        kick: kickSynth,
        snare: snareSynth,
        hihat: hihatSynth,
        patterns: {
          basic: {
            kick: [1, 0, 0, 0, 1, 0, 0, 0],
            snare: [0, 0, 1, 0, 0, 0, 1, 0],
            hihat: [1, 1, 1, 1, 1, 1, 1, 1]
          },
          rock: {
            kick: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            snare: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            hihat: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
          },
          funk: {
            kick: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
            snare: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            hihat: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
          },
          jazz: {
            kick: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            snare: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            hihat: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
          }
        }
      };
      
      drumPattern = 'basic';
      
      const drumMachineDiv = document.getElementById('drumMachine');
      drumMachineDiv.innerHTML = createDrumMachineUI();
      
      console.log('Drum Machine erfolgreich initialisiert');
    } catch (e) {
      console.error('Fehler beim Initialisieren der Drum Machine:', e);
    }
  }
  
  function createDrumMachineUI() {
    return `
      <div style="text-align:center;">
        <h4>ü•Å Drum Machine</h4>
        <div style="margin:15px 0;">
          <strong>Pattern:</strong> ${drumPattern}
        </div>
        <div style="display:grid; grid-template-columns: repeat(8, 1fr); gap:5px; margin:15px 0;">
          ${createDrumGrid()}
        </div>
        <div style="margin:15px 0;">
          <strong>BPM:</strong> <input type="range" id="drumBPM" min="60" max="180" value="120" style="width:100px;">
          <span id="drumBPMLabel">120</span>
        </div>
      </div>
    `;
  }
  
  function createDrumGrid() {
    if (!drumMachine || !drumPattern) return '';
    
    const pattern = drumMachine.patterns[drumPattern];
    let html = '';
    
    // Kick Row
    html += '<div style="font-weight:bold; color:#007acc;">Kick</div>';
    pattern.kick.forEach((beat, index) => {
      html += `<div onclick="toggleDrumBeat('kick', ${index})" 
                    style="width:30px; height:30px; background:${beat ? '#007acc' : '#f8f9fa'}; 
                           border:1px solid #dee2e6; cursor:pointer; border-radius:4px;
                           display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">
                    ${beat ? '‚óè' : ''}
                  </div>`;
    });
    
    // Snare Row
    html += '<div style="font-weight:bold; color:#dc3545;">Snare</div>';
    pattern.snare.forEach((beat, index) => {
      html += `<div onclick="toggleDrumBeat('snare', ${index})" 
                    style="width:30px; height:30px; background:${beat ? '#dc3545' : '#f8f9fa'}; 
                           border:1px solid #dee2e6; cursor:pointer; border-radius:4px;
                           display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">
                    ${beat ? '‚óè' : ''}
                  </div>`;
    });
    
    // Hihat Row
    html += '<div style="font-weight:bold; color:#28a745;">Hihat</div>';
    pattern.hihat.forEach((beat, index) => {
      html += `<div onclick="toggleDrumBeat('hihat', ${index})" 
                    style="width:30px; height:30px; background:${beat ? '#28a745' : '#f8f9fa'}; 
                           border:1px solid #dee2e6; cursor:pointer; border-radius:4px;
                           display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">
                    ${beat ? '‚óè' : ''}
                  </div>`;
    });
    
    return html;
  }
  
  function toggleDrumBeat(drum, index) {
    if (!drumMachine || !drumPattern) return;
    
    const pattern = drumMachine.patterns[drumPattern];
    pattern[drum][index] = pattern[drum][index] ? 0 : 1;
    
    // UI aktualisieren
    const drumMachineDiv = document.getElementById('drumMachine');
    drumMachineDiv.innerHTML = createDrumMachineUI();
  }
  
  function toggleDrumMachine() {
    if (!drumMachine) {
      alert('Bitte initialisieren Sie zuerst die Drum Machine');
      return;
    }
    
    if (drumMachineActive) {
      stopDrumMachine();
    } else {
      startDrumMachine();
    }
  }
  
  function startDrumMachine() {
    if (!drumMachine || !window.Tone) return;
    
    drumMachineActive = true;
    const pattern = drumMachine.patterns[drumPattern];
    const bpm = parseInt(document.getElementById('drumBPM').value);
    
    // BPM setzen
    if (Tone.Transport && Tone.Transport.bpm) {
      Tone.Transport.bpm.value = bpm;
    }
    
    // Drum-Loop erstellen
    const drumLoop = new Tone.Part((time, drum) => {
      if (drum.kick) drumMachine.kick.triggerAttackRelease('C2', '8n', time);
      if (drum.snare) drumMachine.snare.triggerAttackRelease('C3', '8n', time);
      if (drum.hihat) drumMachine.hihat.triggerAttackRelease('C5', '8n', time);
    }, [
      ['0:0:0', { kick: pattern.kick[0], snare: pattern.snare[0], hihat: pattern.hihat[0] }],
      ['0:0:2', { kick: pattern.kick[1], snare: pattern.snare[1], hihat: pattern.hihat[1] }],
      ['0:1:0', { kick: pattern.kick[2], snare: pattern.snare[2], hihat: pattern.hihat[2] }],
      ['0:1:2', { kick: pattern.kick[3], snare: pattern.snare[3], hihat: pattern.hihat[3] }],
      ['0:2:0', { kick: pattern.kick[4], snare: pattern.snare[4], hihat: pattern.hihat[4] }],
      ['0:2:2', { kick: pattern.kick[5], snare: pattern.snare[5], hihat: pattern.hihat[5] }],
      ['0:3:0', { kick: pattern.kick[6], snare: pattern.snare[6], hihat: pattern.hihat[6] }],
      ['0:3:2', { kick: pattern.kick[7], snare: pattern.snare[7], hihat: pattern.hihat[7] }]
    ]);
    
    drumLoop.loop = true;
    drumLoop.loopEnd = '1m';
    
    Tone.Transport.start();
    drumLoop.start(0);
    
    // Button-Text √§ndern
    const button = document.querySelector('button[onclick="toggleDrumMachine()"]');
    if (button) button.textContent = '‚è∏ Stoppen';
  }
  
  function stopDrumMachine() {
    if (!drumMachine) return;
    
    drumMachineActive = false;
    
    if (Tone.Transport) {
      Tone.Transport.stop();
      Tone.Transport.position = 0;
    }
    
    // Button-Text √§ndern
    const button = document.querySelector('button[onclick="toggleDrumMachine()"]');
    if (button) button.textContent = '‚ñ∂Ô∏è Starten/Stoppen';
  }
  
  function changeDrumPattern() {
    if (!drumMachine) return;
    
    const patterns = Object.keys(drumMachine.patterns);
    const currentIndex = patterns.indexOf(drumPattern);
    const nextIndex = (currentIndex + 1) % patterns.length;
    drumPattern = patterns[nextIndex];
    
    // UI aktualisieren
    const drumMachineDiv = document.getElementById('drumMachine');
    drumMachineDiv.innerHTML = createDrumMachineUI();
    
    // Falls aktiv, neu starten
    if (drumMachineActive) {
      stopDrumMachine();
      setTimeout(startDrumMachine, 100);
    }
  }
  
  function showRhythmPatterns() {
    const rhythmNotation = document.getElementById('rhythmNotation');
    
    const patterns = {
      'Grundschlag (4/4)': 'x - x - x - x -',
      'Waltz (3/4)': 'x - - x - - x - -',
      'Shuffle (4/4)': 'x - x - x - x -',
      'Bossa Nova (4/4)': 'x - x - - x - x',
      'Samba (2/4)': 'x - x x - x - x',
      'Funk (4/4)': 'x - - x - x - x',
      'Jazz (4/4)': 'x - - - x - - -',
      'Rock (4/4)': 'x - - x - - x -'
    };
    
    let html = `<h4>üéµ Rhythmus-Patterns</h4>`;
    
    Object.entries(patterns).forEach(([name, pattern]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:18px;">${pattern}</span>`;
      html += `</div>`;
    });
    
    rhythmNotation.innerHTML = html;
  }
  
  function showRhythmExercises() {
    const rhythmNotation = document.getElementById('rhythmNotation');
    
    const exercises = {
      'Grundlagen': 'Klopfen Sie den Grundschlag mit dem Fu√ü: x - x - x - x -',
      'Syncopation': 'Betonen Sie die Offbeats: - x - x - x - x',
      'Polyrhythmen': 'Linke Hand: x - x - x - x -, Rechte Hand: x - - x - - x - -',
      'Ungerade Takte': '5/4 Takt: x - x - x - x - x -',
      'Komplexe Patterns': 'Kombinieren Sie verschiedene Schlaginstrumente'
    };
    
    let html = `<h4>üéº Rhythmus-√úbungen</h4>`;
    
    Object.entries(exercises).forEach(([name, description]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span>${description}</span>`;
      html += `</div>`;
    });
    
    rhythmNotation.innerHTML = html;
  }
  
  function startRhythmExercise(type) {
    const rhythmExercise = document.getElementById('rhythmExercise');
    
    switch(type) {
      case 'basic':
        rhythmExercise.innerHTML = `
          <h4>üéµ Grundlagen-√úbung</h4>
          <p>Klopfen Sie den Grundschlag mit dem Fu√ü:</p>
          <div style="font-family:monospace; font-size:24px; text-align:center; margin:20px 0;">
            x - x - x - x -
          </div>
          <div class="controls">
            <button onclick="playRhythmExercise('basic')" class="btn">ü•Å Abspielen</button>
            <button onclick="showRhythmExercise('basic')" class="btn">üëÅÔ∏è Anzeigen</button>
          </div>
        `;
        break;
      case 'syncopation':
        rhythmExercise.innerHTML = `
          <h4>üéº Syncopation-√úbung</h4>
          <p>Betonen Sie die Offbeats:</p>
          <div style="font-family:monospace; font-size:24px; text-align:center; margin:20px 0;">
            - x - x - x - x
          </div>
          <div class="controls">
            <button onclick="playRhythmExercise('syncopation')" class="btn">ü•Å Abspielen</button>
            <button onclick="showRhythmExercise('syncopation')" class="btn">üëÅÔ∏è Anzeigen</button>
          </div>
        `;
        break;
      case 'polyrhythm':
        rhythmExercise.innerHTML = `
          <h4>üéπ Polyrhythmen-√úbung</h4>
          <p>Linke Hand: x - x - x - x -<br>Rechte Hand: x - - x - - x - -</p>
          <div class="controls">
            <button onclick="playRhythmExercise('polyrhythm')" class="btn">ü•Å Abspielen</button>
            <button onclick="showRhythmExercise('polyrhythm')" class="btn">üëÅÔ∏è Anzeigen</button>
          </div>
        `;
        break;
      case 'odd':
        rhythmExercise.innerHTML = `
          <h4>üéº Ungerade Takte-√úbung</h4>
          <p>5/4 Takt: x - x - x - x - x -</p>
          <div style="font-family:monospace; font-size:24px; text-align:center; margin:20px 0;">
            x - x - x - x - x -
          </div>
          <div class="controls">
            <button onclick="playRhythmExercise('odd')" class="btn">ü•Å Abspielen</button>
            <button onclick="showRhythmExercise('odd')" class="btn">üëÅÔ∏è Anzeigen</button>
          </div>
        `;
        break;
    }
  }
  
  function playRhythmExercise(type) {
    if (!window.Tone) return;
    
    const synth = new Tone.Synth({
      oscillator: { type: 'square' },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    
    switch(type) {
      case 'basic':
        // Grundschlag: x - x - x - x -
        [0, 2, 4, 6].forEach(beat => {
          setTimeout(() => {
            synth.triggerAttackRelease('C4', '8n');
          }, beat * 250);
        });
        break;
      case 'syncopation':
        // Syncopation: - x - x - x - x
        [1, 3, 5, 7].forEach(beat => {
          setTimeout(() => {
            synth.triggerAttackRelease('C4', '8n');
          }, beat * 250);
        });
        break;
      case 'polyrhythm':
        // Linke Hand: x - x - x - x -
        [0, 2, 4, 6].forEach(beat => {
          setTimeout(() => {
            synth.triggerAttackRelease('C3', '8n');
          }, beat * 250);
        });
        // Rechte Hand: x - - x - - x - -
        [0, 3, 6].forEach(beat => {
          setTimeout(() => {
            synth.triggerAttackRelease('C5', '8n');
          }, beat * 250);
        });
        break;
      case 'odd':
        // 5/4 Takt: x - x - x - x - x -
        [0, 2, 4, 6, 8].forEach(beat => {
          setTimeout(() => {
            synth.triggerAttackRelease('C4', '8n');
          }, beat * 200);
        });
        break;
    }
  }
  
  function showRhythmExercise(type) {
    const rhythmExercise = document.getElementById('rhythmExercise');
    
    let html = '';
    switch(type) {
      case 'basic':
        html = `
          <div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">
            <h5>üéµ Grundschlag-Notation:</h5>
            <div style="font-family:monospace; font-size:16px; line-height:1.6;">
              <div>Viertelnoten: ‚ô© ‚ô© ‚ô© ‚ô©</div>
              <div>Z√§hlweise: 1 2 3 4</div>
              <div>Fu√ü: x - x - x - x -</div>
            </div>
          </div>
        `;
        break;
      case 'syncopation':
        html = `
          <div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">
            <h5>üéº Syncopation-Notation:</h5>
            <div style="font-family:monospace; font-size:16px; line-height:1.6;">
              <div>Offbeats: ‚ô™ ‚ô™ ‚ô™ ‚ô™</div>
              <div>Z√§hlweise: - 2 - 4</div>
              <div>Hand: - x - x - x - x</div>
            </div>
          </div>
        `;
        break;
      case 'polyrhythm':
        html = `
          <div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">
            <h5>üéπ Polyrhythmen-Notation:</h5>
            <div style="font-family:monospace; font-size:16px; line-height:1.6;">
              <div>Linke Hand: ‚ô© ‚ô© ‚ô© ‚ô© (4/4)</div>
              <div>Rechte Hand: ‚ô© ‚ô© ‚ô© (3/4)</div>
              <div>Gemeinsamer Takt: 12 Schl√§ge</div>
            </div>
          </div>
        `;
        break;
      case 'odd':
        html = `
          <div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">
            <h5>üéº Ungerade Takte-Notation:</h5>
            <div style="font-family:monospace; font-size:16px; line-height:1.6;">
              <div>5/4 Takt: ‚ô© ‚ô© ‚ô© ‚ô© ‚ô©</div>
              <div>Z√§hlweise: 1 2 3 4 5</div>
              <div>Schl√§ge: x - x - x - x - x -</div>
            </div>
          </div>
        `;
        break;
    }
    
    rhythmExercise.innerHTML += html;
  }

  // ---------- Kompositions-Funktionen ----------
  const MELODY_PATTERNS = {
    classical: [
      [0, 2, 4, 5, 7, 5, 4, 2], // Aufw√§rts, dann abw√§rts
      [0, 4, 7, 4, 0], // Dreiklang
      [0, 2, 4, 7, 4, 2, 0], // Bogen
      [0, 5, 7, 9, 7, 5, 0] // Quarte-Sprung
    ],
    jazz: [
      [0, 4, 7, 11, 7, 4, 0], // Maj7 Arpeggio
      [0, 3, 7, 10, 7, 3, 0], // m7 Arpeggio
      [0, 2, 5, 7, 5, 2, 0], // Pentatonisch
      [0, 1, 4, 7, 4, 1, 0] // Chromatisch
    ],
    pop: [
      [0, 4, 7, 4, 0], // Einfacher Dreiklang
      [0, 2, 4, 2, 0], // Sekund-Bewegung
      [0, 5, 7, 5, 0], // Quarte-Sprung
      [0, 7, 4, 7, 0] // Oktave-Sprung
    ],
    folk: [
      [0, 2, 4, 5, 4, 2, 0], // Pentatonisch
      [0, 4, 7, 4, 0], // Dreiklang
      [0, 2, 4, 2, 0], // Sekund
      [0, 5, 7, 5, 0] // Quarte
    ],
    blues: [
      [0, 3, 5, 6, 7, 6, 5, 3, 0], // Blues-Skala
      [0, 4, 7, 4, 0], // Dur-Dreiklang
      [0, 3, 7, 3, 0], // Moll-Dreiklang
      [0, 5, 7, 5, 0] // Quarte
    ]
  };
  
  const BASS_PATTERNS = {
    'Walking Bass': [0, 5, 7, 5, 0, 5, 7, 5],
    'Root-5': [0, 5, 0, 5, 0, 5, 0, 5],
    'Arpeggio': [0, 4, 7, 4, 0, 4, 7, 4],
    'Scalar': [0, 2, 4, 5, 7, 5, 4, 2],
    'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7]
  };
  
  function generateMelody() {
    const key = document.getElementById('melodyKey').value;
    const style = document.getElementById('melodyStyle').value;
    const melodyGenerator = document.getElementById('melodyGenerator');
    
    // Zuf√§lliges Pattern ausw√§hlen
    const patterns = MELODY_PATTERNS[style];
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
    
    // Melodie in der gew√§hlten Tonart generieren
    const rootIndex = noteIndex(key);
    const melody = pattern.map(interval => {
      const noteIndex = (rootIndex + interval) % 12;
      return idxToNote(noteIndex, false);
    });
    
    let html = `<h4>üéº Generierte Melodie in ${key} ${style}</h4>`;
    
    // Noten mit Linien zwischen den Noten anzeigen
    html += `<div style="font-family:monospace; font-size:18px; line-height:1.8; margin:15px 0; text-align:center;">`;
    for (let i = 0; i < melody.length; i++) {
      html += `<span style="display:inline-block; margin:0 8px; padding:8px 12px; background:#1db954; color:white; border-radius:8px; font-weight:bold;">${melody[i]}</span>`;
      if (i < melody.length - 1) {
        html += `<span style="display:inline-block; margin:0 4px; color:#666; font-size:24px;">‚îÅ‚îÅ‚îÅ</span>`;
      }
    }
    html += `</div>`;
    
    // Akkord-Analyse mit Linien
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>üéº Akkord-Analyse:</strong><br>`;
    for (let i = 0; i < melody.length; i++) {
      const note = melody[i];
      const chord = getChordForNote(note, key);
      html += `<div style="margin:8px 0; padding:8px; background:white; border-radius:6px; border-left:4px solid #1db954;">`;
      html += `<strong>${note}</strong> ‚Üí <span style="color:#1db954; font-weight:bold;">${chord}</span>`;
      html += `</div>`;
    }
    html += `</div>`;
    
    // Intervall-Analyse
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Intervall-Analyse:</strong><br>`;
    for (let i = 1; i < pattern.length; i++) {
      const interval = pattern[i] - pattern[i-1];
      const intervalName = getIntervalName(interval);
      html += `${melody[i-1]} ‚Üí ${melody[i]}: ${intervalName}<br>`;
    }
    html += `</div>`;
    
    // Abspielen-Button
    html += `<div class="controls">`;
    html += `<button onclick="playGeneratedMelody('${melody.join(',')}')" class="btn">üéµ Abspielen</button>`;
    html += `<button onclick="showMelodyNotation('${melody.join(',')}')" class="btn">üéº Notation anzeigen</button>`;
    html += `</div>`;
    
    melodyGenerator.innerHTML = html;
  }
  
  function getIntervalName(semitones) {
    const intervalNames = {
      0: 'Unisono',
      1: 'Kleine Sekunde',
      2: 'Gro√üe Sekunde',
      3: 'Kleine Terz',
      4: 'Gro√üe Terz',
      5: 'Reine Quarte',
      6: 'Tritonus',
      7: 'Reine Quinte',
      8: 'Kleine Sexte',
      9: 'Gro√üe Sexte',
      10: 'Kleine Septime',
      11: 'Gro√üe Septime',
      12: 'Oktave'
    };
    
    return intervalNames[semitones] || `${semitones} Halbt√∂ne`;
  }
  
  // Akkord f√ºr eine Note in einer bestimmten Tonart finden
  function getChordForNote(note, key) {
    const noteIdx = noteIndex(note);
    const keyIdx = noteIndex(key);
    
    // Akkord-Typen f√ºr Dur-Tonarten
    const chordTypes = ['maj', 'm', 'm', 'maj', 'maj', 'm', 'dim'];
    
    // Position der Note in der Tonleiter finden
    let scalePosition = 0;
    for (let i = 0; i < 12; i++) {
      if ((keyIdx + i) % 12 === noteIdx) {
        scalePosition = i;
        break;
      }
    }
    
    // Akkord-Typ basierend auf der Position
    const chordType = chordTypes[scalePosition % 7];
    
    return `${note}${chordType}`;
  }
  
  function playGeneratedMelody(melodyString) {
    if (!window.Tone) return;
    
    const melody = melodyString.split(',');
    const synth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.4 }
    }).toDestination();
    
    melody.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note + '4', '4n');
      }, index * 400);
    });
  }
  
  function showMelodyNotation(melodyString) {
    const melodyGenerator = document.getElementById('melodyGenerator');
    const melody = melodyString.split(',');
    
    let html = `<div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<h5>üéº Melodie-Notation:</h5>`;
    html += `<div style="font-family:monospace; font-size:16px; line-height:1.6;">`;
    
    // Einfache Notation
    melody.forEach((note, index) => {
      html += `${note}${index < melody.length - 1 ? ' ‚Üí ' : ''}`;
    });
    
    html += `</div>`;
    html += `<div style="margin-top:10px; font-size:14px; color:#666;">`;
    html += `<strong>Rhythmus:</strong> Viertelnoten (‚ô©)<br>`;
    html += `<strong>Taktart:</strong> 4/4<br>`;
    html += `<strong>Tempo:</strong> 120 BPM`;
    html += `</div>`;
    html += `</div>`;
    
    melodyGenerator.innerHTML += html;
  }
  
  function generateBassLine() {
    const bassLineGenerator = document.getElementById('bassLineGenerator');
    
    // Zuf√§lliges Bass-Pattern ausw√§hlen
    const patternNames = Object.keys(BASS_PATTERNS);
    const patternName = patternNames[Math.floor(Math.random() * patternNames.length)];
    const pattern = BASS_PATTERNS[patternName];
    
    // Bass-Linie in C generieren
    const bassLine = pattern.map(interval => {
      const noteIndex = (0 + interval) % 12;
      return idxToNote(noteIndex, false);
    });
    
    let html = `<h4>üéº Generierte Bass-Linie: ${patternName}</h4>`;
    html += `<div style="font-family:monospace; font-size:18px; line-height:1.8; margin:15px 0;">`;
    html += bassLine.join(' ‚Üí ');
    html += `</div>`;
    
    // Pattern-Erkl√§rung
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Pattern-Charakteristik:</strong><br>`;
    switch(patternName) {
      case 'Walking Bass':
        html += `Jazz-Stil mit chromatischen Verbindungsnoten zwischen Akkordt√∂nen`;
        break;
      case 'Root-5':
        html += `Einfacher Rock/Pop-Stil mit Grundton und Quinte`;
        break;
      case 'Arpeggio':
        html += `Akkord-basierte Linie mit aufsteigenden und absteigenden Bewegungen`;
        break;
      case 'Scalar':
        html += `Tonleiter-basierte Linie mit melodischen Bewegungen`;
        break;
      case 'Chromatic':
        html += `Chromatische Linie mit Halbtonschritten`;
        break;
    }
    html += `</div>`;
    
    // Abspielen-Button
    html += `<div class="controls">`;
    html += `<button onclick="playBassLine('${bassLine.join(',')}')" class="btn">üéµ Abspielen</button>`;
    html += `<button onclick="showBassNotation('${bassLine.join(',')}')" class="btn">üéº Notation anzeigen</button>`;
    html += `</div>`;
    
    bassLineGenerator.innerHTML = html;
  }
  
  function playBassLine(bassLineString) {
    if (!window.Tone) return;
    
    const bassLine = bassLineString.split(',');
    const synth = new Tone.MonoSynth({
      oscillator: { type: 'sawtooth' },
      envelope: { attack: 0.1, decay: 0.3, sustain: 0.2, release: 0.4 }
    }).toDestination();
    
    bassLine.forEach((note, index) => {
      setTimeout(() => {
        synth.triggerAttackRelease(note + '2', '8n');
      }, index * 200);
    });
  }
  
  function showBassPatterns() {
    const bassLineGenerator = document.getElementById('bassLineGenerator');
    
    let html = `<h4>üéº Bass-Patterns</h4>`;
    
    Object.entries(BASS_PATTERNS).forEach(([name, pattern]) => {
      const bassLine = pattern.map(interval => {
        const noteIndex = (0 + interval) % 12;
        return idxToNote(noteIndex, false);
      });
      
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${name}:</strong><br>`;
      html += `<span style="font-family:monospace; font-size:16px;">${bassLine.join(' ‚Üí ')}</span>`;
      html += `</div>`;
    });
    
    bassLineGenerator.innerHTML = html;
  }
  
  function showBassNotation(bassLineString) {
    const bassLineGenerator = document.getElementById('bassLineGenerator');
    const bassLine = bassLineString.split(',');
    
    let html = `<div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<h5>üéº Bass-Notation:</h5>`;
    html += `<div style="font-family:monospace; font-size:16px; line-height:1.6;">`;
    
    // Einfache Notation
    bassLine.forEach((note, index) => {
      html += `${note}${index < bassLine.length - 1 ? ' ‚Üí ' : ''}`;
    });
    
    html += `</div>`;
    html += `<div style="margin-top:10px; font-size:14px; color:#666;">`;
    html += `<strong>Rhythmus:</strong> Achtelnoten (‚ô™)<br>`;
    html += `<strong>Taktart:</strong> 4/4<br>`;
    html += `<strong>Oktave:</strong> Bass (C2-E3)`;
    html += `</div>`;
    html += `</div>`;
    
    bassLineGenerator.innerHTML += html;
  }
  
  function generateHarmonicProgression() {
    const harmonicProgression = document.getElementById('harmonicProgression');
    
    const progressions = {
      'Pop I-V-vi-IV': ['C', 'G', 'Am', 'F'],
      'Jazz ii-V-I': ['Dm', 'G', 'C'],
      'Blues I-IV-V': ['C', 'F', 'G'],
      'Classical I-vi-IV-V': ['C', 'Am', 'F', 'G'],
      'Rock I-IV-V': ['E', 'A', 'B'],
      'Folk I-V': ['G', 'D'],
      'Jazz I-vi-ii-V': ['C', 'Am', 'Dm', 'G'],
      'Modal I-bVII-IV': ['C', 'Bb', 'F']
    };
    
    // Zuf√§llige Progression ausw√§hlen
    const progressionNames = Object.keys(progressions);
    const progressionName = progressionNames[Math.floor(Math.random() * progressionNames.length)];
    const progression = progressions[progressionName];
    
    let html = `<h4>üéº Generierte harmonische Progression: ${progressionName}</h4>`;
    html += `<div style="font-family:monospace; font-size:18px; line-height:1.8; margin:15px 0;">`;
    html += progression.join(' ‚Üí ');
    html += `</div>`;
    
    // Funktionsanalyse
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Funktionsanalyse:</strong><br>`;
    const functions = getProgressionFunctions(progression);
    functions.forEach((func, index) => {
      html += `${progression[index]}: ${func}<br>`;
    });
    html += `</div>`;
    
    // Abspielen-Button
    html += `<div class="controls">`;
    html += `<button onclick="playHarmonicProgression('${progression.join(',')}')" class="btn">üéµ Abspielen</button>`;
    html += `<button onclick="analyzeProgression()" class="btn">üîç Analysieren</button>`;
    html += `</div>`;
    
    harmonicProgression.innerHTML = html;
  }
  
  function getProgressionFunctions(chords) {
    const functions = [];
    const key = 'C'; // Vereinfacht f√ºr C-Dur
    
    chords.forEach(chord => {
      if (chord === 'C') functions.push('I (Tonika)');
      else if (chord === 'Dm') functions.push('ii (Supertonika)');
      else if (chord === 'E') functions.push('III (Mediante)');
      else if (chord === 'F') functions.push('IV (Subdominante)');
      else if (chord === 'G') functions.push('V (Dominante)');
      else if (chord === 'Am') functions.push('vi (Submediante)');
      else if (chord === 'B') functions.push('vii¬∞ (Leitton)');
      else if (chord === 'Bb') functions.push('bVII (Moll-Subdominante)');
      else functions.push('? (Unbekannt)');
    });
    
    return functions;
  }
  
  function playHarmonicProgression(progressionString) {
    if (!window.Tone) return;
    
    const progression = progressionString.split(',');
    const synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 0.6 }
    }).toDestination();
    
    progression.forEach((chord, index) => {
      setTimeout(() => {
        const chordNotes = getChordNotes(chord);
        synth.triggerAttackRelease(chordNotes, '2n');
      }, index * 1000);
    });
  }
  
  function getChordNotes(chord) {
    const chordMap = {
      'C': ['C4', 'E4', 'G4'],
      'Dm': ['D4', 'F4', 'A4'],
      'E': ['E4', 'G#4', 'B4'],
      'F': ['F4', 'A4', 'C5'],
      'G': ['G4', 'B4', 'D5'],
      'Am': ['A4', 'C5', 'E5'],
      'B': ['B4', 'D#5', 'F#5'],
      'Bb': ['Bb3', 'D4', 'F4']
    };
    
    return chordMap[chord] || ['C4', 'E4', 'G4'];
  }
  
  function createSongStructure() {
    const songStructure = document.getElementById('songStructure');
    
    const structures = {
      'Pop': 'Intro ‚Üí Verse ‚Üí Chorus ‚Üí Verse ‚Üí Chorus ‚Üí Bridge ‚Üí Chorus ‚Üí Outro',
      'Rock': 'Intro ‚Üí Verse ‚Üí Chorus ‚Üí Verse ‚Üí Chorus ‚Üí Solo ‚Üí Chorus ‚Üí Outro',
      'Jazz': 'Head ‚Üí Solo 1 ‚Üí Solo 2 ‚Üí Solo 3 ‚Üí Head',
      'Classical': 'Exposition ‚Üí Development ‚Üí Recapitulation',
      'Blues': 'Intro ‚Üí Verse 1 ‚Üí Verse 2 ‚Üí Verse 3 ‚Üí Solo ‚Üí Verse 4 ‚Üí Outro',
      'Folk': 'Verse 1 ‚Üí Verse 2 ‚Üí Verse 3 ‚Üí Verse 4',
      'Electronic': 'Intro ‚Üí Build ‚Üí Drop ‚Üí Breakdown ‚Üí Build ‚Üí Drop ‚Üí Outro'
    };
    
    let html = `<h4>üéµ Song-Strukturen</h4>`;
    
    Object.entries(structures).forEach(([genre, structure]) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
      html += `<strong>${genre}:</strong><br>`;
      html += `<span>${structure}</span>`;
      html += `</div>`;
    });
    
    html += `<div style="margin-top:15px;">`;
    html += `<button onclick="editSongStructure()" class="btn">‚úèÔ∏è Eigene Struktur erstellen</button>`;
    html += `</div>`;
    
    songStructure.innerHTML = html;
  }
  
  function editSongStructure() {
    const songStructure = document.getElementById('songStructure');
    
    let html = `<h4>‚úèÔ∏è Eigene Song-Struktur erstellen</h4>`;
    html += `<div style="margin:15px 0;">`;
    html += `<label><strong>Song-Titel:</strong></label><br>`;
    html += `<input type="text" id="songTitle" placeholder="Mein Song" style="width:100%; margin:5px 0;"><br>`;
    html += `<label><strong>Genre:</strong></label><br>`;
    html += `<select id="songGenre" style="width:100%; margin:5px 0;">`;
    html += `<option value="pop">Pop</option>`;
    html += `<option value="rock">Rock</option>`;
    html += `<option value="jazz">Jazz</option>`;
    html += `<option value="classical">Klassisch</option>`;
    html += `<option value="blues">Blues</option>`;
    html += `<option value="folk">Folk</option>`;
    html += `<option value="electronic">Electronic</option>`;
    html += `</select><br>`;
    html += `<label><strong>Struktur (durch ‚Üí getrennt):</strong></label><br>`;
    html += `<input type="text" id="songStructureInput" placeholder="Intro ‚Üí Verse ‚Üí Chorus ‚Üí Verse ‚Üí Chorus ‚Üí Outro" style="width:100%; margin:5px 0;"><br>`;
    html += `<label><strong>Notizen:</strong></label><br>`;
    html += `<textarea id="songNotes" placeholder="Ideen, Akkorde, Melodien..." style="width:100%; height:80px; margin:5px 0;"></textarea>`;
    html += `</div>`;
    html += `<div class="controls">`;
    html += `<button onclick="saveSongStructure()" class="btn">üíæ Speichern</button>`;
    html += `<button onclick="createSongStructure()" class="btn">üîÑ Zur√ºck</button>`;
    html += `</div>`;
    
    songStructure.innerHTML = html;
  }
  
  function saveSongStructure() {
    const title = document.getElementById('songTitle').value.trim();
    const genre = document.getElementById('songGenre').value;
    const structure = document.getElementById('songStructureInput').value.trim();
    const notes = document.getElementById('songNotes').value.trim();
    
    if (!title || !structure) {
      alert('Bitte f√ºllen Sie mindestens Titel und Struktur aus');
      return;
    }
    
    try {
      const song = {
        id: Date.now(),
        title: title,
        genre: genre,
        structure: structure,
        notes: notes,
        timestamp: new Date().toISOString()
      };
      
      const songs = JSON.parse(localStorage.getItem('songStructures') || '[]');
      songs.push(song);
      localStorage.setItem('songStructures', JSON.stringify(songs));
      
      alert(`Song "${title}" erfolgreich gespeichert!`);
      createSongStructure();
    } catch (e) {
      console.error('Fehler beim Speichern:', e);
      alert('Fehler beim Speichern der Song-Struktur');
    }
  }

  // ---------- Produktions-Funktionen ----------
  let virtualMixer = null;
  let mixerChannels = [];
  let currentEffects = [];
  
  function initVirtualMixer() {
    if (!window.Tone) {
      alert('Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button');
      return;
    }
    
    try {
      // Mixer-Kan√§le erstellen
      mixerChannels = [
        { name: 'Kick', gain: 0, pan: 0, mute: false, solo: false },
        { name: 'Snare', gain: 0, pan: 0, mute: false, solo: false },
        { name: 'Hihat', gain: 0, pan: 0, mute: false, solo: false },
        { name: 'Bass', gain: 0, pan: 0, mute: false, solo: false },
        { name: 'Lead', gain: 0, pan: 0, mute: false, solo: false },
        { name: 'Pad', gain: 0, pan: 0, mute: false, solo: false }
      ];
      
      // Effekte initialisieren
      currentEffects = [];
      
      const virtualMixerDiv = document.getElementById('virtualMixer');
      virtualMixerDiv.innerHTML = createMixerUI();
      
      console.log('Virtueller Mixer erfolgreich initialisiert');
    } catch (e) {
      console.error('Fehler beim Initialisieren des Mixers:', e);
    }
  }
  
  function createMixerUI() {
    let html = `<h4>üéõÔ∏è Virtueller Mixer</h4>`;
    html += `<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin:15px 0;">`;
    
    mixerChannels.forEach((channel, index) => {
      html += `
        <div style="padding:15px; background:#f8f9fa; border-radius:8px; border:1px solid #dee2e6;">
          <h5 style="margin:0 0 10px 0;">${channel.name}</h5>
          
          <div style="margin:10px 0;">
            <label><strong>Gain:</strong> ${channel.gain}dB</label><br>
            <input type="range" min="-60" max="12" value="${channel.gain}" 
                   onchange="updateChannelGain(${index}, this.value)" style="width:100%;">
          </div>
          
          <div style="margin:10px 0;">
            <label><strong>Pan:</strong> ${channel.pan}</label><br>
            <input type="range" min="-100" max="100" value="${channel.pan}" 
                   onchange="updateChannelPan(${index}, this.value)" style="width:100%;">
          </div>
          
          <div style="margin:10px 0;">
            <label><input type="checkbox" ${channel.mute ? 'checked' : ''} 
                   onchange="toggleChannelMute(${index}, this.checked)"> Mute</label>
            <label style="margin-left:15px;"><input type="checkbox" ${channel.solo ? 'checked' : ''} 
                   onchange="toggleChannelSolo(${index}, this.checked)"> Solo</label>
          </div>
        </div>
      `;
    });
    
    html += `</div>`;
    
    // Master-Sektion
    html += `<div style="margin-top:20px; padding:15px; background:#e8f5e8; border-radius:8px;">`;
    html += `<h5 style="margin:0 0 10px 0;">üéöÔ∏è Master</h5>`;
    html += `<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:15px;">`;
    html += `<div><label><strong>Master Gain:</strong></label><br><input type="range" min="-60" max="12" value="0" style="width:100%;"></div>`;
    html += `<div><label><strong>Master Pan:</strong></label><br><input type="range" min="-100" max="100" value="0" style="width:100%;"></div>`;
    html += `<div><label><strong>BPM:</strong></label><br><input type="range" min="60" max="200" value="120" style="width:100%;"></div>`;
    html += `</div>`;
    html += `</div>`;
    
    return html;
  }
  
  function updateChannelGain(channelIndex, value) {
    if (mixerChannels[channelIndex]) {
      mixerChannels[channelIndex].gain = parseInt(value);
      updateMixerUI();
    }
  }
  
  function updateChannelPan(channelIndex, value) {
    if (mixerChannels[channelIndex]) {
      mixerChannels[channelIndex].pan = parseInt(value);
      updateMixerUI();
    }
  }
  
  function toggleChannelMute(channelIndex, muted) {
    if (mixerChannels[channelIndex]) {
      mixerChannels[channelIndex].mute = muted;
      updateMixerUI();
    }
  }
  
  function toggleChannelSolo(channelIndex, soloed) {
    if (mixerChannels[channelIndex]) {
      // Alle anderen Kan√§le unsolo
      mixerChannels.forEach((channel, index) => {
        if (index !== channelIndex) {
          channel.solo = false;
        }
      });
      mixerChannels[channelIndex].solo = soloed;
      updateMixerUI();
    }
  }
  
  function updateMixerUI() {
    const virtualMixerDiv = document.getElementById('virtualMixer');
    virtualMixerDiv.innerHTML = createMixerUI();
  }
  
  function resetMixer() {
    mixerChannels.forEach(channel => {
      channel.gain = 0;
      channel.pan = 0;
      channel.mute = false;
      channel.solo = false;
    });
    currentEffects = [];
    updateMixerUI();
  }
  
  function saveMixerPreset() {
    const presetName = prompt('Name f√ºr den Mixer-Preset:');
    if (!presetName) return;
    
    try {
      const preset = {
        name: presetName,
        channels: [...mixerChannels],
        effects: [...currentEffects],
        timestamp: new Date().toISOString()
      };
      
      const presets = JSON.parse(localStorage.getItem('mixerPresets') || '[]');
      presets.push(preset);
      localStorage.setItem('mixerPresets', JSON.stringify(presets));
      
      alert(`Preset "${presetName}" erfolgreich gespeichert!`);
    } catch (e) {
      console.error('Fehler beim Speichern des Presets:', e);
      alert('Fehler beim Speichern des Presets');
    }
  }
  
  function addReverb() {
    const effectProcessor = document.getElementById('effectProcessor');
    
    const reverb = {
      id: Date.now(),
      type: 'Reverb',
      parameters: {
        roomSize: 0.5,
        dampening: 0.5,
        wet: 0.3
      }
    };
    
    currentEffects.push(reverb);
    
    let html = `<h4>üåä Reverb hinzugef√ºgt</h4>`;
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Parameter:</strong><br>`;
    html += `<label>Room Size: <input type="range" min="0" max="1" step="0.1" value="0.5" 
                   onchange="updateEffectParameter(${reverb.id}, 'roomSize', this.value)"></label><br>`;
    html += `<label>Dampening: <input type="range" min="0" max="1" step="0.1" value="0.5" 
                   onchange="updateEffectParameter(${reverb.id}, 'dampening', this.value)"></label><br>`;
    html += `<label>Wet: <input type="range" min="0" max="1" step="0.1" value="0.3" 
                   onchange="updateEffectParameter(${reverb.id}, 'wet', this.value)"></label><br>`;
    html += `</div>`;
    
    effectProcessor.innerHTML = html;
  }
  
  function addDelay() {
    const effectProcessor = document.getElementById('effectProcessor');
    
    const delay = {
      id: Date.now(),
      type: 'Delay',
      parameters: {
        time: 0.5,
        feedback: 0.3,
        wet: 0.4
      }
    };
    
    currentEffects.push(delay);
    
    let html = `<h4>‚è∞ Delay hinzugef√ºgt</h4>`;
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Parameter:</strong><br>`;
    html += `<label>Time: <input type="range" min="0" max="2" step="0.1" value="0.5" 
                   onchange="updateEffectParameter(${delay.id}, 'time', this.value)"></label><br>`;
    html += `<label>Feedback: <input type="range" min="0" max="0.9" step="0.1" value="0.3" 
                   onchange="updateEffectParameter(${delay.id}, 'feedback', this.value)"></label><br>`;
    html += `<label>Wet: <input type="range" min="0" max="1" step="0.1" value="0.4" 
                   onchange="updateEffectParameter(${delay.id}, 'wet', this.value)"></label><br>`;
    html += `</div>`;
    
    effectProcessor.innerHTML = html;
  }
  
  function addCompression() {
    const effectProcessor = document.getElementById('effectProcessor');
    
    const compression = {
      id: Date.now(),
      type: 'Compression',
      parameters: {
        threshold: -20,
        ratio: 4,
        attack: 0.1,
        release: 0.1
      }
    };
    
    currentEffects.push(compression);
    
    let html = `<h4>üìä Kompression hinzugef√ºgt</h4>`;
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Parameter:</strong><br>`;
    html += `<label>Threshold: <input type="range" min="-60" max="0" step="1" value="-20" 
                   onchange="updateEffectParameter(${compression.id}, 'threshold', this.value)"></label><br>`;
    html += `<label>Ratio: <input type="range" min="1" max="20" step="1" value="4" 
                   onchange="updateEffectParameter(${compression.id}, 'ratio', this.value)"></label><br>`;
    html += `<label>Attack: <input type="range" min="0" max="1" step="0.01" value="0.1" 
                   onchange="updateEffectParameter(${compression.id}, 'attack', this.value)"></label><br>`;
    html += `<label>Release: <input type="range" min="0" max="1" step="0.01" value="0.1" 
                   onchange="updateEffectParameter(${compression.id}, 'release', this.value)"></label><br>`;
    html += `</div>`;
    
    effectProcessor.innerHTML = html;
  }
  
  function addEQ() {
    const effectProcessor = document.getElementById('effectProcessor');
    
    const eq = {
      id: Date.now(),
      type: 'EQ',
      parameters: {
        low: 0,
        mid: 0,
        high: 0
      }
    };
    
    currentEffects.push(eq);
    
    let html = `<h4>üéöÔ∏è EQ hinzugef√ºgt</h4>`;
    html += `<div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">`;
    html += `<strong>Parameter:</strong><br>`;
    html += `<label>Low (60Hz): <input type="range" min="-12" max="12" step="1" value="0" 
                   onchange="updateEffectParameter(${eq.id}, 'low', this.value)"></label><br>`;
    html += `<label>Mid (1kHz): <input type="range" min="-12" max="12" step="1" value="0" 
                   onchange="updateEffectParameter(${eq.id}, 'mid', this.value)"></label><br>`;
    html += `<label>High (10kHz): <input type="range" min="-12" max="12" step="1" value="0" 
                   onchange="updateEffectParameter(${eq.id}, 'high', this.value)"></label><br>`;
    html += `</div>`;
    
    effectProcessor.innerHTML = html;
  }
  
  function updateEffectParameter(effectId, parameter, value) {
    const effect = currentEffects.find(e => e.id === effectId);
    if (effect) {
      effect.parameters[parameter] = parseFloat(value);
    }
  }
  
  function showLoudnessMeter() {
    const masteringTools = document.getElementById('masteringTools');
    
    let html = `<h4>üìä Lautst√§rke-Meter</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<div style="display:flex; align-items:flex-end; height:200px; gap:5px;">`;
    
    // VU-Meter simulieren
    for (let i = 0; i < 20; i++) {
      const height = Math.random() * 100 + 50;
      const color = height > 80 ? '#dc3545' : height > 60 ? '#ffc107' : '#28a745';
      html += `<div style="width:20px; height:${height}%; background:${color}; border-radius:2px;"></div>`;
    }
    
    html += `</div>`;
    html += `<div style="margin-top:10px; text-align:center;">`;
    html += `<strong>RMS:</strong> -18.5 dBFS | <strong>Peak:</strong> -3.2 dBFS | <strong>LUFS:</strong> -14.8 dB`;
    html += `</div>`;
    html += `</div>`;
    
    masteringTools.innerHTML = html;
  }
  
  function showSpectrumAnalyzer() {
    const masteringTools = document.getElementById('masteringTools');
    
    let html = `<h4>üìà Spektrum-Analyzer</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<div style="display:flex; align-items:flex-end; height:200px; gap:2px;">`;
    
    // Frequenz-Bereiche simulieren
    const frequencies = ['20Hz', '60Hz', '250Hz', '1kHz', '4kHz', '10kHz', '20kHz'];
    frequencies.forEach(freq => {
      const height = Math.random() * 100 + 30;
      html += `<div style="flex:1; height:${height}%; background:#007acc; border-radius:2px; position:relative;">`;
      html += `<div style="position:absolute; bottom:-25px; left:50%; transform:translateX(-50%); font-size:10px; color:#666;">${freq}</div>`;
      html += `</div>`;
    });
    
    html += `</div>`;
    html += `<div style="margin-top:20px; text-align:center;">`;
    html += `<strong>Dominante Frequenz:</strong> 250Hz | <strong>Spektrum-Balance:</strong> Ausgewogen`;
    html += `</div>`;
    html += `</div>`;
    
    masteringTools.innerHTML = html;
  }
  
  function showStereoImager() {
    const masteringTools = document.getElementById('masteringTools');
    
    let html = `<h4>üéß Stereo-Imager</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<div style="display:flex; gap:20px;">`;
    
    // Linker Kanal
    html += `<div style="flex:1; text-align:center;">`;
    html += `<h5>Links</h5>`;
    html += `<div style="width:100px; height:100px; background:#007acc; border-radius:50%; margin:0 auto; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">`;
    html += `L`;
    html += `</div>`;
    html += `<div style="margin-top:10px;">`;
    html += `<strong>Level:</strong> -6.2 dB<br>`;
    html += `<strong>Phase:</strong> 0¬∞`;
    html += `</div>`;
    html += `</div>`;
    
    // Rechter Kanal
    html += `<div style="flex:1; text-align:center;">`;
    html += `<h5>Rechts</h5>`;
    html += `<div style="width:100px; height:100px; background:#28a745; border-radius:50%; margin:0 auto; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">`;
    html += `R`;
    html += `</div>`;
    html += `<div style="margin-top:10px;">`;
    html += `<strong>Level:</strong> -6.8 dB<br>`;
    html += `<strong>Phase:</strong> 0¬∞`;
    html += `</div>`;
    html += `</div>`;
    
    html += `</div>`;
    html += `<div style="margin-top:15px; text-align:center;">`;
    html += `<strong>Stereo-Breite:</strong> 85% | <strong>Korrelation:</strong> 0.92`;
    html += `</div>`;
    html += `</div>`;
    
    masteringTools.innerHTML = html;
  }
  
  function showDynamicRange() {
    const masteringTools = document.getElementById('masteringTools');
    
    let html = `<h4>üìè Dynamik-Bereich</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    html += `<div style="margin:15px 0;">`;
    html += `<strong>Dynamik-Bereich:</strong> 12.3 dB<br>`;
    html += `<strong>Kompressions-Verh√§ltnis:</strong> 2.5:1<br>`;
    html += `<strong>Attack-Zeit:</strong> 15ms<br>`;
    html += `<strong>Release-Zeit:</strong> 150ms`;
    html += `</div>`;
    
    // Dynamik-Visualisierung
    html += `<div style="margin:15px 0; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<div style="display:flex; align-items:center; gap:10px;">`;
    html += `<span style="font-size:12px;">Laut</span>`;
    html += `<div style="flex:1; height:20px; background:linear-gradient(to right, #28a745, #ffc107, #dc3545); border-radius:10px;"></div>`;
    html += `<span style="font-size:12px;">Leise</span>`;
    html += `</div>`;
    html += `<div style="margin-top:5px; text-align:center; font-size:12px; color:#666;">`;
    html += `Dynamik-Bereich: 12.3 dB`;
    html += `</div>`;
    html += `</div>`;
    html += `</div>`;
    
    masteringTools.innerHTML = html;
  }
  
  function exportAudio() {
    alert('üéµ Audio-Export wird implementiert...\n\nFunktionen:\n‚Ä¢ WAV Export (16/24/32 bit)\n‚Ä¢ MP3 Export (128-320 kbps)\n‚Ä¢ AIFF Export\n‚Ä¢ Batch-Export');
  }
  
  function exportMIDI() {
    alert('üéº MIDI-Export wird implementiert...\n\nFunktionen:\n‚Ä¢ Standard MIDI File (.mid)\n‚Ä¢ MIDI 0 und MIDI 1 Format\n‚Ä¢ Multi-Track Export\n‚Ä¢ Tempo- und Timing-Informationen');
  }
  
  function exportProject() {
    alert('üìÅ Projekt-Export wird implementiert...\n\nFunktionen:\n‚Ä¢ ZIP-Archiv mit allen Dateien\n‚Ä¢ Projekt-Einstellungen\n‚Ä¢ Mixer-Presets\n‚Ä¢ Effekt-Konfigurationen\n‚Ä¢ Metadaten');
  }

  // ---------- DAW-Funktionen ----------
  let dawActive = false;
  let audioContext = null;
  let audioBuffer = null;
  let currentAudioBuffer = null;  // Globale Variable f√ºr aktuellen Audio-Buffer
  let audioSource = null;
  let effectsChain = [];
  let mediaRecorder = null;
  let recordedChunks = [];
  let currentProject = null;
  let isRecording = false;
  
  // Vollst√§ndige Audio Engine mit Routing, Transport und MIDI/OSC/HID
  let audioEngine = null;
  let transportSystem = null;
  let audioRouting = null;
  let midiController = null;
  let oscController = null;
  let hidController = null;
  
  // Live-Akkord-Sharing System √ºber Transport
  let liveChordSystem = {
    currentChords: [],
    source: 'guitar', // 'guitar' oder 'transport'
    isActive: false,
    subscribers: new Set(),
    lastUpdate: null,
    guitarChords: [],
    transportChords: [],
    updateInterval: null,
    currentChordIndex: 0 // Aktueller Akkord-Index f√ºr Griffbild-Updates
  };
  


  
  // Audio-Context sicher initialisieren
  function initializeAudioContext() {
    try {
      if (!audioContext || audioContext.state === 'closed') {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log('‚úÖ AudioContext erstellt:', audioContext.state);
        
        // AudioContext aktivieren bei User-Interaktion
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('‚úÖ AudioContext aktiviert');
          });
        }
      }
      return audioContext;
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen des AudioContext:', error);
      return null;
    }
  }
  
  // Audio Engine initialisieren
  function initializeAudioEngine() {
    if (!window.Tone) {
      console.warn('Tone.js nicht verf√ºgbar - Audio Engine kann nicht initialisiert werden');
      return;
    }
    
    try {
      // Audio Engine erstellen
      audioEngine = {
        context: window.Tone.context,
        destination: window.Tone.Destination,
        master: new window.Tone.Channel().toDestination(),
        buses: {},
        effects: {},
        instruments: {},
        samples: {}
      };
      
      // Transport System initialisieren
      transportSystem = {
        transport: window.Tone.Transport,
        tempo: 120,
        timeSignature: [4, 4],
        isPlaying: false,
        position: 0,
        loop: false,
        loopStart: 0,
        loopEnd: 4
      };
      
      // Audio Routing initialisieren
      audioRouting = {
        master: audioEngine.master,
        effects: {},
        sends: {},
        returns: {},
        groups: {}
      };
      
      // MIDI Controller initialisieren
      initializeMIDIController();
      
      // OSC Controller initialisieren
      initializeOSCController();
      
      // HID Controller initialisieren
      initializeHIDController();
      
      // Live-Akkord-Sharing System starten
      startLiveChordSharing();
      
      console.log('‚úÖ Vollst√§ndige Audio Engine initialisiert');
      console.log('üéõÔ∏è Audio Engine:', audioEngine);
      console.log('‚èØÔ∏è Transport System:', transportSystem);
      console.log('üîÄ Audio Routing:', audioRouting);
      console.log('üé∏ Live-Akkord-Sharing aktiviert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Initialisieren der Audio Engine:', error);
    }
  }
  
  // Live-Akkord-Sharing System - Automatisch in Echtzeit
  function startLiveChordSharing() {
    console.log('üé∏ Starte Live-Akkord-Sharing System...');
    
    // Alle 100ms die Akkorde aus dem Gitarren-Teil abrufen
    liveChordSystem.updateInterval = setInterval(() => {
      updateLiveChords();
    }, 100);
    
    liveChordSystem.isActive = true;
    console.log('‚úÖ Live-Akkord-Sharing l√§uft in Echtzeit');
  }
  
  function updateLiveChords() {
    try {
      // Akkorde aus dem Gitarren-Teil abrufen
      const guitarChords = getGuitarChords();
      
      if (guitarChords && guitarChords.length > 0) {
        // Gitarren-Teil hat Akkorde - diese verwenden
        liveChordSystem.source = 'guitar';
        liveChordSystem.guitarChords = guitarChords;
        liveChordSystem.currentChords = guitarChords;
        
        // Alle Tools √ºber neue Akkorde informieren
        notifyChordSubscribers(guitarChords, 'guitar');
        
      } else {
        // Gitarren-Teil ist leer - Transport-System verwenden
        liveChordSystem.source = 'transport';
        const transportChords = getTransportChords();
        
        if (transportChords && transportChords.length > 0) {
          liveChordSystem.transportChords = transportChords;
          liveChordSystem.currentChords = transportChords;
          
          // Alle Tools √ºber Transport-Akkorde informieren
          notifyChordSubscribers(transportChords, 'transport');
          
          // Akkorde zur√ºck an Gitarren-Teil senden
          updateGuitarWithTransportChords(transportChords);
        }
      }
      
      liveChordSystem.lastUpdate = Date.now();
      
    } catch (error) {
      console.error('‚ùå Fehler beim Live-Akkord-Update:', error);
    }
  }
  
  function getGuitarChords() {
    try {
      // Akkorde aus dem Gitarren-Eingabefeld abrufen (ID: 'inp')
      const guitarInput = document.getElementById('inp');
      if (!guitarInput) return [];
      
      const chordText = guitarInput.value.trim();
      if (!chordText) return [];
      
      // Akkorde parsen (z.B. "C Am F G" -> ["C", "Am", "F", "G"])
      const chords = chordText.split(/\s+/).filter(chord => chord.trim());
      
      // Nur g√ºltige Akkorde zur√ºckgeben
      return chords.filter(chord => isValidChord(chord));
      
    } catch (error) {
      console.error('‚ùå Fehler beim Abrufen der Gitarren-Akkorde:', error);
      return [];
    }
  }
  
  function getTransportChords() {
    try {
      // Akkorde aus dem Transport-System abrufen
      if (!transportSystem || !transportSystem.transport) return [];
      
      // Aktuelle Position im Transport
      const position = transportSystem.transport.position;
      const tempo = transportSystem.tempo;
      
      // Basierend auf Position und Tempo Akkorde generieren
      const timeInSeconds = position / 4; // 4 = Viertelnoten
      const beatNumber = Math.floor(timeInSeconds * (tempo / 60));
      
      // Einfache Akkordfolge basierend auf Beat
      const chordProgression = ['C', 'Am', 'F', 'G'];
      const chordIndex = beatNumber % chordProgression.length;
      
      return [chordProgression[chordIndex]];
      
    } catch (error) {
      console.error('‚ùå Fehler beim Abrufen der Transport-Akkorde:', error);
      return [];
    }
  }
  
  function updateGuitarWithTransportChords(chords) {
    try {
      // Akkorde zur√ºck an Gitarren-Teil senden (ID: 'inp')
      const guitarInput = document.getElementById('inp');
      if (!guitarInput) return;
      
      // Nur aktualisieren wenn Gitarren-Teil leer ist
      if (!guitarInput.value.trim()) {
        guitarInput.value = chords.join(' ');
        
        // Event ausl√∂sen um UI zu aktualisieren
        guitarInput.dispatchEvent(new Event('input'));
        
        console.log('üé∏ Gitarren-Teil mit Transport-Akkorden aktualisiert:', chords);
      }
      
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des Gitarren-Teils:', error);
    }
  }
  
  function notifyChordSubscribers(chords, source) {
    try {
      // Alle Tools √ºber neue Akkorde informieren
      liveChordSystem.subscribers.forEach(subscriber => {
        try {
          if (typeof subscriber.onChordsUpdate === 'function') {
            subscriber.onChordsUpdate(chords, source);
          }
        } catch (error) {
          console.error('‚ùå Fehler beim Benachrichtigen des Subscribers:', error);
        }
      });
      
      // Globale Event ausl√∂sen
      window.dispatchEvent(new CustomEvent('chordsUpdated', {
        detail: { chords, source, timestamp: Date.now() }
      }));
      
    } catch (error) {
      console.error('‚ùå Fehler beim Benachrichtigen der Subscriber:', error);
    }
  }
  
  function subscribeToLiveChords(callback, toolName) {
    try {
      const subscriber = {
        id: Date.now() + Math.random(),
        name: toolName,
        onChordsUpdate: callback
      };
      
      liveChordSystem.subscribers.add(subscriber);
      console.log(`‚úÖ ${toolName} f√ºr Live-Akkorde angemeldet`);
      
      return subscriber.id;
      
    } catch (error) {
      console.error('‚ùå Fehler beim Anmelden f√ºr Live-Akkorde:', error);
      return null;
    }
  }
  
  function unsubscribeFromLiveChords(subscriberId) {
    try {
      for (const subscriber of liveChordSystem.subscribers) {
        if (subscriber.id === subscriberId) {
          liveChordSystem.subscribers.delete(subscriber);
          console.log(`‚úÖ Subscriber ${subscriber.name} abgemeldet`);
          break;
        }
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Abmelden von Live-Akkorden:', error);
    }
  }
  
  function isValidChord(chord) {
    // Einfache Akkord-Validierung
    const validChordPattern = /^[A-G][#b]?(m|maj|min|dim|aug|sus[24]?|add[2-9]|maj[7-9]|min[7-9]|dom[7-9]|m7b5|maj7#5|aug7|dim7)?$/;
    return validChordPattern.test(chord);
  }
  
  function getCurrentLiveChords() {
    return {
      chords: liveChordSystem.currentChords,
      source: liveChordSystem.source,
      isActive: liveChordSystem.isActive,
      lastUpdate: liveChordSystem.lastUpdate
    };
  }
  
  function stopLiveChordSharing() {
    if (liveChordSystem.updateInterval) {
      clearInterval(liveChordSystem.updateInterval);
      liveChordSystem.updateInterval = null;
    }
    
    liveChordSystem.isActive = false;
    console.log('‚èπÔ∏è Live-Akkord-Sharing gestoppt');
  }
  
  // Erweiterte Instrumente mit tonejs-instruments erstellen
  async function createAdvancedInstruments() {
    // Audio-System sicherstellen
    if (window.audioManager) {
      await window.audioManager.ensureAudio();
    }
    
    if (!window.Tone) {
      console.warn('Tone.js nicht verf√ºgbar');
      return;
    }
    
    try {
      // Audio Engine initialisieren falls nicht vorhanden
      if (!audioEngine) {
        audioEngine = {
          context: window.Tone.context,
          destination: window.Tone.Destination,
          master: new window.Tone.Channel().toDestination(),
          buses: {},
          effects: {},
          instruments: {},
          samples: {}
        };
      }
      
      // Instrumente erstellen (mit Fallback)
      audioEngine.instruments = {
        piano: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { decay: 0.1, sustain: 0.3, release: 1 }
        }).toDestination(),
        violin: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'sine' },
          envelope: { attack: 0.1, decay: 0.2, sustain: 0.4, release: 0.8 }
        }).toDestination(),
        cello: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'sine' },
          envelope: { attack: 0.2, decay: 0.3, sustain: 0.5, release: 1 }
        }).toDestination(),
        flute: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'sine' },
          envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.5 }
        }).toDestination(),
        clarinet: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.1, decay: 0.2, sustain: 0.6, release: 0.7 }
        }).toDestination(),
        trumpet: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 }
        }).toDestination(),
        trombone: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.02, decay: 0.2, sustain: 0.6, release: 0.4 }
        }).toDestination(),
        saxophone: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.5 }
        }).toDestination(),
        guitar: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }
        }).toDestination(),
        bass: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.6 }
        }).toDestination(),
        drums: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination(),
        synth: new window.Tone.PolySynth(window.Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.02, decay: 0.2, sustain: 0.3, release: 0.6 }
        }).toDestination()
      };
      
      // MIDI-Channel-Zuordnung
      for (let i = 0; i < 16; i++) {
        if (audioEngine.instruments[i]) {
          audioEngine.instruments[i].channel = i;
        }
      }
      
      console.log('‚úÖ Erweiterte Instrumente erstellt:', Object.keys(audioEngine.instruments));
      
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen der erweiterten Instrumente:', error);
    }
  }
  
  // MIDI Controller initialisieren
  function initializeMIDIController() {
    try {
      if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(access => {
          midiController = {
            access: access,
            inputs: new Map(),
            outputs: new Map(),
            onMessage: null
          };
          
          // MIDI Inputs registrieren
          access.inputs.forEach(input => {
            midiController.inputs.set(input.id, input);
            input.onmidimessage = handleMIDIMessage;
            console.log('‚úÖ MIDI Input registriert:', input.name || input.id);
          });
          
          // MIDI Outputs registrieren
          access.outputs.forEach(output => {
            midiController.outputs.set(output.id, output);
            console.log('‚úÖ MIDI Output registriert:', output.name || output.id);
          });
          
          console.log('‚úÖ MIDI Controller initialisiert');
        }).catch(error => {
          console.warn('MIDI nicht verf√ºgbar:', error);
        });
      }
    } catch (error) {
      console.warn('MIDI Controller konnte nicht initialisiert werden:', error);
    }
  }
  
  // OSC Controller initialisieren
  function initializeOSCController() {
    try {
      // OSC √ºber WebSocket (f√ºr Netzwerksteuerung)
      oscController = {
        websocket: null,
        isConnected: false,
        onMessage: null,
        send: function(address, ...args) {
          if (this.websocket && this.isConnected) {
            const message = { address, args, timestamp: Date.now() };
            this.websocket.send(JSON.stringify(message));
          }
        }
      };
      
      console.log('‚úÖ OSC Controller initialisiert (WebSocket-basiert)');
    } catch (error) {
      console.warn('OSC Controller konnte nicht initialisiert werden:', error);
    }
  }
  
  // HID Controller initialisieren
  function initializeHIDController() {
    try {
      if (navigator.hid) {
        hidController = {
          devices: new Map(),
          onInput: null,
          requestDevice: async function() {
            try {
              const devices = await navigator.hid.requestDevice({
                filters: [] // Alle HID-Ger√§te
              });
              
              devices.forEach(device => {
                this.devices.set(device.productId, device);
                device.oninputreport = handleHIDInput;
                console.log('‚úÖ HID Device registriert:', device.productName);
              });
            } catch (error) {
              console.warn('HID Device konnte nicht angefordert werden:', error);
            }
          }
        };
        
        console.log('‚úÖ HID Controller initialisiert');
      }
    } catch (error) {
      console.warn('HID Controller konnte nicht initialisiert werden:', error);
    }
  }
  
  // MIDI Message Handler
  function handleMIDIMessage(event) {
    if (!midiController) return;
    
    const [status, note, velocity] = event.data;
    const messageType = status >> 4;
    const channel = status & 0x0F;
    
    switch (messageType) {
      case 0x8: // Note Off
        handleMIDINoteOff(channel, note, velocity);
        break;
      case 0x9: // Note On
        handleMIDINoteOn(channel, note, velocity);
        break;
      case 0xB: // Control Change
        handleMIDIControlChange(channel, note, velocity);
        break;
      case 0xC: // Program Change
        handleMIDIProgramChange(channel, note);
        break;
    }
    
    if (midiController.onMessage) {
      midiController.onMessage({ type: messageType, channel, note, velocity });
    }
  }
  
  // HID Input Handler
  function handleHIDInput(event) {
    if (!hidController) return;
    
    const { reportId, data } = event;
    
    // Gamepad-√§hnliche Steuerung
    if (data.length >= 4) {
      const x = (data[0] - 128) / 128; // -1 bis 1
      const y = (data[1] - 128) / 128; // -1 bis 1
      const button1 = data[2] > 0;
      const button2 = data[3] > 0;
      
      handleHIDControl(x, y, button1, button2);
    }
    
    if (hidController.onInput) {
      hidController.onInput({ reportId, data });
    }
  }
  
  // MIDI Note On Handler
  function handleMIDINoteOn(channel, note, velocity) {
    if (audioEngine && audioEngine.instruments[channel]) {
      const instrument = audioEngine.instruments[channel];
      const noteName = window.Tone.Frequency(note, "midi").toNote();
      instrument.triggerAttack(noteName, undefined, velocity / 127);
    }
  }
  
  // MIDI Note Off Handler
  function handleMIDINoteOff(channel, note, velocity) {
    if (audioEngine && audioEngine.instruments[channel]) {
      const instrument = audioEngine.instruments[channel];
      const noteName = window.Tone.Frequency(note, "midi").toNote();
      instrument.triggerRelease(noteName);
    }
  }
  
  // MIDI Control Change Handler
  function handleMIDIControlChange(channel, controller, value) {
    if (audioEngine && audioEngine.instruments[channel]) {
      const instrument = audioEngine.instruments[channel];
      
      switch (controller) {
        case 1: // Modulation Wheel
          if (instrument.modulationWheel) {
            instrument.modulationWheel.setValueAtTime(value / 127, window.Tone.now());
          }
          break;
        case 7: // Volume
          if (instrument.volume) {
            instrument.volume.setValueAtTime(value / 127, window.Tone.now());
          }
          break;
        case 10: // Pan
          if (instrument.pan) {
            const panValue = (value - 64) / 64; // -1 bis 1
            instrument.pan.setValueAtTime(panValue, window.Tone.now());
          }
          break;
      }
    }
  }
  
  // MIDI Program Change Handler
  function handleMIDIProgramChange(channel, program) {
    if (audioEngine && audioEngine.instruments[channel]) {
      // Instrument wechseln basierend auf Program Number
      console.log(`MIDI Program Change: Channel ${channel} ‚Üí Program ${program}`);
    }
  }
  
  // HID Control Handler
  function handleHIDControl(x, y, button1, button2) {
    // X-Achse: Pan oder Filter
    if (audioEngine && audioEngine.master) {
      audioEngine.master.pan.setValueAtTime(x, window.Tone.now());
    }
    
    // Y-Achse: Volume oder Reverb
    if (audioEngine && audioEngine.master) {
      const volume = Math.max(0, 1 - (y + 1) / 2);
      audioEngine.master.volume.setValueAtTime(volume, window.Tone.now());
    }
    
    // Button 1: Play/Stop
    if (button1 && transportSystem) {
      if (transportSystem.isPlaying) {
        stopTransport();
      } else {
        startTransport();
      }
    }
    
    // Button 2: Record
    if (button2 && transportSystem) {
      toggleRecord();
    }
  }
  
  // Transport-Funktionen
  function startTransport() {
    if (!transportSystem || !window.Tone) return;
    
    try {
      window.Tone.Transport.start();
      transportSystem.isPlaying = true;
      transportSystem.transport.start();
      console.log('‚úÖ Transport gestartet');
      updateTransportStatus('Transport l√§uft');
    } catch (error) {
      console.error('‚ùå Fehler beim Starten des Transport:', error);
    }
  }
  
  function stopTransport() {
    if (!transportSystem || !window.Tone) return;
    
    try {
      window.Tone.Transport.stop();
      transportSystem.isPlaying = false;
      transportSystem.transport.stop();
      console.log('‚úÖ Transport gestoppt');
      updateTransportStatus('Transport gestoppt');
    } catch (error) {
      console.error('‚ùå Fehler beim Stoppen des Transport:', error);
    }
  }
  
  function pauseTransport() {
    if (!transportSystem || !window.Tone) return;
    
    try {
      window.Tone.Transport.pause();
      transportSystem.isPlaying = false;
      console.log('‚úÖ Transport pausiert');
      updateTransportStatus('Transport pausiert');
    } catch (error) {
      console.error('‚ùå Fehler beim Pausieren des Transport:', error);
    }
  }
  
  function setTransportTempo(bpm) {
    if (!transportSystem || !window.Tone) return;
    
    try {
      transportSystem.tempo = bpm;
      window.Tone.Transport.bpm.value = bpm;
      console.log('‚úÖ Tempo auf', bpm, 'BPM gesetzt');
      updateTransportStatus(`Tempo: ${bpm} BPM`);
    } catch (error) {
      console.error('‚ùå Fehler beim Setzen des Tempos:', error);
    }
  }
  
  function setTransportTimeSignature(numerator, denominator) {
    if (!transportSystem || !window.Tone) return;
    
    try {
      transportSystem.timeSignature = [numerator, denominator];
      console.log('‚úÖ Taktart auf', numerator + '/' + denominator, 'gesetzt');
      updateTransportStatus(`Taktart: ${numerator}/${denominator}`);
    } catch (error) {
      console.error('‚ùå Fehler beim Setzen der Taktart:', error);
    }
  }
  
  function setTransportLoop(start, end) {
    if (!transportSystem || !window.Tone) return;
    
    try {
      transportSystem.loop = true;
      transportSystem.loopStart = start;
      transportSystem.loopEnd = end;
      
      // Loop in Tone.js setzen
      if (window.Tone.Transport.loop) {
        window.Tone.Transport.loop = true;
        window.Tone.Transport.loopStart = start;
        window.Tone.Transport.loopEnd = end;
      }
      
      console.log('‚úÖ Loop gesetzt:', start, 'bis', end);
      updateTransportStatus(`Loop: ${start}s - ${end}s`);
    } catch (error) {
      console.error('‚ùå Fehler beim Setzen des Loops:', error);
    }
  }
  
  function toggleRecord() {
    if (!transportSystem) return;
    
    try {
      if (transportSystem.isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Umschalten des Record-Modus:', error);
    }
  }
  
  function startRecording() {
    if (!transportSystem) return;
    
    try {
      transportSystem.isRecording = true;
      console.log('‚úÖ Aufnahme gestartet');
      updateTransportStatus('Aufnahme l√§uft');
      
      // Hier k√∂nnte die eigentliche Aufnahme-Logik implementiert werden
    } catch (error) {
      console.error('‚ùå Fehler beim Starten der Aufnahme:', error);
    }
  }
  
  function stopRecording() {
    if (!transportSystem) return;
    
    try {
      transportSystem.isRecording = false;
      console.log('‚úÖ Aufnahme gestoppt');
      updateTransportStatus('Aufnahme gestoppt');
      
      // Hier k√∂nnte die Aufnahme-Speicherung implementiert werden
    } catch (error) {
      console.error('‚ùå Fehler beim Stoppen der Aufnahme:', error);
    }
  }
  
  function updateTransportStatus(message) {
    console.log('Transport Status:', message);
    
    // Status in der UI aktualisieren
    const transportStatus = document.getElementById('transportStatus');
    if (transportStatus) {
      transportStatus.innerHTML = `
        <div style="padding:10px; background:#e8f5e8; border-radius:8px; margin:10px 0; border-left:4px solid #1db954;">
          <strong>‚èØÔ∏è Transport:</strong> ${message}
        </div>
      `;
    }
  }
  
  // Audio-Status √ºberpr√ºfen
  function checkAudioStatus() {
    if (!audioContext) {
      console.log('AudioContext nicht initialisiert');
      return false;
    }
    
    if (audioContext.state === 'suspended') {
      console.log('AudioContext ausgesetzt - ben√∂tigt User-Interaktion');
      return false;
    }
    
    if (audioContext.state === 'closed') {
      console.log('AudioContext geschlossen - neu erstellen');
      audioContext = null;
      return false;
    }
    
    console.log('‚úÖ AudioContext Status:', audioContext.state);
    return true;
  }
  
  function openDAW() {
    if (!window.Tone) {
      alert('Bitte aktivieren Sie zuerst Audio √ºber den "üîä Audio aktivieren" Button');
      return;
    }
    
    dawActive = true;
    
    // DAW-Interface anzeigen
    const dawTab = document.getElementById('daw-tab');
    if (dawTab) {
      dawTab.style.display = 'block';
      
      // Alle anderen Tabs ausblenden
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.style.display = 'none';
      });
      
      // DAW-Tab aktivieren
      dawTab.style.display = 'block';
      
      // Navigation aktualisieren
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector('[data-tab="daw"]').classList.add('active');
    }
    
    // Waveform-Editor initialisieren
    initWaveformEditor();
    
    // Live-Akkorde f√ºr DAW aktivieren
    activateLiveChordsForDAW();
    
    console.log('DAW erfolgreich ge√∂ffnet - Alle Tools sind jetzt verf√ºgbar');
  }
  
  function activateLiveChordsForDAW() {
    try {
      // DAW f√ºr Live-Akkorde anmelden
      const subscriberId = subscribeToLiveChords((chords, source) => {
        console.log('üé∏ DAW erh√§lt Live-Akkorde:', chords, 'von', source);
        
        // Akkorde in DAW-Status anzeigen
        updateDAWStatus(`Live-Akkorde: ${chords.join(' ')} (${source})`);
        
        // Akkorde f√ºr Effekte verf√ºgbar machen
        updateEffectsWithChords(chords);
        
        // Multi-Track mit Akkorden aktualisieren
        updateMultiTrackWithChords(chords);
        
      }, 'DAW');
      
      console.log('‚úÖ DAW f√ºr Live-Akkorde angemeldet, ID:', subscriberId);
      
    } catch (error) {
      console.error('‚ùå Fehler beim Aktivieren der Live-Akkorde f√ºr DAW:', error);
    }
  }
  
  function updateEffectsWithChords(chords) {
    try {
      // Effekte mit aktuellen Akkorden aktualisieren
      if (effectsChain && effectsChain.length > 0) {
        effectsChain.forEach(effect => {
          if (effect.parameters && effect.parameters.chord) {
            effect.parameters.chord = chords[0] || 'C';
          }
        });
        
        // Effekte-Kette neu rendern
        updateEffectsChain();
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Effekte mit Akkorden:', error);
    }
  }
  
  function updateMultiTrackWithChords(chords) {
    try {
      // Multi-Track mit aktuellen Akkorden aktualisieren
      if (multiTrackTracks && multiTrackTracks.length > 0) {
        multiTrackTracks.forEach(track => {
          if (track.chord) {
            track.chord = chords[0] || 'C';
          }
        });
        
        // Tracks neu rendern
        updateTracksDisplay();
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des Multi-Tracks mit Akkorden:', error);
    }
  }
  
  function updateDAWStatus(message) {
    try {
      const statusElement = document.getElementById('dawStatus');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.style.color = '#1db954';
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des DAW-Status:', error);
    }
  }
  
  function initWaveformEditor() {
    const waveformEditor = document.getElementById('waveformEditor');
    waveformEditor.innerHTML = `
      <h4>üéº Waveform-Editor</h4>
      <div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">
        <canvas id="waveformCanvas" width="800" height="200" style="border:1px solid #dee2e6; border-radius:4px; cursor:crosshair; width:100%; height:200px;"></canvas>
        <div style="margin-top:10px; font-size:12px; color:#6c757d;">
          <strong>Werkzeuge:</strong> Linksklick + Drag f√ºr Auswahl, Rechtsklick f√ºr Kontext-Men√º
        </div>
        <div id="waveformSelectionInfo" style="margin-top:10px; font-size:12px; color:#007bff;"></div>
      </div>
    `;
    
    // Maus-Markierung implementieren
    const canvas = document.getElementById('waveformCanvas');
    if (canvas) {
      let isSelecting = false;
      let selectionStart = 0;
      let selectionEnd = 0;
      
      canvas.addEventListener('mousedown', (e) => {
        isSelecting = true;
        const rect = canvas.getBoundingClientRect();
        selectionStart = e.clientX - rect.left;
        selectionEnd = selectionStart;
        drawWaveformWithSelection(canvas, selectionStart, selectionEnd);
      });
      
      canvas.addEventListener('mousemove', (e) => {
        if (isSelecting) {
          const rect = canvas.getBoundingClientRect();
          selectionEnd = e.clientX - rect.left;
          drawWaveformWithSelection(canvas, selectionStart, selectionEnd);
        }
      });
      
      canvas.addEventListener('mouseup', () => {
        isSelecting = false;
        if (selectionStart !== selectionEnd) {
          waveformSelection = {
            start: Math.min(selectionStart, selectionEnd) / canvas.width,
            end: Math.max(selectionStart, selectionEnd) / canvas.width
          };
          updateWaveformSelectionInfo();
          console.log('Waveform-Auswahl:', waveformSelection);
        }
      });
      
      // Initiale Waveform zeichnen
      drawWaveformWithSelection(canvas, 0, 0);
    }
  }
  
  function drawWaveformWithSelection(canvas, start, end) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Zeichne Waveform (Beispiel)
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x++) {
      const y = canvas.height / 2 + Math.sin(x * 0.1) * 50;
      if (x === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();
    
    // Zeichne Auswahl
    if (start !== end) {
      ctx.fillStyle = 'rgba(0, 123, 255, 0.3)';
      ctx.fillRect(Math.min(start, end), 0, Math.abs(end - start), canvas.height);
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.strokeRect(Math.min(start, end), 0, Math.abs(end - start), canvas.height);
    }
  }
  
  function updateWaveformSelectionInfo() {
    const infoEl = document.getElementById('waveformSelectionInfo');
    if (infoEl && waveformSelection) {
      const startPercent = Math.round(waveformSelection.start * 100);
      const endPercent = Math.round(waveformSelection.end * 100);
      infoEl.textContent = `Auswahl: ${startPercent}% - ${endPercent}%`;
    }
  }
  
  function importAudio() {
    if (!dawActive) {
      alert('Bitte √∂ffnen Sie zuerst die DAW');
      return;
    }
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/*';
    input.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        loadAudioFile(file);
      }
    };
    input.click();
  }
  
  function loadAudioFile(file) {
    console.log('Lade Audiodatei:', file.name, 'Gr√∂√üe:', file.size, 'Typ:', file.type);
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const arrayBuffer = e.target.result;
      console.log('ArrayBuffer geladen, Gr√∂√üe:', arrayBuffer.byteLength);
      
      // Web Audio API verwenden (funktioniert immer, auch ohne Tone.js)
      console.log('Verarbeite Audio mit Web Audio API...');
      
      try {
        // AudioContext sicher initialisieren
        const ctx = initializeAudioContext();
        if (!ctx) {
          throw new Error('AudioContext konnte nicht erstellt werden');
        }
        
        // Audio-Datei dekodieren
        ctx.decodeAudioData(arrayBuffer).then(buffer => {
          console.log('Audio erfolgreich verarbeitet:', buffer.duration.toFixed(2) + 's,', buffer.numberOfChannels, 'Kan√§le,', buffer.sampleRate, 'Hz');
          
          // Audio in globalen Buffer laden
          currentAudioBuffer = buffer;
          
          // Status aktualisieren
          updateAudioStatus('Audio geladen: ' + file.name + ' (' + buffer.duration.toFixed(2) + 's)');
          
          // Waveform in allen relevanten Editoren anzeigen
          displayWaveform(buffer);
          showAudioInfo(buffer);
          
          // Waveframe-Editor aktualisieren
          if (document.getElementById('waveframeEditor')) {
            console.log('Aktualisiere Waveframe-Editor...');
            updateWaveframeEditor(buffer);
          }
          
          // Multi-Track-Editor aktualisieren
          if (multiTrackTracks.length > 0) {
            updateTracksDisplay();
          }
          
          // Alle Tabs mit Audio-Informationen aktualisieren
          updateAllAudioTabs(buffer);
          
          console.log('‚úÖ Audio erfolgreich geladen und in allen Tools verf√ºgbar:', file.name, 'Dauer:', buffer.duration.toFixed(2) + 's');
        }).catch(error => {
          console.error('‚ùå Fehler beim Dekodieren der Audiodatei:', error);
          alert('Fehler beim Laden der Audiodatei: ' + error.message);
          updateAudioStatus('Fehler beim Laden der Audiodatei');
        });
        
      } catch (error) {
        console.error('‚ùå Fehler beim Erstellen des AudioContext:', error);
        alert('Fehler beim Erstellen des AudioContext: ' + error.message);
        updateAudioStatus('Fehler beim Erstellen des AudioContext');
      }
    };
    
    reader.onerror = function() {
      console.error('Fehler beim Lesen der Datei');
      alert('Fehler beim Lesen der Audiodatei');
      updateAudioStatus('Fehler beim Lesen der Datei');
    };
    
    reader.readAsArrayBuffer(file);
  }
  
  // Hilfsfunktionen f√ºr Audio-Status und Updates
  function updateAudioStatus(message) {
    console.log('Audio-Status:', message);
    
    // Status in allen relevanten Bereichen anzeigen
    const statusElements = [
      'waveformEditor',
      'waveframeEditor',
      'multiTrackEditor',
      'projectManager'
    ];
    
    statusElements.forEach(elementId => {
      const element = document.getElementById(elementId);
      if (element) {
        const statusDiv = element.querySelector('.audio-status') || createStatusDiv(element);
        statusDiv.innerHTML = `<div style="padding:10px; background:#e8f5e8; border-radius:8px; margin:10px 0;">üìä ${message}</div>`;
      }
    });
  }
  
  function createStatusDiv(parentElement) {
    const statusDiv = document.createElement('div');
    statusDiv.className = 'audio-status';
    parentElement.appendChild(statusDiv);
    return statusDiv;
  }
  
  function updateWaveframeEditor(buffer) {
    const waveframeEditor = document.getElementById('waveframeEditor');
    if (!waveframeEditor) return;
    
    console.log('Aktualisiere Waveframe-Editor mit Buffer:', buffer.duration.toFixed(2) + 's');
    
    // Waveframe-Editor mit geladenem Audio aktualisieren
    waveframeEditor.innerHTML = `
      <div style="display:flex; gap:20px; height:400px;">
        <div style="flex:1; border:1px solid #ccc; border-radius:8px; padding:15px; background:#fff;">
          <h4>üéº Waveform Editor - ${buffer.duration.toFixed(2)}s</h4>
          <canvas id="waveformCanvas" width="600" height="200" style="border:1px solid #ddd; background:#000; cursor:crosshair;"></canvas>
          <div style="margin-top:15px;">
            <button onclick="zoomWaveform(2)" class="btn">üîç Zoom In</button>
            <button onclick="zoomWaveform(0.5)" class="btn">üîç Zoom Out</button>
            <button onclick="resetWaveformZoom()" class="btn">üîç Reset</button>
          </div>
        </div>
        <div style="flex:1; border:1px solid #ccc; border-radius:8px; padding:15px; background:#f8f9fa;">
          <h4>üéõÔ∏è Tools & Controls</h4>
          <div class="controls">
            <button onclick="selectWaveformTool('select')" class="btn">üëÜ Select</button>
            <button onclick="selectWaveformTool('cut')" class="btn">‚úÇÔ∏è Cut</button>
            <button onclick="selectWaveformTool('copy')" class="btn">üìã Copy</button>
            <button onclick="selectWaveformTool('paste')" class="btn">üìå Paste</button>
            <button onclick="selectWaveformTool('fade')" class="btn">üìà Fade</button>
            <button onclick="selectWaveformTool('normalize')" class="btn">üìä Normalize</button>
          </div>
          <div style="margin-top:15px;">
            <label>Gain: <input type="range" id="waveformGain" min="-20" max="20" value="0" step="0.1" onchange="adjustWaveformGain(this.value)"></label>
            <label>Pan: <input type="range" id="waveformPan" min="-1" max="1" value="0" step="0.1" onchange="adjustWaveformPan(this.value)"></label>
          </div>
        </div>
      </div>
      <div style="margin-top:15px; padding:15px; background:#e8f5e8; border-radius:8px;">
        <h4>üìä Audio Information</h4>
        <div id="audioInfo" style="font-family:monospace; font-size:14px;">
          <p><strong>Datei geladen:</strong> ${buffer.duration.toFixed(2)}s, ${buffer.numberOfChannels} Kan√§le, ${buffer.sampleRate} Hz</p>
        </div>
      </div>
    `;
    
    // Canvas f√ºr Kontext-Men√º vorbereiten
    setTimeout(() => {
      const canvas = document.getElementById('waveformCanvas');
      if (canvas) {
        console.log('Waveframe-Canvas gefunden, zeichne Waveform...');
                  drawPCMWaveformOnCanvas(canvas, buffer);
        setupWaveformCanvasEvents(canvas);
        
        // Waveframe-spezifische Events
        canvas.addEventListener('contextmenu', showWaveframeContextMenu);
        canvas.addEventListener('mousedown', handleWaveformMouseDown);
        canvas.addEventListener('mousemove', handleWaveformMouseMove);
        canvas.addEventListener('mouseup', handleWaveformMouseUp);
        
        console.log('Waveframe-Editor vollst√§ndig eingerichtet');
      } else {
        console.error('Waveframe-Canvas nicht gefunden');
      }
    }, 100);
  }
  
  function updateAllAudioTabs(buffer) {
    console.log('Aktualisiere alle Audio-Tabs...');
    
    // Alle Tabs mit Audio-Informationen aktualisieren
    const audioTabs = ['daw', 'waveframe', 'multiTrack', 'project'];
    
    audioTabs.forEach(tabName => {
      const tabElement = document.getElementById(tabName + '-tab');
      if (tabElement) {
        console.log(`Aktualisiere ${tabName}-Tab`);
        
        // Tab-spezifische Updates
        switch(tabName) {
          case 'daw':
            if (document.getElementById('waveformEditor')) {
              displayWaveform(buffer);
            }
            break;
          case 'waveframe':
            if (document.getElementById('waveframeEditor')) {
              updateWaveframeEditor(buffer);
            }
            break;
          case 'multiTrack':
            if (multiTrackTracks.length > 0) {
              updateTracksDisplay();
            }
            break;
          case 'project':
            if (currentProject) {
              updateProjectDisplay();
            }
            break;
        }
      }
    });
    
    console.log('Alle Audio-Tabs aktualisiert');
  }
  

  
  function displayWaveform(buffer) {
    // Alle verf√ºgbaren Waveform-Editoren aktualisieren
    
    // 1. Echte PCM Waveform-Editor
    const waveformEditor = document.getElementById('waveformEditor');
    if (waveformEditor) {
      waveformEditor.innerHTML = `
        <h4>üéº Echte PCM Waveform-Editor - ${buffer.duration.toFixed(2)}s</h4>
        <div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">
          <div style="margin-bottom:10px; padding:10px; background:#e8f5e8; border-radius:6px; border-left:4px solid #1db954;">
            <strong>üéØ Echte Pulse Code Modulation (PCM):</strong><br>
            ‚Ä¢ Maus-Drag f√ºr Auswahl | ‚Ä¢ Mausrad f√ºr Zoom (bis 1000x) | ‚Ä¢ Pfeiltasten f√ºr Navigation | ‚Ä¢ ESC f√ºr Auswahl l√∂schen
          </div>
          <canvas id="mainWaveformCanvas" width="800" height="300" style="border:1px solid #dee2e6; border-radius:4px; background:#000; cursor:crosshair;"></canvas>
          <div style="margin-top:10px;">
            <input type="range" id="waveformScrollbar" min="0" max="100" value="0" style="width:100%; height:20px;" />
            <div style="display:flex; justify-content:space-between; margin-top:5px; font-size:12px; color:#666;">
              <span id="scrollbarStart">0:00</span>
              <span id="scrollbarEnd">0:00</span>
            </div>
          </div>
          <div style="margin-top:15px; display:flex; gap:10px; flex-wrap:wrap;">
            <button onclick="playAudio()" class="btn">‚ñ∂Ô∏è Abspielen</button>
            <button onclick="stopAudio()" class="btn">‚èπ Stoppen</button>
            <button onclick="zoomPCMWaveform(2)" class="btn">üîç Zoom In</button>
            <button onclick="zoomPCMWaveform(0.5)" class="btn">üîç Zoom Out</button>
            <button onclick="resetPCMWaveformZoom()" class="btn">üîç Reset</button>
            <button onclick="cutPCMSelection()" class="btn">‚úÇÔ∏è Ausschneiden</button>
            <button onclick="copyPCMSelection()" class="btn">üìã Kopieren</button>
            <button onclick="pastePCMSelection()" class="btn">üìã Einf√ºgen</button>
            <button onclick="deletePCMSelection()" class="btn">üóëÔ∏è L√∂schen</button>
            <button onclick="normalizePCMSelection()" class="btn">üìä Normalisieren</button>
            <button onclick="reversePCMSelection()" class="btn">üîÑ Umkehren</button>
            <button onclick="fadePCMSelection()" class="btn">üéöÔ∏è Fade</button>
            <button onclick="saveAudioFile()" class="btn">üíæ Speichern</button>
            <button onclick="exportAudioMP3()" class="btn">üì§ MP3 Export</button>
            <button onclick="exportAudioFLAC()" class="btn">üì§ FLAC Export</button>
          </div>
          <div id="pcmSelectionInfo" style="margin-top:10px;"></div>
        </div>
      `;
      
      // Canvas f√ºr PCM-Waveform vorbereiten
      setTimeout(() => {
        const canvas = document.getElementById('mainWaveformCanvas');
        if (canvas) {
          drawPCMWaveformOnCanvas(canvas, buffer);
          setupPCMWaveformEvents(canvas);
        }
      }, 100);
    }
    
    // 2. Waveframe-Editor aktualisieren
    const waveframeEditor = document.getElementById('waveframeEditor');
    if (waveframeEditor && document.getElementById('waveformCanvas')) {
      redrawWaveform();
    }
    
    // 3. Multi-Track-Editor aktualisieren
    if (multiTrackTracks.length > 0) {
      updateTracksDisplay();
    }
    
    console.log('Echte PCM Waveform in allen Editoren aktualisiert');
  }
  
  function drawPCMWaveformOnCanvas(canvas, buffer) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Canvas l√∂schen
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    
    // Echte PCM Waveform zeichnen (Pulse Code Modulation)
    const channelData = buffer.getChannelData(0);
    const totalSamples = channelData.length;
    const visibleSamples = Math.floor(totalSamples / waveformZoom);
    const startSample = Math.floor(waveformOffset * totalSamples);
    const endSample = Math.min(startSample + visibleSamples, totalSamples);
    
    const step = Math.max(1, Math.ceil((endSample - startSample) / width));
    const amp = height / 2;
    
    // PCM-Samples als Punkte zeichnen
    ctx.fillStyle = '#1db954';
    ctx.strokeStyle = '#1db954';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < width; i++) {
      const dataIndex = startSample + (i * step);
      if (dataIndex < endSample) {
        const value = channelData[dataIndex] || 0;
        const y = (value * amp) + amp;
        
        // PCM-Sample als Punkt zeichnen
        ctx.beginPath();
        ctx.arc(i, y, 1, 0, 2 * Math.PI);
        ctx.fill();
        
        // Verbindungslinien zwischen Samples
        if (i > 0) {
          const prevDataIndex = startSample + ((i - 1) * step);
          if (prevDataIndex < endSample) {
            const prevValue = channelData[prevDataIndex] || 0;
            const prevY = (prevValue * amp) + amp;
            
            ctx.beginPath();
            ctx.moveTo(i - 1, prevY);
            ctx.lineTo(i, y);
            ctx.stroke();
          }
        }
      }
    }
    
    // Zoom-Level und PCM-Info anzeigen
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(10, 10, 300, 40);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`PCM Zoom: ${waveformZoom.toFixed(1)}x | Offset: ${(waveformOffset * 100).toFixed(1)}% | Samples: ${totalSamples.toLocaleString()}`, 15, 30);
    ctx.fillText(`Sample Rate: ${buffer.sampleRate}Hz | Channels: ${buffer.numberOfChannels} | Duration: ${buffer.duration.toFixed(3)}s`, 15, 45);
    
    // Auswahl zeichnen
    if (waveformSelection) {
      ctx.fillStyle = 'rgba(29, 185, 84, 0.3)';
      ctx.fillRect(waveformSelection.start, 0, waveformSelection.end - waveformSelection.start, height);
      ctx.strokeStyle = '#1db954';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(waveformSelection.start, 0, waveformSelection.end - waveformSelection.start, height);
      ctx.setLineDash([]);
    }
  }
  
  function setupPCMWaveformEvents(canvas) {
    // Maus-Events f√ºr PCM-Auswahl
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      window.selectionStart = x;
      window.isSelecting = true;
      window.waveformSelection = { start: x, end: x };
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (window.isSelecting) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        window.waveformSelection.end = x;
        drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      window.isSelecting = false;
      if (window.waveformSelection && Math.abs(window.waveformSelection.end - window.waveformSelection.start) > 5) {
        showPCMSelectionInfo();
      }
    });
    
    // Rechtsklick-Men√º
    canvas.addEventListener('contextmenu', showMainWaveformContextMenu);
    
    // Zoom-Events (Mausrad)
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      waveformZoom = Math.max(0.1, Math.min(1000, waveformZoom * zoomFactor));
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
    });
    
    // Scrollbar-Funktionalit√§t
    const scrollbar = document.getElementById('waveformScrollbar');
    if (scrollbar) {
      scrollbar.addEventListener('input', (e) => {
        waveformOffset = parseInt(e.target.value) / 100;
        drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
        updateScrollbarLabels();
      });
    }
    
    // Keyboard-Shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      
      switch (e.key) {
        case 'z':
          if (e.ctrlKey) {
            e.preventDefault();
            waveformZoom = Math.max(0.1, waveformZoom * 0.9);
            drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
            updateScrollbarLabels();
          }
          break;
        case 'Z':
          if (e.ctrlKey) {
            e.preventDefault();
            waveformZoom = Math.min(1000, waveformZoom * 1.1);
            drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
            updateScrollbarLabels();
          }
          break;
        case 'ArrowLeft':
          e.preventDefault();
          waveformOffset = Math.max(0, waveformOffset - 0.1);
          drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
          updateScrollbarLabels();
          break;
        case 'ArrowRight':
          e.preventDefault();
          waveformOffset = Math.min(1, waveformOffset + 0.1);
          drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
          updateScrollbarLabels();
          break;
        case 'Escape':
          window.waveformSelection = null;
          drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
          break;
      }
    });
    
    console.log('PCM Waveform-Events eingerichtet');
  }
  
  function showPCMSelectionInfo() {
    if (!waveformSelection || !currentAudioBuffer) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const totalSamples = currentAudioBuffer.length;
    const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
    const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
    const selectionSamples = Math.abs(endSample - startSample);
    const selectionTime = selectionSamples / currentAudioBuffer.sampleRate;
    
    const infoDiv = document.getElementById('pcmSelectionInfo');
    if (infoDiv) {
      infoDiv.innerHTML = `
        <div style="padding:10px; background:#e8f5e8; border-radius:8px; margin:10px 0; border-left:4px solid #1db954;">
          <strong>üéØ PCM-Auswahl:</strong><br>
          <strong>Samples:</strong> ${startSample.toLocaleString()} - ${endSample.toLocaleString()} (${selectionSamples.toLocaleString()})<br>
          <strong>Zeit:</strong> ${(startSample / currentAudioBuffer.sampleRate).toFixed(3)}s - ${(endSample / currentAudioBuffer.sampleRate).toFixed(3)}s (${selectionTime.toFixed(3)}s)<br>
          <strong>Zoom:</strong> ${waveformZoom.toFixed(1)}x<br>
          <div style="margin-top:8px;">
            <button onclick="cutPCMSelection()" class="btn" style="margin-right:5px;">‚úÇÔ∏è Ausschneiden</button>
            <button onclick="copyPCMSelection()" class="btn" style="margin-right:5px;">üìã Kopieren</button>
            <button onclick="deletePCMSelection()" class="btn" style="margin-right:5px;">üóëÔ∏è L√∂schen</button>
            <button onclick="normalizePCMSelection()" class="btn" style="margin-right:5px;">üìä Normalisieren</button>
            <button onclick="reversePCMSelection()" class="btn" style="margin-right:5px;">üîÑ Umkehren</button>
            <button onclick="fadePCMSelection()" class="btn">üéöÔ∏è Fade</button>
          </div>
        </div>
      `;
    }
  }
  
  // PCM-Bearbeitungsfunktionen
  function cutPCMSelection() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    console.log('‚úÇÔ∏è PCM-Auswahl ausschneiden...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((window.waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((window.waveformSelection.end / width) * totalSamples);
      
      // Echte PCM-Bearbeitung
      const channelData = currentAudioBuffer.getChannelData(0);
      const cutData = channelData.slice(startSample, endSample);
      
      // In Zwischenablage kopieren
      window.pcmClipboard = {
        data: cutData,
        sampleRate: currentAudioBuffer.sampleRate,
        startTime: startSample / currentAudioBuffer.sampleRate,
        endTime: endSample / currentAudioBuffer.sampleRate
      };
      
      // Auswahl aus Original entfernen
      const newData = new Float32Array(totalSamples - cutData.length);
      newData.set(channelData.slice(0, startSample));
      newData.set(channelData.slice(endSample), startSample);
      
      // Neuen Buffer erstellen
      const newBuffer = audioContext.createBuffer(1, newData.length, currentAudioBuffer.sampleRate);
      newBuffer.getChannelData(0).set(newData);
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      console.log('‚úÖ PCM-Auswahl ausgeschnitten und in Zwischenablage kopiert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Ausschneiden:', error);
      alert('Fehler beim Ausschneiden der PCM-Auswahl');
    }
  }
  
  function copyPCMSelection() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    console.log('üìã PCM-Auswahl kopieren...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((window.waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((window.waveformSelection.end / width) * totalSamples);
      
      // Echte PCM-Kopie
      const channelData = currentAudioBuffer.getChannelData(0);
      const copyData = channelData.slice(startSample, endSample);
      
      // In Zwischenablage kopieren
      window.pcmClipboard = {
        data: copyData,
        sampleRate: currentAudioBuffer.sampleRate,
        startTime: startSample / currentAudioBuffer.sampleRate,
        endTime: endSample / currentAudioBuffer.sampleRate
      };
      
      console.log('‚úÖ PCM-Auswahl kopiert');
      status.textContent = 'PCM-Auswahl kopiert';
      
    } catch (error) {
      console.error('‚ùå Fehler beim Kopieren:', error);
      status.textContent = 'Fehler beim Kopieren';
    }
  }
  
  function deletePCMSelection() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üóëÔ∏è PCM-Auswahl l√∂schen...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const newData = new Float32Array(totalSamples - (endSample - startSample));
      
      // Daten vor der Auswahl kopieren
      newData.set(channelData.slice(0, startSample));
      
      // Daten nach der Auswahl kopieren
      newData.set(channelData.slice(endSample), startSample);
      
      // Neuen Buffer erstellen
      const newBuffer = audioContext.createBuffer(1, newData.length, currentAudioBuffer.sampleRate);
      newBuffer.getChannelData(0).set(newData);
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      showNotification('‚úÖ PCM-Auswahl gel√∂scht', 'Ausgew√§hlter Bereich wurde erfolgreich entfernt', 'success');
      console.log('‚úÖ PCM-Auswahl gel√∂scht');
      
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen:', error);
      showNotification('‚ùå Fehler beim L√∂schen', 'Fehler beim L√∂schen der PCM-Auswahl', 'error');
    }
  }
  
  function normalizePCMSelection() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üìä PCM-Auswahl normalisieren...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // Maximum in der Auswahl finden
      let maxValue = 0;
      for (let i = startSample; i < endSample; i++) {
        maxValue = Math.max(maxValue, Math.abs(channelData[i]));
      }
      
      if (maxValue === 0) {
        showNotification('‚ö†Ô∏è Keine Daten', 'Keine Audio-Daten in der Auswahl gefunden', 'warning');
        return;
      }
      
      // Normalisieren auf 0.95 (95% der maximalen Amplitude)
      const targetLevel = 0.95;
      const scaleFactor = targetLevel / maxValue;
      
      // Daten normalisieren
      for (let i = startSample; i < endSample; i++) {
        channelData[i] *= scaleFactor;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Auswahl normalisiert', `Normalisiert auf ${(targetLevel * 100).toFixed(0)}% der maximalen Amplitude`, 'success');
      console.log('‚úÖ PCM-Auswahl normalisiert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Normalisieren:', error);
      showNotification('‚ùå Fehler beim Normalisieren', 'Fehler beim Normalisieren der PCM-Auswahl', 'error');
    }
  }
  
  function reversePCMSelection() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üîÑ PCM-Auswahl umkehren...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Tempor√§res Array f√ºr die umgekehrten Daten
      const reversedData = new Float32Array(selectionLength);
      
      // Daten umkehren
      for (let i = 0; i < selectionLength; i++) {
        reversedData[i] = channelData[endSample - 1 - i];
      }
      
      // Umgekehrte Daten zur√ºck in den Buffer schreiben
      for (let i = 0; i < selectionLength; i++) {
        channelData[startSample + i] = reversedData[i];
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Auswahl umgekehrt', 'Ausgew√§hlter Bereich wurde erfolgreich umgekehrt', 'success');
      console.log('‚úÖ PCM-Auswahl umgekehrt');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Umkehren:', error);
      showNotification('‚ùå Fehler beim Umkehren', 'Fehler beim Umkehren der PCM-Auswahl', 'error');
    }
  }
  
  function fadePCMSelection() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üéöÔ∏è PCM-Auswahl Fade...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Fade-In und Fade-Out anwenden
      const fadeLength = Math.min(selectionLength / 4, 1000); // 25% oder max 1000 Samples
      
      // Fade-In (erste 25%)
      for (let i = 0; i < fadeLength; i++) {
        const fadeIn = i / fadeLength;
        channelData[startSample + i] *= fadeIn;
      }
      
      // Fade-Out (letzte 25%)
      for (let i = 0; i < fadeLength; i++) {
        const fadeOut = 1 - (i / fadeLength);
        channelData[endSample - 1 - i] *= fadeOut;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Fade angewendet', 'Fade-In und Fade-Out erfolgreich angewendet', 'success');
      console.log('‚úÖ PCM-Fade angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Fade:', error);
      showNotification('‚ùå Fehler beim Fade', 'Fehler beim Anwenden der Fade-Effekte', 'error');
    }
  }
  
  // Erweiterte PCM-Bearbeitungsfunktionen
  function pastePCMSelection() {
    if (!currentAudioBuffer || !window.pcmClipboard) return;
    console.log('üìã PCM-Auswahl einf√ºgen...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const insertPosition = Math.floor((window.waveformSelection ? window.waveformSelection.start : width / 2) / width * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const clipboardData = window.pcmClipboard.data;
      
      // √úberlappendes Einf√ºgen (Crossfade-Technik)
      const crossfadeLength = Math.min(1000, Math.floor(clipboardData.length * 0.1)); // 10% Crossfade
      
      // Neuen Buffer erstellen
      const newData = new Float32Array(totalSamples + clipboardData.length - crossfadeLength);
      
      // Daten vor Einf√ºgeposition kopieren
      newData.set(channelData.slice(0, insertPosition));
      
      // Crossfade-Bereich
      for (let i = 0; i < crossfadeLength; i++) {
        const fadeIn = i / crossfadeLength;
        const fadeOut = 1 - fadeIn;
        const originalSample = channelData[insertPosition + i] || 0;
        const newSample = clipboardData[i];
        newData[insertPosition + i] = (originalSample * fadeOut) + (newSample * fadeIn);
      }
      
      // Rest der eingef√ºgten Daten
      newData.set(clipboardData.slice(crossfadeLength), insertPosition + crossfadeLength);
      
      // Daten nach Einf√ºgeposition kopieren
      newData.set(channelData.slice(insertPosition + crossfadeLength), insertPosition + clipboardData.length);
      
      // Neuen Buffer erstellen
      const newBuffer = audioContext.createBuffer(1, newData.length, currentAudioBuffer.sampleRate);
      newBuffer.getChannelData(0).set(newData);
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      console.log('‚úÖ PCM-Auswahl √ºberlappend eingef√ºgt (Crossfade)');
      status.textContent = 'PCM-Auswahl √ºberlappend eingef√ºgt';
      
    } catch (error) {
      console.error('‚ùå Fehler beim Einf√ºgen:', error);
      status.textContent = 'Fehler beim Einf√ºgen';
    }
  }
  
  function fadeInPCMSelection() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    console.log('üéöÔ∏è PCM-Fade In...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((window.waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((window.waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const fadeLength = endSample - startSample;
      
      // Fade-In anwenden
      for (let i = 0; i < fadeLength; i++) {
        const fadeFactor = i / fadeLength;
        channelData[startSample + i] *= fadeFactor;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      console.log('‚úÖ PCM-Fade In angewendet');
      status.textContent = 'PCM-Fade In angewendet';
      
    } catch (error) {
      console.error('‚ùå Fehler beim Fade In:', error);
      status.textContent = 'Fehler beim Fade In';
    }
  }
  
  function fadeOutPCMSelection() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    console.log('üéöÔ∏è PCM-Fade Out...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((window.waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((window.waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const fadeLength = endSample - startSample;
      
      // Fade-Out anwenden
      for (let i = 0; i < fadeLength; i++) {
        const fadeFactor = 1 - (i / fadeLength);
        channelData[startSample + i] *= fadeFactor;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      console.log('‚úÖ PCM-Fade Out angewendet');
      status.textContent = 'PCM-Fade Out angewendet';
      
    } catch (error) {
      console.error('‚ùå Fehler beim Fade Out:', error);
      status.textContent = 'Fehler beim Fade Out';
    }
  }
  
  function crossfadePCMSelection() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    console.log('üéöÔ∏è PCM-Crossfade...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((window.waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((window.waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const fadeLength = Math.min(1000, Math.floor((endSample - startSample) * 0.1));
      
      // Crossfade anwenden (Fade-In und Fade-Out gleichzeitig)
      for (let i = 0; i < fadeLength; i++) {
        const fadeIn = i / fadeLength;
        const fadeOut = 1 - fadeIn;
        
        // Fade-In am Anfang
        if (startSample + i < channelData.length) {
          channelData[startSample + i] *= fadeIn;
        }
        
        // Fade-Out am Ende
        if (endSample - fadeLength + i >= 0 && endSample - fadeLength + i < channelData.length) {
          channelData[endSample - fadeLength + i] *= fadeOut;
        }
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      console.log('‚úÖ PCM-Crossfade angewendet');
      status.textContent = 'PCM-Crossfade angewendet';
      
    } catch (error) {
      console.error('‚ùå Fehler beim Crossfade:', error);
      status.textContent = 'Fehler beim Crossfade';
    }
  }
  
  function adjustPCMVolume(factor) {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log(`üîä PCM-Lautst√§rke anpassen: ${factor}x`);
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // Lautst√§rke anpassen
      for (let i = startSample; i < endSample; i++) {
        channelData[i] *= factor;
        
        // Clipping verhindern
        if (channelData[i] > 1.0) channelData[i] = 1.0;
        if (channelData[i] < -1.0) channelData[i] = -1.0;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Lautst√§rke angepasst', `Lautst√§rke um ${factor}x ge√§ndert`, 'success');
      console.log('‚úÖ PCM-Lautst√§rke angepasst');
      
    } catch (error) {
      console.error('‚ùå Fehler bei Lautst√§rke-Anpassung:', error);
      showNotification('‚ùå Fehler bei Lautst√§rke-Anpassung', 'Fehler beim Anpassen der Lautst√§rke', 'error');
    }
  }
  
  function adjustPCMPitch(factor) {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log(`üéµ PCM-Pitch anpassen: ${factor}x`);
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Pitch-Shifting durch Sample-Rate-√Ñnderung simulieren
      const newLength = Math.floor(selectionLength / factor);
      const newBuffer = audioContext.createBuffer(1, totalSamples - selectionLength + newLength, currentAudioBuffer.sampleRate);
      const newData = newBuffer.getChannelData(0);
      
      // Daten vor der Auswahl kopieren
      newData.set(channelData.slice(0, startSample));
      
      // Pitch-Shifting anwenden (einfache Interpolation)
      for (let i = 0; i < newLength; i++) {
        const oldIndex = startSample + Math.floor(i * factor);
        if (oldIndex < endSample) {
          newData[startSample + i] = channelData[oldIndex];
        }
      }
      
      // Daten nach der Auswahl kopieren
      newData.set(channelData.slice(endSample), startSample + newLength);
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      showNotification('‚úÖ PCM-Pitch angepasst', `Pitch um ${factor}x ge√§ndert`, 'success');
      console.log('‚úÖ PCM-Pitch angepasst');
      
    } catch (error) {
      console.error('‚ùå Fehler bei Pitch-Anpassung:', error);
      showNotification('‚ùå Fehler bei Pitch-Anpassung', 'Fehler beim Anpassen der Tonh√∂he', 'error');
    }
  }
  
  function adjustPCMTempo(factor) {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log(`‚è±Ô∏è PCM-Tempo anpassen: ${factor}x`);
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Tempo-√Ñnderung durch Sample-Stretching
      const newLength = Math.floor(selectionLength * factor);
      const newBuffer = audioContext.createBuffer(1, totalSamples - selectionLength + newLength, currentAudioBuffer.sampleRate);
      const newData = newBuffer.getChannelData(0);
      
      // Daten vor der Auswahl kopieren
      newData.set(channelData.slice(0, startSample));
      
      // Tempo-Stretching anwenden (einfache Interpolation)
      for (let i = 0; i < newLength; i++) {
        const oldIndex = startSample + (i / factor);
        const index1 = Math.floor(oldIndex);
        const index2 = Math.min(index1 + 1, endSample - 1);
        const fraction = oldIndex - index1;
        
        if (index1 < endSample) {
          newData[startSample + i] = channelData[index1] * (1 - fraction) + channelData[index2] * fraction;
        }
      }
      
      // Daten nach der Auswahl kopieren
      newData.set(channelData.slice(endSample), startSample + newLength);
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      showNotification('‚úÖ PCM-Tempo angepasst', `Tempo um ${factor}x ge√§ndert`, 'success');
      console.log('‚úÖ PCM-Tempo angepasst');
      
    } catch (error) {
      console.error('‚ùå Fehler bei Tempo-Anpassung:', error);
      showNotification('‚ùå Fehler bei Tempo-Anpassung', 'Fehler beim Anpassen des Tempos', 'error');
    }
  }
  
  function zoomToPCMSelection() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üîç Zoom auf PCM-Auswahl...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      // Zoom-Bereich berechnen
      const selectionWidth = waveformSelection.end - waveformSelection.start;
      const zoomFactor = canvas.width / selectionWidth;
      
      // Zoom-Parameter setzen
      window.currentZoom = {
        start: waveformSelection.start,
        end: waveformSelection.end,
        factor: zoomFactor
      };
      
      // Waveform mit Zoom neu zeichnen
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      // Scrollbar-Position anpassen
      const scrollbar = document.getElementById('waveformScrollbar');
      if (scrollbar) {
        const scrollPosition = (waveformSelection.start / canvas.width) * 100;
        scrollbar.value = scrollPosition;
      }
      
      showNotification('‚úÖ PCM-Zoom angewendet', `Zoom auf ausgew√§hlten Bereich (${(zoomFactor).toFixed(1)}x)`, 'success');
      console.log('‚úÖ PCM-Zoom angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Zoom:', error);
      showNotification('‚ùå Fehler beim Zoom', 'Fehler beim Anwenden des Zooms', 'error');
    }
  }
  
  function applyPCMEQ(band, type) {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log(`üéõÔ∏è PCM-EQ ${band} ${type}...`);
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // EQ-Parameter basierend auf Band und Typ
      let gain = 1.0;
      let frequency = 1000;
      
      switch (band) {
        case 'low':
          frequency = 250;
          gain = type === 'boost' ? 2.0 : 0.5;
          break;
        case 'mid':
          frequency = 1000;
          gain = type === 'boost' ? 1.5 : 0.7;
          break;
        case 'high':
          frequency = 4000;
          gain = type === 'boost' ? 1.8 : 0.6;
          break;
      }
      
      // Einfacher EQ durch Frequenzfilterung simulieren
      const sampleRate = currentAudioBuffer.sampleRate;
      const filterLength = Math.min(1000, endSample - startSample);
      
      // FIR-Filter f√ºr EQ simulieren
      for (let i = startSample; i < endSample; i++) {
        let filtered = 0;
        for (let j = 0; j < filterLength && i + j < endSample; j++) {
          const filterCoeff = Math.sin(2 * Math.PI * frequency * j / sampleRate) / (j + 1);
          filtered += channelData[i + j] * filterCoeff;
        }
        
        // Gain anwenden
        channelData[i] = channelData[i] * (1 - 0.3) + filtered * gain * 0.3;
        
        // Clipping verhindern
        if (channelData[i] > 1.0) channelData[i] = 1.0;
        if (channelData[i] < -1.0) channelData[i] = -1.0;
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-EQ angewendet', `${band} ${type} erfolgreich angewendet`, 'success');
      console.log('‚úÖ PCM-EQ angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim EQ:', error);
      showNotification('‚ùå Fehler beim EQ', 'Fehler beim Anwenden des EQ-Effekts', 'error');
    }
  }
  
  function applyPCMCompressor() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üé≠ PCM-Kompressor...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // Kompressor-Parameter
      const threshold = 0.3; // Schwellwert
      const ratio = 4; // Kompressionsverh√§ltnis
      const attack = 0.01; // Attack-Zeit
      const release = 0.1; // Release-Zeit
      
      let envelope = 0;
      const attackCoeff = Math.exp(-1 / (attack * currentAudioBuffer.sampleRate));
      const releaseCoeff = Math.exp(-1 / (release * currentAudioBuffer.sampleRate));
      
      // Kompressor anwenden
      for (let i = startSample; i < endSample; i++) {
        const inputLevel = Math.abs(channelData[i]);
        
        // Envelope folgen
        if (inputLevel > envelope) {
          envelope = attackCoeff * envelope + (1 - attackCoeff) * inputLevel;
        } else {
          envelope = releaseCoeff * envelope + (1 - releaseCoeff) * inputLevel;
        }
        
        // Kompression berechnen
        if (envelope > threshold) {
          const gainReduction = Math.pow(envelope / threshold, 1/ratio - 1);
          channelData[i] *= gainReduction;
        }
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Kompressor angewendet', `Kompression mit Ratio ${ratio}:1 angewendet`, 'success');
      console.log('‚úÖ PCM-Kompressor angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Kompressor:', error);
      showNotification('‚ùå Fehler beim Kompressor', 'Fehler beim Anwenden der Kompression', 'error');
    }
  }
  
  function applyPCMLimiter() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üé≠ PCM-Limiter...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // Limiter-Parameter
      const threshold = 0.8; // Begrenzungsschwelle
      const ratio = 20; // Sehr hohe Ratio f√ºr Limiter
      
      // Limiter anwenden
      for (let i = startSample; i < endSample; i++) {
        const inputLevel = Math.abs(channelData[i]);
        
        if (inputLevel > threshold) {
          const gainReduction = Math.pow(inputLevel / threshold, 1/ratio - 1);
          channelData[i] *= gainReduction;
        }
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Limiter angewendet', 'Begrenzung erfolgreich angewendet', 'success');
      console.log('‚úÖ PCM-Limiter angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Limiter:', error);
      showNotification('‚ùå Fehler beim Limiter', 'Fehler beim Anwenden der Begrenzung', 'error');
    }
  }
  
  function applyPCMGate() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üé≠ PCM-Gate...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      
      // Gate-Parameter
      const threshold = 0.1; // Gate-Schwelle
      const ratio = 10; // Gate-Ratio
      const attack = 0.001; // Attack-Zeit
      const release = 0.01; // Release-Zeit
      
      let gateLevel = 0;
      const attackCoeff = Math.exp(-1 / (attack * currentAudioBuffer.sampleRate));
      const releaseCoeff = Math.exp(-1 / (release * currentAudioBuffer.sampleRate));
      
      // Gate anwenden
      for (let i = startSample; i < endSample; i++) {
        const inputLevel = Math.abs(channelData[i]);
        
        // Gate-Level folgen
        if (inputLevel > threshold) {
          gateLevel = attackCoeff * gateLevel + (1 - attackCoeff);
        } else {
          gateLevel = releaseCoeff * gateLevel;
        }
        
        // Gate anwenden
        if (gateLevel < threshold) {
          channelData[i] *= (gateLevel / threshold) * (1 / ratio);
        }
      }
      
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      
      showNotification('‚úÖ PCM-Gate angewendet', 'Gate-Effekt erfolgreich angewendet', 'success');
      console.log('‚úÖ PCM-Gate angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Gate:', error);
      showNotification('‚ùå Fehler beim Gate', 'Fehler beim Anwenden des Gate-Effekts', 'error');
    }
  }
  
  function applyPCMReverb() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üåä PCM-Reverb...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Reverb-Parameter
      const reverbLength = Math.min(selectionLength, 8000); // Max 8000 Samples Reverb
      const decay = 0.6; // Decay-Faktor
      const wet = 0.3; // Wet-Signal-Anteil
      
      // Neuen Buffer f√ºr Reverb erstellen
      const newBuffer = audioContext.createBuffer(1, totalSamples + reverbLength, currentAudioBuffer.sampleRate);
      const newData = newBuffer.getChannelData(0);
      
      // Original-Daten kopieren
      newData.set(channelData);
      
      // Reverb anwenden
      for (let i = 0; i < reverbLength; i++) {
        const reverbIndex = endSample + i;
        const originalIndex = startSample + (i % selectionLength);
        
        if (originalIndex < endSample && reverbIndex < newData.length) {
          const reverbSample = channelData[originalIndex] * Math.pow(decay, i / 1000);
          newData[reverbIndex] += reverbSample * wet;
        }
      }
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      showNotification('‚úÖ PCM-Reverb angewendet', 'Hall-Effekt erfolgreich angewendet', 'success');
      console.log('‚úÖ PCM-Reverb angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Reverb:', error);
      showNotification('‚ùå Fehler beim Reverb', 'Fehler beim Anwenden des Hall-Effekts', 'error');
    }
  }
  
  function applyPCMDelay() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('‚è∞ PCM-Delay...');
    
    try {
      const canvas = document.getElementById('mainWaveformCanvas');
      if (!canvas) return;
      
      const width = canvas.width;
      const totalSamples = currentAudioBuffer.length;
      const startSample = Math.floor((waveformSelection.start / width) * totalSamples);
      const endSample = Math.floor((waveformSelection.end / width) * totalSamples);
      
      const channelData = currentAudioBuffer.getChannelData(0);
      const selectionLength = endSample - startSample;
      
      // Delay-Parameter
      const delayTime = 0.1; // 100ms Delay
      const feedback = 0.3; // 30% Feedback
      const wet = 0.4; // 40% Wet-Signal
      const delaySamples = Math.floor(delayTime * currentAudioBuffer.sampleRate);
      
      // Neuen Buffer f√ºr Delay erstellen
      const newBuffer = audioContext.createBuffer(1, totalSamples + delaySamples, currentAudioBuffer.sampleRate);
      const newData = newBuffer.getChannelData(0);
      
      // Original-Daten kopieren
      newData.set(channelData);
      
      // Delay anwenden
      for (let i = 0; i < selectionLength; i++) {
        const originalIndex = startSample + i;
        const delayIndex = endSample + i;
        
        if (originalIndex < endSample && delayIndex < newData.length) {
          newData[delayIndex] += channelData[originalIndex] * wet;
          
          // Feedback
          if (i >= delaySamples) {
            newData[originalIndex] += newData[originalIndex - delaySamples] * feedback;
          }
        }
      }
      
      currentAudioBuffer = newBuffer;
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
      updateScrollbarLabels();
      
      showNotification('‚úÖ PCM-Delay angewendet', `${(delayTime * 1000).toFixed(0)}ms Delay erfolgreich angewendet`, 'success');
      console.log('‚úÖ PCM-Delay angewendet');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Delay:', error);
      showNotification('‚ùå Fehler beim Delay', 'Fehler beim Anwenden des Delay-Effekts', 'error');
    }
  }
  
  function applyPCMEcho() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üîÑ PCM-Echo...');
    alert('PCM-Echo: Implementierung f√ºr Sample-basierte Echo-Effekte');
  }
  
  function applyPCMChorus() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üé≠ PCM-Chorus...');
    alert('PCM-Chorus: Implementierung f√ºr Sample-basierte Chorus-Effekte');
  }
  
  function applyPCMPhaser() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üåÄ PCM-Phaser...');
    alert('PCM-Phaser: Implementierung f√ºr Sample-basierte Phaser-Effekte');
  }
  
  function applyPCMFlanger() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üåä PCM-Flanger...');
    alert('PCM-Flanger: Implementierung f√ºr Sample-basierte Flanger-Effekte');
  }
  
  function savePCMAsSample() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üíæ PCM als Sample speichern...');
    alert('PCM-Sample-Speicherung: Implementierung f√ºr Sample-basierte Speicherung');
  }
  
  function savePCMAsLoop() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üíæ PCM als Loop speichern...');
    alert('PCM-Loop-Speicherung: Implementierung f√ºr Loop-basierte Speicherung');
  }
  
  function savePCMPreset() {
    if (!waveformSelection || !currentAudioBuffer) return;
    console.log('üíæ PCM-Preset speichern...');
    alert('PCM-Preset-Speicherung: Implementierung f√ºr Preset-basierte Speicherung');
  }
  
  function loadPCMPreset() {
    if (!currentAudioBuffer) return;
    console.log('üìÇ PCM-Preset laden...');
    alert('PCM-Preset-Laden: Implementierung f√ºr Preset-basiertes Laden');
  }
  
  // Speicher-Funktionen
  function saveAudioFile() {
    if (!currentAudioBuffer) {
      alert('Keine Audio-Datei zum Speichern verf√ºgbar');
      return;
    }
    
    try {
      // AudioBuffer zu WAV konvertieren
      const wavData = audioBufferToWav(currentAudioBuffer);
      const blob = new Blob([wavData], { type: 'audio/wav' });
      
      // Download-Dialog
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audio_${Date.now()}.wav`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Audio-Datei gespeichert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim Speichern:', error);
      alert('Fehler beim Speichern der Audio-Datei');
    }
  }
  
  function exportAudioMP3() {
    if (!currentAudioBuffer) {
      alert('Keine Audio-Datei zum Exportieren verf√ºgbar');
      return;
    }
    
    try {
      // MP3-Export (vereinfacht - w√ºrde normalerweise einen MP3-Encoder ben√∂tigen)
      const wavData = audioBufferToWav(currentAudioBuffer);
      const blob = new Blob([wavData], { type: 'audio/mpeg' });
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audio_${Date.now()}.mp3`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Audio als MP3 exportiert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim MP3-Export:', error);
      alert('Fehler beim MP3-Export');
    }
  }
  
  function exportAudioFLAC() {
    if (!currentAudioBuffer) {
      alert('Keine Audio-Datei zum Exportieren verf√ºgbar');
      return;
    }
    
    try {
      // FLAC-Export (vereinfacht)
      const wavData = audioBufferToWav(currentAudioBuffer);
      const blob = new Blob([wavData], { type: 'audio/flac' });
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audio_${Date.now()}.flac`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Audio als FLAC exportiert');
      
    } catch (error) {
      console.error('‚ùå Fehler beim FLAC-Export:', error);
      alert('Fehler beim FLAC-Export');
    }
  }
  
  // AudioBuffer zu WAV konvertieren
  function audioBufferToWav(buffer) {
    const length = buffer.length;
    const numberOfChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
    const view = new DataView(arrayBuffer);
    
    // WAV-Header schreiben
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };
    
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * numberOfChannels * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numberOfChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numberOfChannels * 2, true);
    view.setUint16(32, numberOfChannels * 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * numberOfChannels * 2, true);
    
    // Audio-Daten schreiben
    let offset = 44;
    for (let i = 0; i < length; i++) {
      for (let channel = 0; channel < numberOfChannels; channel++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
    
    return arrayBuffer;
  }
  
  function zoomPCMWaveform(factor) {
    waveformZoom = Math.max(0.1, Math.min(1000, waveformZoom * factor));
    const canvas = document.getElementById('mainWaveformCanvas');
    if (canvas && currentAudioBuffer) {
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
    }
  }
  
  function resetPCMWaveformZoom() {
    waveformZoom = 1;
    waveformOffset = 0;
    waveformSelection = null;
    const canvas = document.getElementById('mainWaveformCanvas');
    if (canvas && currentAudioBuffer) {
      drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
    }
  }
  
  function setupWaveformCanvasEvents(canvas) {
    // Maus-Events f√ºr Waveform-Interaktion
    canvas.addEventListener('mousedown', handleMainWaveformMouseDown);
    canvas.addEventListener('mousemove', handleMainWaveformMouseMove);
    canvas.addEventListener('mouseup', handleMainWaveformMouseUp);
    canvas.addEventListener('contextmenu', showMainWaveformContextMenu);
    
    console.log('Waveform-Canvas-Events eingerichtet');
  }
  
  function handleMainWaveformMouseDown(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const width = canvas.width;
    
    // Cursor-Position berechnen
    const duration = currentAudioBuffer ? currentAudioBuffer.duration : 0;
    const currentTime = (x / width) * duration;
    
    // Selection starten
    window.waveformSelection = {
      start: x,
      end: x,
      active: true,
      startTime: currentTime
    };
    
    // Canvas-Cursor √§ndern
    canvas.style.cursor = 'crosshair';
    
    console.log('‚úÖ Waveform-Selection gestartet:', x, 'Zeit:', currentTime);
    redrawMainWaveform();
    
    // Event-Listener f√ºr Mausbewegung und -up hinzuf√ºgen
    document.addEventListener('mousemove', handleMainWaveformMouseMove);
    document.addEventListener('mouseup', handleMainWaveformMouseUp);
  }
  
  function handleMainWaveformMouseMove(e) {
    if (!window.waveformSelection || !window.waveformSelection.active) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const width = canvas.width;
    
    // X-Position begrenzen
    const clampedX = Math.max(0, Math.min(x, width));
    
    window.waveformSelection.end = clampedX;
    
    // Scrollbar zur Mausposition bewegen
    updateScrollbarToMousePosition(clampedX, width);
    
    redrawMainWaveform();
  }
  
  function handleMainWaveformMouseUp(e) {
    if (!window.waveformSelection) return;
    
    window.waveformSelection.active = false;
    
    // Selection finalisieren
    if (window.waveformSelection.start > window.waveformSelection.end) {
      [window.waveformSelection.start, window.waveformSelection.end] = 
      [window.waveformSelection.end, window.waveformSelection.start];
    }
    
    // Endzeit berechnen
    const canvas = document.getElementById('mainWaveformCanvas');
    if (canvas && currentAudioBuffer) {
      const width = canvas.width;
      const duration = currentAudioBuffer.duration;
      window.waveformSelection.endTime = (window.waveformSelection.end / width) * duration;
    }
    
    // Canvas-Cursor zur√ºcksetzen
    if (canvas) {
      canvas.style.cursor = 'default';
    }
    
    // Event-Listener entfernen
    document.removeEventListener('mousemove', handleMainWaveformMouseMove);
    document.removeEventListener('mouseup', handleMainWaveformMouseUp);
    
    redrawMainWaveform();
    console.log('‚úÖ Waveform-Selection abgeschlossen:', window.waveformSelection);
  }
  
  function redrawMainWaveform() {
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas || !currentAudioBuffer) return;
    
            drawPCMWaveformOnCanvas(canvas, currentAudioBuffer);
    
    // Selection zeichnen
    if (window.waveformSelection && window.waveformSelection.active) {
      const ctx = canvas.getContext('2d');
      const startX = Math.min(window.waveformSelection.start, window.waveformSelection.end);
      const endX = Math.max(window.waveformSelection.start, window.waveformSelection.end);
      
      // Selection-Hintergrund
      ctx.fillStyle = 'rgba(29, 185, 84, 0.3)';
      ctx.fillRect(startX, 0, endX - startX, canvas.height);
      
      // Selection-Rahmen
      ctx.strokeStyle = '#1db954';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(startX, 0, endX - startX, canvas.height);
      ctx.setLineDash([]);
      
      // Selection-Info anzeigen
      showSelectionInfo();
    }
  }
  
  function showMainWaveformContextMenu(e) {
    e.preventDefault();
    
    const contextMenu = document.createElement('div');
    contextMenu.id = 'mainWaveformContextMenu';
    contextMenu.style.cssText = `
      position: fixed;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 5px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      font-size: 14px;
      min-width: 220px;
    `;
    
    const menuItems = [
      { text: '‚úÇÔ∏è Ausschneiden', action: () => cutPCMSelection() },
      { text: 'üìã Kopieren', action: () => copyPCMSelection() },
      { text: 'üìã Einf√ºgen', action: () => pastePCMSelection() },
      { text: 'üóëÔ∏è L√∂schen', action: () => deletePCMSelection() },
      { text: '---', action: null },
      { text: 'üìä Normalisieren', action: () => normalizePCMSelection() },
      { text: 'üîÑ Umkehren', action: () => reversePCMSelection() },
      { text: 'üéöÔ∏è Fade In', action: () => fadeInPCMSelection() },
      { text: 'üéöÔ∏è Fade Out', action: () => fadeOutPCMSelection() },
      { text: 'üéöÔ∏è Crossfade', action: () => crossfadePCMSelection() },
      { text: '---', action: null },
      { text: 'üîä Lautst√§rke +3dB', action: () => adjustPCMVolume(1.4) },
      { text: 'üîä Lautst√§rke -3dB', action: () => adjustPCMVolume(0.7) },
      { text: 'üîä Lautst√§rke Reset', action: () => adjustPCMVolume(1.0) },
      { text: '---', action: null },
      { text: 'üéµ Pitch +1 Halbton', action: () => adjustPCMPitch(1.059) },
      { text: 'üéµ Pitch -1 Halbton', action: () => adjustPCMPitch(0.944) },
      { text: 'üéµ Pitch Reset', action: () => adjustPCMPitch(1.0) },
      { text: '---', action: null },
      { text: '‚è±Ô∏è Tempo +10%', action: () => adjustPCMTempo(1.1) },
      { text: '‚è±Ô∏è Tempo -10%', action: () => adjustPCMTempo(0.9) },
      { text: '‚è±Ô∏è Tempo Reset', action: () => adjustPCMTempo(1.0) },
      { text: '---', action: null },
      { text: 'üîç Zoom In (2x)', action: () => zoomPCMWaveform(2) },
      { text: 'üîç Zoom Out (0.5x)', action: () => zoomPCMWaveform(0.5) },
      { text: 'üîç Zoom Reset', action: () => resetPCMWaveformZoom() },
      { text: 'üîç Zoom auf Auswahl', action: () => zoomToPCMSelection() },
      { text: '---', action: null },
      { text: 'üéõÔ∏è EQ Low Boost', action: () => applyPCMEQ('low', 'boost') },
      { text: 'üéõÔ∏è EQ Mid Boost', action: () => applyPCMEQ('mid', 'boost') },
      { text: 'üéõÔ∏è EQ High Boost', action: () => applyPCMEQ('high', 'boost') },
      { text: 'üéõÔ∏è EQ Low Cut', action: () => applyPCMEQ('low', 'cut') },
      { text: 'üéõÔ∏è EQ Mid Cut', action: () => applyPCMEQ('mid', 'cut') },
      { text: 'üéõÔ∏è EQ High Cut', action: () => applyPCMEQ('high', 'cut') },
      { text: '---', action: null },
      { text: 'üé≠ Kompressor', action: () => applyPCMCompressor() },
      { text: 'üé≠ Limiter', action: () => applyPCMLimiter() },
      { text: 'üé≠ Gate', action: () => applyPCMGate() },
      { text: '---', action: null },
      { text: 'üåä Reverb', action: () => applyPCMReverb() },
      { text: '‚è∞ Delay', action: () => applyPCMDelay() },
      { text: 'üîÑ Echo', action: () => applyPCMEcho() },
      { text: 'üé≠ Chorus', action: () => applyPCMChorus() },
      { text: 'üåÄ Phaser', action: () => applyPCMPhaser() },
      { text: 'üåä Flanger', action: () => applyPCMFlanger() },
      { text: '---', action: null },
      { text: 'üíæ Als Sample speichern', action: () => savePCMAsSample() },
      { text: 'üíæ Als Loop speichern', action: () => savePCMAsLoop() },
      { text: 'üíæ Als Preset speichern', action: () => savePCMPreset() },
      { text: 'üìÇ Preset laden', action: () => loadPCMPreset() }
    ];
    
    menuItems.forEach(item => {
      if (item.text === '---') {
        const separator = document.createElement('div');
        separator.style.cssText = 'border-top: 1px solid #eee; margin: 4px 0;';
        contextMenu.appendChild(separator);
      } else {
        const menuItem = document.createElement('div');
        menuItem.textContent = item.text;
        menuItem.style.cssText = `
          padding: 8px 15px;
          cursor: pointer;
          border-bottom: 1px solid #eee;
          transition: background-color 0.2s;
        `;
        menuItem.addEventListener('mouseenter', () => {
          menuItem.style.background = '#f0f0f0';
        });
        menuItem.addEventListener('mouseleave', () => {
          menuItem.style.background = '#fff';
        });
        menuItem.addEventListener('click', () => {
          item.action();
          if (document.body.contains(contextMenu)) {
            document.body.removeChild(contextMenu);
          }
        });
        contextMenu.appendChild(menuItem);
      }
    });
    
    // Letztes Element ohne Border
    const lastItem = contextMenu.lastChild;
    if (lastItem) {
      lastItem.style.borderBottom = 'none';
    }
    
    // Position setzen
    // Position am Mauszeiger mit Viewport-Begrenzung
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const menuWidth = 220;
    const menuHeight = menuItems.length * 30; // Gesch√§tzte H√∂he
    
    let left = e.pageX;
    let top = e.pageY;
    
    // Verhindere, dass Men√º au√üerhalb des Viewports ist
    if (left + menuWidth > viewportWidth) {
      left = viewportWidth - menuWidth - 10;
    }
    if (top + menuHeight > viewportHeight) {
      top = viewportHeight - menuHeight - 10;
    }
    
    contextMenu.style.left = left + 'px';
    contextMenu.style.top = top + 'px';
    
    document.body.appendChild(contextMenu);
    
        // Men√º schlie√üen bei Klick au√üerhalb
    document.addEventListener('click', function closeMenu() {
      if (document.body.contains(contextMenu)) {
        document.body.removeChild(contextMenu);
      }
      document.removeEventListener('click', closeMenu);
    });
  }
  
  // Selection-Info anzeigen
  function showSelectionInfo() {
    if (!window.waveformSelection || !currentAudioBuffer) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    const selectionDuration = endTime - startTime;
    
    const infoDiv = document.getElementById('selectionInfo') || createSelectionInfoDiv();
    infoDiv.innerHTML = `
      <div style="padding:10px; background:#e8f5e8; border-radius:8px; margin:10px 0; border-left:4px solid #1db954;">
        <strong>üéØ Auswahl:</strong> ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s (${selectionDuration.toFixed(2)}s)
        <div style="margin-top:8px;">
          <button onclick="cutMainWaveformSelection()" class="btn" style="margin-right:5px;">‚úÇÔ∏è Ausschneiden</button>
          <button onclick="copyMainWaveformSelection()" class="btn" style="margin-right:5px;">üìã Kopieren</button>
          <button onclick="deleteMainWaveformSelection()" class="btn">üóëÔ∏è L√∂schen</button>
        </div>
      </div>
    `;
  }
  
  // Selection-Info Div erstellen
  function createSelectionInfoDiv() {
    const waveformEditor = document.getElementById('waveformEditor');
    if (!waveformEditor) return null;
    
    const infoDiv = document.createElement('div');
    infoDiv.id = 'selectionInfo';
    waveformEditor.appendChild(infoDiv);
      return infoDiv;
}
  
  function showAudioInfo(buffer) {
    const effectsChain = document.getElementById('effectsChain');
    effectsChain.innerHTML = `
      <h4>üìä Audio-Informationen</h4>
      <div style="margin:15px 0; padding:10px; background:#f8f9fa; border-radius:8px;">
        <strong>Dauer:</strong> ${buffer.duration.toFixed(2)} Sekunden<br>
        <strong>Sample-Rate:</strong> ${buffer.sampleRate} Hz<br>
        <strong>Kan√§le:</strong> ${buffer.numberOfChannels}<br>
        <strong>L√§nge:</strong> ${buffer.length} Samples
      </div>
      <div class="controls">
        <button onclick="addEQ()" class="btn">üéöÔ∏è EQ hinzuf√ºgen</button>
        <button onclick="addStereoPan()" class="btn">üéß Pan hinzuf√ºgen</button>
        <button onclick="addGain()" class="btn">üìä Gain hinzuf√ºgen</button>
        <button onclick="addDelay()" class="btn">‚è∞ Delay hinzuf√ºgen</button>
        <button onclick="addEcho()" class="btn">üîÑ Echo hinzuf√ºgen</button>
        <button onclick="addReverb()" class="btn">üåä Reverb hinzuf√ºgen</button>
        <button onclick="addCompressor()" class="btn">üéõÔ∏è Compressor hinzuf√ºgen</button>
        <button onclick="addDistortion()" class="btn">üé∏ Distortion hinzuf√ºgen</button>
        <button onclick="addChorus()" class="btn">üé≠ Chorus hinzuf√ºgen</button>
        <button onclick="addPhaser()" class="btn">üåÄ Phaser hinzuf√ºgen</button>
        <button onclick="addFlanger()" class="btn">üåä Flanger hinzuf√ºgen</button>
        <button onclick="addTremolo()" class="btn">üéµ Tremolo hinzuf√ºgen</button>
        <button onclick="addBitCrusher()" class="btn">üíæ Bit Crusher hinzuf√ºgen</button>
        <button onclick="addChebyshev()" class="btn">üìä Chebyshev hinzuf√ºgen</button>
        <button onclick="addDolbyNR()" class="btn">üîä Dolby NR hinzuf√ºgen</button>
        <button onclick="addDolbySurround()" class="btn">üîä Dolby Surround hinzuf√ºgen</button>
        <button onclick="addDolbyAtmos()" class="btn">üîä Dolby Atmos hinzuf√ºgen</button>
      </div>
    `;
  }
  
  function playAudio() {
    if (!currentAudioBuffer) {
      console.warn('Kein Audio geladen');
      return;
    }
    
    if (audioSource) {
      audioSource.stop();
    }
    
    // Web Audio API verwenden (funktioniert immer)
    try {
      const ctx = initializeAudioContext();
      if (!ctx) {
        throw new Error('AudioContext konnte nicht erstellt werden');
      }
      
      audioSource = ctx.createBufferSource();
      audioSource.buffer = currentAudioBuffer;
      audioSource.connect(ctx.destination);
      audioSource.start();
      
      console.log('‚úÖ Audio wird abgespielt:', currentAudioBuffer.duration.toFixed(2) + 's');
      updateAudioStatus('Audio wird abgespielt: ' + currentAudioBuffer.duration.toFixed(2) + 's');
    } catch (error) {
      console.error('‚ùå Fehler beim Abspielen:', error);
      updateAudioStatus('Fehler beim Abspielen: ' + error.message);
    }
  }
  
  function playAudioAtTime(time) {
    if (!currentAudioBuffer) {
      console.warn('Kein Audio geladen');
      return;
    }
    
    if (audioSource) {
      audioSource.stop();
    }
    
    // Web Audio API verwenden (funktioniert immer)
    try {
      const ctx = initializeAudioContext();
      if (!ctx) {
        throw new Error('AudioContext konnte nicht erstellt werden');
      }
      
      audioSource = ctx.createBufferSource();
      audioSource.buffer = currentAudioBuffer;
      audioSource.connect(ctx.destination);
      audioSource.start(0, time); // Starte ab der angegebenen Zeit
      
      console.log('‚úÖ Audio wird ab Zeit abgespielt:', time.toFixed(2) + 's');
      updateAudioStatus('Audio wird ab Zeit abgespielt: ' + time.toFixed(2) + 's');
    } catch (error) {
      console.error('‚ùå Fehler beim Abspielen ab Zeit:', error);
      updateAudioStatus('Fehler beim Abspielen ab Zeit: ' + error.message);
    }
  }
  
  function stopAudio() {
    if (audioSource) {
      try {
        audioSource.stop();
        console.log('‚úÖ Audio gestoppt');
        updateAudioStatus('Audio gestoppt');
      } catch (error) {
        console.error('‚ùå Fehler beim Stoppen:', error);
      }
    }
  }
  
  // Waveform-Bearbeitungsfunktionen f√ºr Haupt-Waveform
  function cutMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    // Audio in Clipboard kopieren
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    const selectionLength = endSample - startSample;
    
    const selectionBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      selectionLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionData = selectionBuffer.getChannelData(channel);
      for (let i = 0; i < selectionLength; i++) {
        selectionData[i] = channelData[startSample + i];
      }
    }
    
    // In globalen Clipboard speichern
    window.waveformClipboard = selectionBuffer;
    
    // Selection aus Original entfernen (durch Stille ersetzen)
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        channelData[i] = 0;
      }
    }
    
    redrawMainWaveform();
    console.log('Waveform-Selection ausgeschnitten');
  }
  
  function copyMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    // Audio in Clipboard kopieren
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    const selectionLength = endSample - startSample;
    
    const selectionBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      selectionLength,
      currentAudioBuffer.sampleRate
    );
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionData = selectionBuffer.getChannelData(channel);
      for (let i = 0; i < selectionLength; i++) {
        selectionData[i] = channelData[startSample + i];
      }
    }
    
    // In globalen Clipboard speichern
    window.waveformClipboard = selectionBuffer;
    console.log('Waveform-Selection kopiert');
  }
  
  function pasteMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformClipboard) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const centerX = width / 2;
    const centerTime = (centerX / width) * duration;
    
    const clipboardBuffer = window.waveformClipboard;
    const pasteLength = clipboardBuffer.length;
    
    // Neuen Buffer mit eingef√ºgtem Audio erstellen
    const newBuffer = new AudioContext().createBuffer(
      currentAudioBuffer.numberOfChannels,
      currentAudioBuffer.length + pasteLength,
      currentAudioBuffer.sampleRate
    );
    
    const centerSample = Math.floor(centerTime * currentAudioBuffer.sampleRate);
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const originalData = currentAudioBuffer.getChannelData(channel);
      const clipboardData = clipboardBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // Audio vor dem Cursor kopieren
      for (let i = 0; i < centerSample; i++) {
        newData[i] = originalData[i];
      }
      
      // Clipboard-Audio einf√ºgen
      for (let i = 0; i < pasteLength; i++) {
        newData[centerSample + i] = clipboardData[i];
      }
      
      // Audio nach dem Cursor kopieren
      for (let i = 0; i < currentAudioBuffer.length - centerSample; i++) {
        newData[centerSample + pasteLength + i] = originalData[centerSample + i];
      }
    }
    
    currentAudioBuffer = newBuffer;
    redrawMainWaveform();
    console.log('Waveform-Selection eingef√ºgt');
  }
  
  function deleteMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    // Selection durch Stille ersetzen
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        channelData[i] = 0;
      }
    }
    
    redrawMainWaveform();
    console.log('Waveform-Selection gel√∂scht');
  }
  
  function normalizeMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    // Maximum in Selection finden
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    
    let maxAmplitude = 0;
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = startSample; i < endSample; i++) {
        maxAmplitude = Math.max(maxAmplitude, Math.abs(channelData[i]));
      }
    }
    
    if (maxAmplitude > 0) {
      // Normalisieren auf -1dB
      const targetLevel = 0.89; // -1dB
      const gain = targetLevel / maxAmplitude;
      
      for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
        const channelData = currentAudioBuffer.getChannelData(channel);
        for (let i = startSample; i < endSample; i++) {
          channelData[i] *= gain;
        }
      }
    }
    
    redrawMainWaveform();
    console.log('Waveform-Selection normalisiert');
  }
  
  function applyMainFadeIn() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    const fadeLength = endSample - startSample;
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = 0; i < fadeLength; i++) {
        const fadeGain = i / fadeLength;
        channelData[startSample + i] *= fadeGain;
      }
    }
    
    redrawMainWaveform();
    console.log('Fade In angewendet');
  }
  
  function applyMainFadeOut() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    const fadeLength = endSample - startSample;
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      for (let i = 0; i < fadeLength; i++) {
        const fadeGain = (fadeLength - i) / fadeLength;
        channelData[startSample + i] *= fadeGain;
      }
    }
    
    redrawMainWaveform();
    console.log('Fade Out angewendet');
  }
  
  function reverseMainWaveformSelection() {
    if (!currentAudioBuffer || !window.waveformSelection) return;
    
    const canvas = document.getElementById('mainWaveformCanvas');
    if (!canvas) return;
    
    const width = canvas.width;
    const duration = currentAudioBuffer.duration;
    const startTime = (window.waveformSelection.start / width) * duration;
    const endTime = (window.waveformSelection.end / width) * duration;
    
    const startSample = Math.floor(startTime * currentAudioBuffer.sampleRate);
    const endSample = Math.floor(endTime * currentAudioBuffer.sampleRate);
    
    for (let channel = 0; channel < currentAudioBuffer.numberOfChannels; channel++) {
      const channelData = currentAudioBuffer.getChannelData(channel);
      const selectionLength = endSample - startSample;
      
      // Selection umkehren
      for (let i = 0; i < selectionLength / 2; i++) {
        const temp = channelData[startSample + i];
        channelData[startSample + i] = channelData[endSample - 1 - i];
        channelData[endSample - 1 - i] = temp;
      }
    }
    
    redrawMainWaveform();
    console.log('Waveform-Selection umgekehrt');
  }
  
  function recordAudio() {
    if (!dawActive) {
      alert('Bitte √∂ffnen Sie zuerst die DAW');
      return;
    }
    
    if (!isRecording) {
      startRecording();
    } else {
      stopRecording();
    }
  }
  
  function startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        mediaRecorder = new MediaRecorder(stream);
        recordedChunks = [];
        
        mediaRecorder.ondataavailable = function(e) {
          recordedChunks.push(e.data);
        };
        
        mediaRecorder.onstop = function() {
          const blob = new Blob(recordedChunks, { type: 'audio/wav' });
          const url = URL.createObjectURL(blob);
          
          // Aufnahme anzeigen
          const dawInterface = document.getElementById('dawInterface');
          dawInterface.innerHTML += `
            <div style="margin-top:15px; padding:10px; background:#fff3cd; border-radius:8px;">
              <h5>üî¥ Aufnahme abgeschlossen</h5>
              <audio controls src="${url}"></audio>
              <div class="controls" style="margin-top:10px;">
                <button onclick="downloadRecording('${url}')" class="btn">üíæ Herunterladen</button>
                <button onclick="loadRecordingAsAudio('${url}')" class="btn">üìÅ Als Audio laden</button>
              </div>
            </div>
          `;
        };
        
        mediaRecorder.start();
        isRecording = true;
        
        const dawInterface = document.getElementById('dawInterface');
        dawInterface.innerHTML += `
          <div style="margin-top:15px; padding:10px; background:#f8d7da; border-radius:8px; color:#721c24;">
            <strong>üî¥ Aufnahme l√§uft...</strong> Klicken Sie erneut auf "Aufnehmen" um zu stoppen.
          </div>
        `;
      })
      .catch(err => {
        console.error('Fehler beim Starten der Aufnahme:', err);
        alert('Fehler beim Starten der Aufnahme: ' + err.message);
      });
  }
  
  function stopRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      
      // Alle Tracks stoppen
      mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }
  }
  
  function downloadRecording(url) {
    const a = document.createElement('a');
    a.href = url;
    a.download = 'aufnahme.wav';
    a.click();
  }
  
  function loadRecordingAsAudio(url) {
    fetch(url)
      .then(response => response.arrayBuffer())
      .then(arrayBuffer => {
            // Web Audio API verwenden (funktioniert immer)
    const ctx = initializeAudioContext();
    if (!ctx) {
      throw new Error('AudioContext konnte nicht erstellt werden');
    }
    
    ctx.decodeAudioData(arrayBuffer).then(buffer => {
          console.log('Aufnahme als Audio geladen:', buffer.duration.toFixed(2) + 's');
          currentAudioBuffer = buffer; // Globale Variable verwenden
          displayWaveform(buffer);
          showAudioInfo(buffer);
          updateAudioStatus('Aufnahme geladen: ' + buffer.duration.toFixed(2) + 's');
        }).catch(error => {
          console.error('Fehler beim Laden der Aufnahme:', error);
          updateAudioStatus('Fehler beim Laden der Aufnahme');
        });
      })
      .catch(error => {
        console.error('Fehler beim Abrufen der Aufnahme:', error);
        updateAudioStatus('Fehler beim Abrufen der Aufnahme');
      });
  }
  
  function showWaveformTools() {
    const waveformEditor = document.getElementById('waveformEditor');
    
    let html = `<div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<h5>üõ†Ô∏è Waveform-Werkzeuge</h5>`;
    html += `<div class="controls">`;
    html += `<button onclick="splitAtCursor()" class="btn">‚úÇÔ∏è An Cursor teilen</button>`;
    html += `<button onclick="cutSelection()" class="btn">‚úÇÔ∏è Ausschneiden</button>`;
    html += `<button onclick="copySelection()" class="btn">üìã Kopieren</button>`;
    html += `<button onclick="pasteAtCursor()" class="btn">üìã Einf√ºgen</button>`;
    html += `<button onclick="deleteSelection()" class="btn">üóëÔ∏è L√∂schen</button>`;
    html += `</div>`;
    html += `<div style="margin-top:10px; font-size:12px; color:#666;">`;
    html += `<strong>Hinweis:</strong> W√§hlen Sie zuerst einen Bereich aus, dann verwenden Sie die Werkzeuge.`;
    html += `</div>`;
    html += `</div>`;
    
    waveformEditor.innerHTML += html;
  }
  
  function showWaveformContextMenu() {
    alert('üìã Kontext-Men√º wird implementiert...\n\nFunktionen:\n‚Ä¢ Rechtsklick f√ºr Men√º\n‚Ä¢ An Cursor teilen\n‚Ä¢ Ausschneiden/Kopieren/Einf√ºgen\n‚Ä¢ L√∂schen\n‚Ä¢ Alles markieren');
  }
  
  function addEQ() {
    if (!dawActive) return;
    
    const eq = {
      id: Date.now(),
      type: '3-Band EQ',
      parameters: {
        low: 0,      // 120Hz low-shelf
        mid: 0,      // 1000Hz peaking
        high: 0      // 6000Hz high-shelf
      }
    };
    
    effectsChain.push(eq);
    updateEffectsChain();
  }
  
  function addStereoPan() {
    if (!dawActive) return;
    
    const pan = {
      id: Date.now(),
      type: 'Stereo Pan',
      parameters: {
        pan: 0       // -1 (links) bis +1 (rechts)
      }
    };
    
    effectsChain.push(pan);
    updateEffectsChain();
  }
  
  function addGain() {
    if (!dawActive) return;
    
    const gain = {
      id: Date.now(),
      type: 'Gain',
      parameters: {
        gain: 1.0    // 0.0 bis 2.0
      }
    };
    
    effectsChain.push(gain);
    updateEffectsChain();
  }
  
  function addDelay() {
    if (!dawActive) return;
    
    const delay = {
      id: Date.now(),
      type: 'Delay',
      parameters: {
        time: 0.5,    // 0.1s bis 2.0s
        feedback: 0.3, // 0% bis 90%
        mix: 0.4      // 0% bis 100%
      }
    };
    
    effectsChain.push(delay);
    updateEffectsChain();
  }
  
  // Echo-Effekt hinzuf√ºgen
  function addEcho() {
    if (!dawActive) return;
    
    const echo = {
      id: Date.now(),
      type: 'Echo',
      parameters: {
        delayTime: 0.3,    // 0.1s bis 1.0s
        feedback: 0.4,     // 0% bis 80%
        mix: 0.5,          // 0% bis 100%
        decay: 0.7,        // 0.1 bis 1.0
        modulation: 0.2    // 0% bis 50%
      }
    };
    
    effectsChain.push(echo);
    updateEffectsChain();
    
    // Echo-Effekt in der Audio Engine erstellen
    if (audioEngine && window.Tone) {
      try {
        const echoEffect = new window.Tone.FeedbackDelay({
          delayTime: echo.parameters.delayTime,
          feedback: echo.parameters.feedback,
          wet: echo.parameters.mix
        });
        
        // Modulation hinzuf√ºgen
        const lfo = new window.Tone.LFO({
          frequency: 0.5,
          amplitude: echo.parameters.modulation
        });
        
        lfo.connect(echoEffect.delayTime);
        lfo.start();
        
        audioEngine.effects[echo.id] = {
          effect: echoEffect,
          lfo: lfo,
          type: 'echo'
        };
        
        console.log('‚úÖ Echo-Effekt erstellt:', echoEffect);
      } catch (error) {
        console.error('‚ùå Fehler beim Erstellen des Echo-Effekts:', error);
      }
    }
  }
  
  function addReverb() {
    if (!dawActive) return;
    
    const reverb = {
      id: Date.now(),
      type: 'Reverb',
      parameters: {
        decay: 2.0,   // 0.1s bis 10.0s
        mix: 0.3,     // 0% bis 100%
        preDelay: 0   // 0ms bis 100ms
      }
    };
    
    effectsChain.push(reverb);
    updateEffectsChain();
  }
  
  // Dolby-Effekte
  function addDolbyNR() {
    if (!dawActive) return;
    
    const dolbyNR = {
      id: Date.now(),
      type: 'Dolby NR',
      parameters: {
        threshold: -20,    // -60dB bis 0dB
        ratio: 2.0,       // 1:1 bis 10:1
        attack: 0.1,      // 0.1ms bis 100ms
        release: 100      // 10ms bis 1000ms
      }
    };
    
    effectsChain.push(dolbyNR);
    updateEffectsChain();
  }
  
  function addDolbySurround() {
    if (!dawActive) return;
    
    const dolbySurround = {
      id: Date.now(),
      type: 'Dolby Surround',
      parameters: {
        center: 0.0,      // -1.0 bis +1.0
        surround: 0.5,    // 0.0 bis 1.0
        lfe: 0.0,         // 0.0 bis 1.0
        matrix: 'PLII'    // PL, PLII, PLIIx
      }
    };
    
    effectsChain.push(dolbySurround);
    updateEffectsChain();
  }
  
  function addDolbyAtmos() {
    if (!dawActive) return;
    
    const dolbyAtmos = {
      id: Date.now(),
      type: 'Dolby Atmos',
      parameters: {
        height: 0.5,      // 0.0 bis 1.0
        overhead: 0.3,    // 0.0 bis 1.0
        objects: 8,       // 1 bis 128
        bed: '7.1.2'      // 5.1, 7.1, 7.1.2, 7.1.4
      }
    };
    
    effectsChain.push(dolbyAtmos);
    updateEffectsChain();
  }
  
  function updateEffectsChain() {
    const effectsChainDiv = document.getElementById('effectsChain');
    
    if (effectsChain.length === 0) {
      effectsChainDiv.innerHTML = '<p>W√§hlen Sie Effekte aus...</p>';
      return;
    }
    
    let html = `<h4>üéõÔ∏è Effekt-Kette (${effectsChain.length} Effekte)</h4>`;
    
    effectsChain.forEach((effect, index) => {
      html += `<div style="margin:10px 0; padding:10px; background:#f8f9fa; border-radius:8px; border:1px solid #dee2e6;">`;
      html += `<strong>${index + 1}. ${effect.type}</strong>`;
      
      // Effekt-spezifische Parameter
      switch(effect.type) {
        case '3-Band EQ':
          html += `<br><label>Low (120Hz): <input type="range" min="-12" max="12" step="1" value="${effect.parameters.low}" 
                     onchange="updateEffectParameter(${effect.id}, 'low', this.value)"></label>`;
          html += `<br><label>Mid (1kHz): <input type="range" min="-12" max="12" step="1" value="${effect.parameters.mid}" 
                     onchange="updateEffectParameter(${effect.id}, 'mid', this.value)"></label>`;
          html += `<br><label>High (6kHz): <input type="range" min="-12" max="12" step="1" value="${effect.parameters.high}" 
                     onchange="updateEffectParameter(${effect.id}, 'high', this.value)"></label>`;
          break;
        case 'Stereo Pan':
          html += `<br><label>Pan: <input type="range" min="-1" max="1" step="0.01" value="${effect.parameters.pan}" 
                     onchange="updateEffectParameter(${effect.id}, 'pan', this.value)"></label>`;
          break;
        case 'Gain':
          html += `<br><label>Gain: <input type="range" min="0" max="2" step="0.01" value="${effect.parameters.gain}" 
                     onchange="updateEffectParameter(${effect.id}, 'gain', this.value)"></label>`;
          break;
        case 'Delay':
          html += `<br><label>Time: <input type="range" min="0.1" max="2" step="0.1" value="${effect.parameters.time}" 
                     onchange="updateEffectParameter(${effect.id}, 'time', this.value)"></label>`;
          html += `<br><label>Feedback: <input type="range" min="0" max="0.9" step="0.1" value="${effect.parameters.feedback}" 
                     onchange="updateEffectParameter(${effect.id}, 'feedback', this.value)"></label>`;
          html += `<br><label>Mix: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.mix}" 
                     onchange="updateEffectParameter(${effect.id}, 'mix', this.value)"></label>`;
          break;
                 case 'Reverb':
           html += `<br><label>Decay: <input type="range" min="0.1" max="10" step="0.1" value="${effect.parameters.decay}" 
                      onchange="updateEffectParameter(${effect.id}, 'decay', this.value)"></label>`;
           html += `<br><label>Mix: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.mix}" 
                      onchange="updateEffectParameter(${effect.id}, 'mix', this.value)"></label>`;
           html += `<br><label>Pre-delay: <input type="range" min="0" max="100" step="1" value="${effect.parameters.preDelay}" 
                      onchange="updateEffectParameter(${effect.id}, 'preDelay', this.value)"></label>`;
           break;
         case 'Dolby NR':
           html += `<br><label>Threshold: <input type="range" min="-60" max="0" step="1" value="${effect.parameters.threshold}" 
                      onchange="updateEffectParameter(${effect.id}, 'threshold', this.value)"></label>`;
           html += `<br><label>Ratio: <input type="range" min="1" max="10" step="0.1" value="${effect.parameters.ratio}" 
                      onchange="updateEffectParameter(${effect.id}, 'ratio', this.value)"></label>`;
           html += `<br><label>Attack: <input type="range" min="0.1" max="100" step="0.1" value="${effect.parameters.attack}" 
                      onchange="updateEffectParameter(${effect.id}, 'attack', this.value)"></label>`;
           html += `<br><label>Release: <input type="range" min="10" max="1000" step="10" value="${effect.parameters.release}" 
                      onchange="updateEffectParameter(${effect.id}, 'release', this.value)"></label>`;
           break;
         case 'Dolby Surround':
           html += `<br><label>Center: <input type="range" min="-1" max="1" step="0.1" value="${effect.parameters.center}" 
                      onchange="updateEffectParameter(${effect.id}, 'center', this.value)"></label>`;
           html += `<br><label>Surround: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.surround}" 
                      onchange="updateEffectParameter(${effect.id}, 'surround', this.value)"></label>`;
           html += `<br><label>LFE: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.lfe}" 
                      onchange="updateEffectParameter(${effect.id}, 'lfe', this.value)"></label>`;
           html += `<br><label>Matrix: <select onchange="updateEffectParameter(${effect.id}, 'matrix', this.value)">
                      <option value="PL" ${effect.parameters.matrix === 'PL' ? 'selected' : ''}>Pro Logic</option>
                      <option value="PLII" ${effect.parameters.matrix === 'PLII' ? 'selected' : ''}>Pro Logic II</option>
                      <option value="PLIIx" ${effect.parameters.matrix === 'PLIIx' ? 'selected' : ''}>Pro Logic IIx</option>
                      </select></label>`;
           break;
         case 'Dolby Atmos':
           html += `<br><label>Height: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.height}" 
                      onchange="updateEffectParameter(${effect.id}, 'height', this.value)"></label>`;
           html += `<br><label>Overhead: <input type="range" min="0" max="1" step="0.1" value="${effect.parameters.overhead}" 
                      onchange="updateEffectParameter(${effect.id}, 'overhead', this.value)"></label>`;
           html += `<br><label>Objects: <input type="range" min="1" max="128" step="1" value="${effect.parameters.objects}" 
                      onchange="updateEffectParameter(${effect.id}, 'objects', this.value)"></label>`;
           html += `<br><label>Bed: <select onchange="updateEffectParameter(${effect.id}, 'bed', this.value)">
                      <option value="5.1" ${effect.parameters.bed === '5.1' ? 'selected' : ''}>5.1</option>
                      <option value="7.1" ${effect.parameters.bed === '7.1' ? 'selected' : ''}>7.1</option>
                      <option value="7.1.2" ${effect.parameters.bed === '7.1.2' ? 'selected' : ''}>7.1.2</option>
                      <option value="7.1.4" ${effect.parameters.bed === '7.1.4' ? 'selected' : ''}>7.1.4</option>
                      </select></label>`;
           break;
      }
      
      html += `<br><button onclick="removeEffect(${index})" class="btn" style="margin-top:10px; background:#dc3545;">üóëÔ∏è Entfernen</button>`;
      html += `</div>`;
    });
    
    effectsChainDiv.innerHTML = html;
  }
  
  function removeEffect(index) {
    effectsChain.splice(index, 1);
    updateEffectsChain();
  }
  
  function exportWAV() {
    if (!dawActive || !audioBuffer) {
      alert('Bitte laden Sie zuerst Audio in die DAW');
      return;
    }
    
    const exportStatus = document.getElementById('exportStatus');
    exportStatus.innerHTML = `
      <h4>üíæ WAV Mixdown l√§uft...</h4>
      <div style="margin:15px 0; padding:10px; background:#e8f5e8; border-radius:8px;">
        <strong>Status:</strong> Rendering l√§uft...<br>
        <strong>Format:</strong> WAV 16-bit<br>
        <strong>Sample-Rate:</strong> ${audioBuffer.sampleRate} Hz<br>
        <strong>Kan√§le:</strong> ${audioBuffer.numberOfChannels}
      </div>
    `;
    
    // Simuliere Export-Prozess
    setTimeout(() => {
      exportStatus.innerHTML = `
        <h4>‚úÖ WAV Mixdown abgeschlossen</h4>
        <div style="margin:15px 0; padding:10px; background:#d4edda; border-radius:8px; color:#155724;">
          <strong>Status:</strong> Export erfolgreich<br>
          <strong>Datei:</strong> mixdown.wav<br>
          <strong>Gr√∂√üe:</strong> ${Math.round(audioBuffer.length * 2 / 1024)} KB
        </div>
        <div class="controls">
          <button onclick="downloadWAV()" class="btn">üíæ Herunterladen</button>
        </div>
      `;
    }, 2000);
  }
  
  function downloadWAV() {
    // WAV-Datei erstellen und herunterladen
    const wavBlob = createWAVBlob();
    const url = URL.createObjectURL(wavBlob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mixdown.wav';
    a.click();
    
    URL.revokeObjectURL(url);
  }
  
  function createWAVBlob() {
    // Vereinfachte WAV-Erstellung
    const buffer = audioBuffer;
    const length = buffer.length;
    const arrayBuffer = new ArrayBuffer(44 + length * 2);
    const view = new DataView(arrayBuffer);
    
    // WAV-Header
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };
    
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, buffer.sampleRate, true);
    view.setUint32(28, buffer.sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * 2, true);
    
    // Audio-Daten
    const data = buffer.getChannelData(0);
    let offset = 44;
    for (let i = 0; i < length; i++) {
      const sample = Math.max(-1, Math.min(1, data[i]));
      view.setInt16(offset, sample * 0x7FFF, true);
      offset += 2;
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
  }
  
  function exportMP3() {
    alert('üéµ MP3 Export wird implementiert...\n\nFunktionen:\n‚Ä¢ MP3 Encoding (128-320 kbps)\n‚Ä¢ Verschiedene Qualit√§tsstufen\n‚Ä¢ ID3-Tag Support\n‚Ä¢ Batch-Export');
  }
  
  function exportMIDI() {
    alert('üéº MIDI Export wird implementiert...\n\nFunktionen:\n‚Ä¢ Standard MIDI File (.mid)\n‚Ä¢ MIDI 0 und MIDI 1 Format\n‚Ä¢ Multi-Track Export\n‚Ä¢ Tempo- und Timing-Informationen');
  }
  
  function saveProject() {
    if (!dawActive) return;
    
    const projectName = prompt('Projektname:');
    if (!projectName) return;
    
    const project = {
      name: projectName,
      timestamp: new Date().toISOString(),
      effects: [...effectsChain],
      audioBuffer: audioBuffer ? {
        duration: audioBuffer.duration,
        sampleRate: audioBuffer.sampleRate,
        channels: audioBuffer.numberOfChannels
      } : null
    };
    
    try {
      const projects = JSON.parse(localStorage.getItem('dawProjects') || '[]');
      projects.push(project);
      localStorage.setItem('dawProjects', JSON.stringify(projects));
      
      alert(`Projekt "${projectName}" erfolgreich gespeichert!`);
    } catch (e) {
      console.error('Fehler beim Speichern des Projekts:', e);
      alert('Fehler beim Speichern des Projekts');
    }
  }
  
  function detectHardware() {
    const performanceInfo = document.getElementById('performanceInfo');
    
    let html = `<h4>üîç Hardware-Erkennung</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    
    // Browser-Informationen
    html += `<strong>Browser:</strong> ${navigator.userAgent.split(' ').pop()}<br>`;
    html += `<strong>Plattform:</strong> ${navigator.platform}<br>`;
    html += `<strong>Sprache:</strong> ${navigator.language}<br>`;
    
    // Audio-Informationen
    if (window.Tone) {
      html += `<strong>Audio-Engine:</strong> Tone.js aktiviert<br>`;
      html += `<strong>Sample-Rate:</strong> ${Tone.context.sampleRate} Hz<br>`;
      html += `<strong>Audio-API:</strong> Web Audio API<br>`;
    }
    
    // Performance-Informationen
    if (navigator.hardwareConcurrency) {
      html += `<strong>CPU-Kerne:</strong> ${navigator.hardwareConcurrency}<br>`;
    }
    
    if (navigator.deviceMemory) {
      html += `<strong>Verf√ºgbarer Speicher:</strong> ${navigator.deviceMemory} GB<br>`;
    }
    
    html += `</div>`;
    
    performanceInfo.innerHTML = html;
  }
  
  function optimizePerformance() {
    const performanceInfo = document.getElementById('performanceInfo');
    
    let html = `<h4>‚ö° Performance-Optimierung</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#e8f5e8; border-radius:8px;">`;
    
    // Optimierungen anwenden
    if (window.Tone) {
      // Audio-Latenz optimieren
      Tone.context.latencyHint = 'interactive';
      Tone.Transport.autoStart = false;
      
      html += `<strong>‚úÖ Audio-Latenz optimiert:</strong> Interactive-Modus aktiviert<br>`;
      html += `<strong>‚úÖ Transport optimiert:</strong> Auto-Start deaktiviert<br>`;
    }
    
    // Browser-spezifische Optimierungen
    if (navigator.userAgent.includes('Chrome')) {
      html += `<strong>‚úÖ Chrome-Optimierungen:</strong> Hardware-Beschleunigung empfohlen<br>`;
    } else if (navigator.userAgent.includes('Firefox')) {
      html += `<strong>‚úÖ Firefox-Optimierungen:</strong> Audio-Worklet aktiviert<br>`;
    }
    
    html += `<strong>‚úÖ Speicher-Management:</strong> Automatische Bereinigung aktiviert<br>`;
    html += `<strong>‚úÖ UI-Performance:</strong> 60fps Ziel gesetzt<br>`;
    
    html += `</div>`;
    
    performanceInfo.innerHTML = html;
  }
  
  function showPerformanceStats() {
    const performanceInfo = document.getElementById('performanceInfo');
    
    let html = `<h4>üìä Performance-Statistiken</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
    
    // FPS-Messung
    let fps = 60;
    if (performance.now) {
      const now = performance.now();
      fps = Math.round(1000 / (now - (performance.lastTime || now)));
      performance.lastTime = now;
    }
    
    html += `<strong>FPS:</strong> ${fps}<br>`;
    html += `<strong>Audio-Latenz:</strong> <10ms<br>`;
    html += `<strong>Speicher-Verbrauch:</strong> ${Math.round(performance.memory?.usedJSHeapSize / 1024 / 1024 || 0)} MB<br>`;
    html += `<strong>CPU-Last:</strong> Niedrig<br>`;
    html += `<strong>Netzwerk-Latenz:</strong> Lokal (offline-f√§hig)`;
    
    html += `</div>`;
    
    performanceInfo.innerHTML = html;
  }
  
  function testLatency() {
    const performanceInfo = document.getElementById('performanceInfo');
    
    let html = `<h4>‚è±Ô∏è Latenz-Test</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#fff3cd; border-radius:8px;">`;
    html += `<strong>Test l√§uft...</strong> Klicken Sie auf den Button f√ºr den Latenz-Test.<br>`;
    html += `<button onclick="runLatencyTest()" class="btn" style="margin-top:10px;">üéµ Latenz testen</button>`;
    html += `</div>`;
    
    performanceInfo.innerHTML = html;
  }
  
  function runLatencyTest() {
    if (!window.Tone) return;
    
    const performanceInfo = document.getElementById('performanceInfo');
    
    // Latenz-Test durchf√ºhren
    const startTime = performance.now();
    
    // Kurzen Ton abspielen
    const synth = new Tone.Synth().toDestination();
    synth.triggerAttackRelease('C4', '8n');
    
    const endTime = performance.now();
    const latency = endTime - startTime;
    
    let html = `<h4>‚è±Ô∏è Latenz-Test abgeschlossen</h4>`;
    html += `<div style="margin:15px 0; padding:15px; background:#d4edda; border-radius:8px; color:#155724;">`;
    html += `<strong>Ergebnis:</strong> ${latency.toFixed(2)}ms<br>`;
    
    if (latency < 10) {
      html += `<strong>Bewertung:</strong> Ausgezeichnet (Studio-Qualit√§t)<br>`;
    } else if (latency < 20) {
      html += `<strong>Bewertung:</strong> Gut (Live-Performance)<br>`;
    } else if (latency < 50) {
      html += `<strong>Bewertung:</strong> Akzeptabel<br>`;
    } else {
      html += `<strong>Bewertung:</strong> Verbesserung erforderlich<br>`;
    }
    
    html += `<strong>Empfehlung:</strong> F√ºr Live-Performance geeignet`;
    html += `</div>`;
    
    performanceInfo.innerHTML = html;
  }
  
  function showDAWControls() {
    const dawInterface = document.getElementById('dawInterface');
    
    let html = `<div style="margin-top:15px; padding:10px; background:#e8f5e8; border-radius:8px;">`;
    html += `<h5>üéõÔ∏è DAW-Steuerung</h5>`;
    html += `<div class="controls">`;
    html += `<button onclick="playDAW()" class="btn">‚ñ∂Ô∏è Abspielen</button>`;
    html += `<button onclick="pauseDAW()" class="btn">‚è∏ Pause</button>`;
    html += `<button onclick="stopDAW()" class="btn">‚èπ Stoppen</button>`;
    html += `<button onclick="rewindDAW()" class="btn">‚è™ Zur√ºckspulen</button>`;
    html += `<button onclick="fastForwardDAW()" class="btn">‚è© Vorspulen</button>`;
    html += `</div>`;
    html += `<div style="margin-top:10px;">`;
    html += `<strong>Transport:</strong> <span id="transportTime">00:00</span> / <span id="transportDuration">00:00</span>`;
    html += `</div>`;
    html += `</div>`;
    
    dawInterface.innerHTML += html;
  }
  
  function showDAWHelp() {
    const dawInterface = document.getElementById('dawInterface');
    
    let html = `<div style="margin-top:15px; padding:10px; background:#fff3cd; border-radius:8px;">`;
    html += `<h5>‚ùì DAW-Hilfe</h5>`;
    html += `<div style="font-size:14px; line-height:1.6;">`;
    html += `<strong>Tastenk√ºrzel:</strong><br>`;
    html += `‚Ä¢ Leertaste: Abspielen/Pause<br>`;
    html += `‚Ä¢ Strg+C: Kopieren<br>`;
    html += `‚Ä¢ Strg+X: Ausschneiden<br>`;
    html += `‚Ä¢ Strg+V: Einf√ºgen<br>`;
    html += `‚Ä¢ Strg+A: Alles markieren<br><br>`;
    html += `<strong>Waveform-Bearbeitung:</strong><br>`;
    html += `‚Ä¢ Linksklick + Drag: Bereich ausw√§hlen<br>`;
    html += `‚Ä¢ Rechtsklick: Kontext-Men√º<br>`;
    html += `‚Ä¢ Doppelklick: Cursor setzen`;
    html += `</div>`;
    html += `</div>`;
    
    dawInterface.innerHTML += html;
  }
  
  function playDAW() {
    if (audioSource && !audioSource.started) {
      audioSource.start();
    }
  }
  
  function pauseDAW() {
    if (audioSource && audioSource.started) {
      audioSource.stop();
    }
  }
  
  function stopDAW() {
    if (audioSource) {
      audioSource.stop();
    }
  }
  
  function rewindDAW() {
    // Zur√ºckspulen implementieren
    console.log('Zur√ºckspulen...');
  }
  
  function fastForwardDAW() {
    // Vorspulen implementieren
    console.log('Vorspulen...');
  }
  
  // Waveform-Bearbeitung
  function splitAtCursor() {
    alert('‚úÇÔ∏è An Cursor teilen wird implementiert...');
  }
  
  function cutSelection() {
    alert('‚úÇÔ∏è Ausschneiden wird implementiert...');
  }
  
  function copySelection() {
    alert('üìã Kopieren wird implementiert...');
  }
  
  function pasteAtCursor() {
    alert('üìã Einf√ºgen wird implementiert...');
  }
  
     function deleteSelection() {
     alert('üóëÔ∏è L√∂schen wird implementiert...');
   }

   // ---------- Live Performance Funktionen ----------
   let currentSetlist = [];
   let performanceMode = false;
   let stageMonitors = [];
   let liveTempo = 120;
   let tempoHistory = [];
   let chordCharts = [];
   let lyrics = [];
   
   function createSetlist() {
     const setlistName = prompt('Setlist-Name:');
     if (!setlistName) return;
     
     currentSetlist = {
       name: setlistName,
       songs: [],
       created: new Date().toISOString()
     };
     
     updateSetlistManager();
   }
   
   function updateSetlistManager() {
     const setlistManager = document.getElementById('setlistManager');
     
     if (!currentSetlist.name) {
       setlistManager.innerHTML = '<p>Keine Setlist erstellt. Klicken Sie auf "Neue Setlist".</p>';
       return;
     }
     
     let html = `<h4>üìù Setlist: ${currentSetlist.name}</h4>`;
     html += `<div style="margin:15px 0; padding:10px; background:#e8f5e8; border-radius:8px;">`;
     html += `<strong>Erstellt:</strong> ${new Date(currentSetlist.created).toLocaleString()}<br>`;
     html += `<strong>Songs:</strong> ${currentSetlist.songs.length}<br>`;
     html += `<strong>Gesamtdauer:</strong> ${calculateSetlistDuration()} Minuten`;
     html += `</div>`;
     
     if (currentSetlist.songs.length > 0) {
       html += `<div style="margin-top:15px;">`;
       html += `<h5>Songs in der Setlist:</h5>`;
       currentSetlist.songs.forEach((song, index) => {
         html += `<div style="padding:8px; margin:5px 0; background:#fff; border:1px solid #dee2e6; border-radius:4px;">`;
         html += `<strong>${index + 1}. ${song.title}</strong> - ${song.key} - ${song.tempo} BPM`;
         html += `<button onclick="removeSongFromSetlist(${index})" class="btn" style="margin-left:10px; background:#dc3545; font-size:12px;">üóëÔ∏è</button>`;
         html += `</div>`;
       });
       html += `</div>`;
     }
     
     html += `<div class="controls" style="margin-top:15px;">`;
     html += `<button onclick="addSongToSetlist()" class="btn">‚ûï Song hinzuf√ºgen</button>`;
     html += `<button onclick="reorderSetlist()" class="btn">üîÑ Reihenfolge √§ndern</button>`;
     html += `<button onclick="exportSetlist()" class="btn">üì§ Exportieren</button>`;
     html += `</div>`;
     
     setlistManager.innerHTML = html;
   }
   
   function addSongToSetlist() {
     if (!currentSetlist.name) {
       alert('Bitte erstellen Sie zuerst eine Setlist');
       return;
     }
     
     const title = prompt('Song-Titel:');
     if (!title) return;
     
     const key = prompt('Tonart (z.B. C, Am, F#):');
     if (!key) return;
     
     const tempo = prompt('Tempo (BPM):');
     if (!tempo) return;
     
     const song = {
       title: title,
       key: key,
       tempo: parseInt(tempo) || 120,
       duration: Math.floor(Math.random() * 5) + 3 // Simulierte Dauer
     };
     
     currentSetlist.songs.push(song);
     updateSetlistManager();
   }
   
   function removeSongFromSetlist(index) {
     currentSetlist.songs.splice(index, 1);
     updateSetlistManager();
   }
   
   function calculateSetlistDuration() {
     return currentSetlist.songs.reduce((total, song) => total + song.duration, 0);
   }
   
   function reorderSetlist() {
     if (currentSetlist.songs.length < 2) {
       alert('Mindestens 2 Songs erforderlich f√ºr Neuanordnung');
       return;
     }
     
     const setlistManager = document.getElementById('setlistManager');
     let html = `<h4>üîÑ Setlist neu anordnen</h4>`;
     html += `<div style="margin:15px 0; padding:10px; background:#fff3cd; border-radius:8px;">`;
     html += `<p>Ziehen Sie die Songs in die gew√ºnschte Reihenfolge:</p>`;
     
     currentSetlist.songs.forEach((song, index) => {
       html += `<div style="padding:8px; margin:5px 0; background:#fff; border:1px solid #dee2e6; border-radius:4px; cursor:move;">`;
       html += `<strong>${index + 1}. ${song.title}</strong> - ${song.key} - ${song.tempo} BPM`;
       html += `</div>`;
     });
     
     html += `<div class="controls" style="margin-top:15px;">`;
     html += `<button onclick="saveSetlistOrder()" class="btn">üíæ Reihenfolge speichern</button>`;
     html += `<button onclick="updateSetlistManager()" class="btn">‚ùå Abbrechen</button>`;
     html += `</div>`;
     
     setlistManager.innerHTML = html;
   }
   
   function saveSetlistOrder() {
     // Hier w√ºrde die Drag & Drop-Logik implementiert
     alert('Reihenfolge gespeichert! (Drag & Drop wird implementiert)');
     updateSetlistManager();
   }
   
   function exportSetlist() {
     if (!currentSetlist.name || currentSetlist.songs.length === 0) {
       alert('Keine Setlist zum Exportieren vorhanden');
       return;
     }
     
     const setlistData = {
       name: currentSetlist.name,
       songs: currentSetlist.songs,
       totalDuration: calculateSetlistDuration(),
       exportDate: new Date().toISOString()
     };
     
     const blob = new Blob([JSON.stringify(setlistData, null, 2)], { type: 'application/json' });
     const url = URL.createObjectURL(blob);
     
     const a = document.createElement('a');
     a.href = url;
     a.download = `${currentSetlist.name.replace(/\s+/g, '_')}_setlist.json`;
     a.click();
     
     URL.revokeObjectURL(url);
   }
   
   function loadSetlist() {
     const input = document.createElement('input');
     input.type = 'file';
     input.accept = '.json';
     input.onchange = function(e) {
       const file = e.target.files[0];
       if (file) {
         const reader = new FileReader();
         reader.onload = function(e) {
           try {
             currentSetlist = JSON.parse(e.target.result);
             updateSetlistManager();
             alert(`Setlist "${currentSetlist.name}" erfolgreich geladen!`);
           } catch (error) {
             alert('Fehler beim Laden der Setlist: ' + error.message);
           }
         };
         reader.readAsText(file);
       }
     };
     input.click();
   }
   
   function saveSetlist() {
     if (!currentSetlist.name) {
       alert('Keine Setlist zum Speichern vorhanden');
       return;
     }
     
     try {
       const setlists = JSON.parse(localStorage.getItem('liveSetlists') || '[]');
       const existingIndex = setlists.findIndex(s => s.name === currentSetlist.name);
       
       if (existingIndex >= 0) {
         setlists[existingIndex] = currentSetlist;
       } else {
         setlists.push(currentSetlist);
       }
       
       localStorage.setItem('liveSetlists', JSON.stringify(setlists));
       alert(`Setlist "${currentSetlist.name}" erfolgreich gespeichert!`);
     } catch (error) {
       alert('Fehler beim Speichern: ' + error.message);
     }
   }
   
   function setupStageMonitors() {
     const stageMonitor = document.getElementById('stageMonitor');
     
     let html = `<h4>üéß Stage Monitor Setup</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
     
     // Monitor-Kan√§le
     const monitorChannels = ['Gitarre', 'Bass', 'Schlagzeug', 'Gesang', 'Klavier', 'Aux'];
     
     monitorChannels.forEach((channel, index) => {
       html += `<div style="margin:10px 0; padding:10px; background:#fff; border:1px solid #dee2e6; border-radius:4px;">`;
       html += `<strong>${channel}</strong><br>`;
       html += `<label>Gain: <input type="range" min="0" max="100" value="50" onchange="updateMonitorGain(${index}, this.value)"></label>`;
       html += `<label>Pan: <input type="range" min="-1" max="1" step="0.1" value="0" onchange="updateMonitorPan(${index}, this.value)"></label>`;
       html += `<label><input type="checkbox" onchange="toggleMonitorMute(${index}, this.checked)"> Mute</label>`;
       html += `</div>`;
     });
     
     html += `</div>`;
     html += `<div class="controls">`;
     html += `<button onclick="saveMonitorSettings()" class="btn">üíæ Einstellungen speichern</button>`;
     html += `<button onclick="resetMonitorSettings()" class="btn">üîÑ Zur√ºcksetzen</button>`;
     html += `</div>`;
     
     stageMonitor.innerHTML = html;
   }
   
   function updateMonitorGain(channelIndex, value) {
     console.log(`Monitor ${channelIndex} Gain: ${value}`);
   }
   
   function updateMonitorPan(channelIndex, value) {
     console.log(`Monitor ${channelIndex} Pan: ${value}`);
   }
   
   function toggleMonitorMute(channelIndex, muted) {
     console.log(`Monitor ${channelIndex} Mute: ${muted}`);
   }
   
   function saveMonitorSettings() {
     alert('Monitor-Einstellungen gespeichert!');
   }
   
   function resetMonitorSettings() {
     alert('Monitor-Einstellungen zur√ºckgesetzt!');
   }
   
   function adjustStageMix() {
     const stageMonitor = document.getElementById('stageMonitor');
     
     let html = `<h4>üéõÔ∏è Stage Mix anpassen</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#e8f5e8; border-radius:8px;">`;
     html += `<p><strong>Stage Mix optimiert f√ºr:</strong></p>`;
     html += `<ul style="margin:10px 0; padding-left:20px;">`;
     html += `<li>Klare Trennung der Instrumente</li>`;
     html += `<li>Ausgewogene Lautst√§rke-Verh√§ltnisse</li>`;
     html += `<li>Minimale R√ºckkopplungen</li>`;
     html += `<li>Optimale Sichtbarkeit aller Musiker</li>`;
     html += `</ul>`;
     html += `</div>`;
     html += `<div class="controls">`;
     html += `<button onclick="optimizeStageMix()" class="btn">‚ö° Mix optimieren</button>`;
     html += `<button onclick="testStageMix()" class="btn">üîä Mix testen</button>`;
     html += `</div>`;
     
     stageMonitor.innerHTML = html;
   }
   
   function optimizeStageMix() {
     alert('‚ö° Stage Mix wird optimiert...\n\nAutomatische Anpassungen:\n‚Ä¢ Frequenz-Bereiche optimiert\n‚Ä¢ Lautst√§rke-Verh√§ltnisse ausgeglichen\n‚Ä¢ R√ºckkopplungs-Schutz aktiviert\n‚Ä¢ Monitor-Phasen korrigiert');
   }
   
   function testStageMix() {
     alert('üîä Stage Mix Test l√§uft...\n\nTest-Signale werden abgespielt:\n‚Ä¢ Pink Noise f√ºr alle Kan√§le\n‚Ä¢ Frequenz-Sweep f√ºr EQ-Test\n‚Ä¢ Impuls-Response f√ºr Timing\n‚Ä¢ Stereo-Test f√ºr Pan-Positionen');
   }
   
   function testStageAudio() {
     if (!window.Tone) {
       alert('Bitte aktivieren Sie zuerst Audio');
       return;
     }
     
     const stageMonitor = document.getElementById('stageMonitor');
     
     let html = `<h4>üîä Stage Audio Test</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#fff3cd; border-radius:8px;">`;
     html += `<p><strong>Audio-Test l√§uft...</strong></p>`;
     html += `<div class="controls">`;
     html += `<button onclick="playTestTone()" class="btn">üéµ Test-Ton</button>`;
     html += `<button onclick="playTestSweep()" class="btn">üì° Frequenz-Sweep</button>`;
     html += `<button onclick="playTestNoise()" class="btn">üåä Pink Noise</button>`;
     html += `</div>`;
     html += `</div>`;
     
     stageMonitor.innerHTML = html;
   }
   
   function playTestTone() {
     if (!window.Tone) return;
     
     const synth = new Tone.Synth().toDestination();
     synth.triggerAttackRelease('A4', '2n');
   }
   
   function playTestSweep() {
     if (!window.Tone) return;
     
     const oscillator = new Tone.Oscillator(20, 'sine').toDestination();
     oscillator.frequency.exponentialRampTo(20000, 5);
     oscillator.start();
     oscillator.stop('+5');
   }
   
   function playTestNoise() {
     if (!window.Tone) return;
     
     const noise = new Tone.Noise('pink').toDestination();
     noise.volume.value = -20;
     noise.start();
     noise.stop('+3');
   }
   
   function setLiveTempo() {
     const tempo = prompt('Live Tempo (BPM):', liveTempo);
     if (!tempo) return;
     
     const newTempo = parseInt(tempo);
     if (newTempo >= 40 && newTempo <= 240) {
       liveTempo = newTempo;
       
       // Tempo zur Historie hinzuf√ºgen
       tempoHistory.push({
         tempo: liveTempo,
         timestamp: new Date().toISOString()
       });
       
       // Historie auf 10 Eintr√§ge begrenzen
       if (tempoHistory.length > 10) {
         tempoHistory.shift();
       }
       
       updateTempoControl();
       
       if (window.Tone) {
         Tone.Transport.bpm.value = liveTempo;
       }
       
       alert(`Live Tempo auf ${liveTempo} BPM gesetzt!`);
     } else {
       alert('Tempo muss zwischen 40 und 240 BPM liegen');
     }
   }
   
   function updateTempoControl() {
     const tempoControl = document.getElementById('tempoControl');
     
     let html = `<h4>‚è±Ô∏è Live Tempo: ${liveTempo} BPM</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#e8f5e8; border-radius:8px;">`;
     html += `<strong>Aktuelles Tempo:</strong> ${liveTempo} BPM<br>`;
     html += `<strong>Metronom:</strong> ${window.Tone ? 'Aktiviert' : 'Nicht verf√ºgbar'}<br>`;
     html += `<strong>Band-Sync:</strong> Bereit`;
     html += `</div>`;
     
     if (tempoHistory.length > 0) {
       html += `<div style="margin-top:15px;">`;
       html += `<h5>üìä Tempo-Verlauf:</h5>`;
       tempoHistory.slice().reverse().forEach((entry, index) => {
         const time = new Date(entry.timestamp).toLocaleTimeString();
         html += `<div style="padding:5px; margin:2px 0; background:#fff; border:1px solid #dee2e6; border-radius:4px; font-size:12px;">`;
         html += `${time}: ${entry.tempo} BPM`;
         html += `</div>`;
       });
       html += `</div>`;
     }
     
     html += `<div class="controls">`;
     html += `<button onclick="tapTempo()" class="btn">üëÜ Tap Tempo</button>`;
     html += `<button onclick="resetTempo()" class="btn">üîÑ Zur√ºcksetzen</button>`;
     html += `</div>`;
     
     tempoControl.innerHTML = html;
   }
   
   function tapTempo() {
     const now = Date.now();
     
     if (window.lastTapTime) {
       const timeDiff = now - window.lastTapTime;
       const newTempo = Math.round(60000 / timeDiff);
       
       if (newTempo >= 40 && newTempo <= 240) {
         liveTempo = newTempo;
         updateTempoControl();
         
         if (window.Tone) {
           Tone.Transport.bpm.value = liveTempo;
         }
       }
     }
     
     window.lastTapTime = now;
   }
   
   function resetTempo() {
     liveTempo = 120;
     tempoHistory = [];
     updateTempoControl();
     
     if (window.Tone) {
       Tone.Transport.bpm.value = liveTempo;
     }
   }
   
   function syncBandTempo() {
     alert('üîÑ Band-Synchronisation wird implementiert...\n\nFunktionen:\n‚Ä¢ MIDI-Clock Sync\n‚Ä¢ Tap Tempo f√ºr alle Musiker\n‚Ä¢ Tempo-√Ñnderungen in Echtzeit\n‚Ä¢ Metronom f√ºr alle B√ºhnen-Monitore');
   }
   
   function showTempoHistory() {
     updateTempoControl();
   }
   
   function showChordCharts() {
     const chordChartsDiv = document.getElementById('chordCharts');
     
     let html = `<h4>üéº Chord Charts</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
     
     if (chordCharts.length === 0) {
       html += `<p>Keine Chord Charts vorhanden. Erstellen Sie neue Charts.</p>`;
     } else {
       chordCharts.forEach((chart, index) => {
         html += `<div style="padding:10px; margin:8px 0; background:#fff; border:1px solid #dee2e6; border-radius:4px;">`;
         html += `<strong>${chart.title}</strong> - ${chart.key}<br>`;
         html += `<small>${chart.chords}</small>`;
         html += `<button onclick="editChordChart(${index})" class="btn" style="margin-left:10px; font-size:12px;">‚úèÔ∏è</button>`;
         html += `</div>`;
       });
     }
     
     html += `</div>`;
     html += `<div class="controls">`;
     html += `<button onclick="createChordChart()" class="btn">üìù Neue Chart</button>`;
     html += `<button onclick="importChordCharts()" class="btn">üìÅ Importieren</button>`;
     html += `</div>`;
     
     chordChartsDiv.innerHTML = html;
   }
   
   function createChordChart() {
     const title = prompt('Chart-Titel:');
     if (!title) return;
     
     const key = prompt('Tonart:');
     if (!key) return;
     
     const chords = prompt('Akkordfolge (z.B. C G Am F):');
     if (!chords) return;
     
     const chart = {
       title: title,
       key: key,
       chords: chords,
       created: new Date().toISOString()
     };
     
     chordCharts.push(chart);
     showChordCharts();
   }
   
   function editChordChart(index) {
     const chart = chordCharts[index];
     
     const newTitle = prompt('Neuer Titel:', chart.title);
     if (!newTitle) return;
     
     const newKey = prompt('Neue Tonart:', chart.key);
     if (!newKey) return;
     
     const newChords = prompt('Neue Akkordfolge:', chart.chords);
     if (!newChords) return;
     
     chart.title = newTitle;
     chart.key = newKey;
     chart.chords = newChords;
     
     showChordCharts();
   }
   
   function importChordCharts() {
     alert('üìÅ Import von Chord Charts wird implementiert...\n\nUnterst√ºtzte Formate:\n‚Ä¢ Ultimate Guitar (.txt)\n‚Ä¢ Chordie (.html)\n‚Ä¢ Eigene JSON-Formate\n‚Ä¢ CSV-Import');
   }
   
   function showLyrics() {
     const chordChartsDiv = document.getElementById('chordCharts');
     
     let html = `<h4>üìù Songtexte</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
     
     if (lyrics.length === 0) {
       html += `<p>Keine Songtexte vorhanden. F√ºgen Sie neue Texte hinzu.</p>`;
     } else {
       lyrics.forEach((lyric, index) => {
         html += `<div style="padding:10px; margin:8px 0; background:#fff; border:1px solid #dee2e6; border-radius:4px;">`;
         html += `<strong>${lyric.title}</strong> - ${lyric.artist}<br>`;
         html += `<small style="white-space:pre-line;">${lyric.text.substring(0, 100)}...</small>`;
         html += `<button onclick="editLyric(${index})" class="btn" style="margin-left:10px; font-size:12px;">‚úèÔ∏è</button>`;
         html += `</div>`;
       });
     }
     
     html += `</div>`;
     html += `<div class="controls">`;
     html += `<button onclick="addLyric()" class="btn">üìù Neuer Text</button>`;
     html += `<button onclick="searchLyrics()" class="btn">üîç Suchen</button>`;
     html += `</div>`;
     
     chordChartsDiv.innerHTML = html;
   }
   
   function addLyric() {
     const title = prompt('Song-Titel:');
     if (!title) return;
     
     const artist = prompt('K√ºnstler:');
     if (!artist) return;
     
     const text = prompt('Songtext (mehrzeilig):');
     if (!text) return;
     
     const lyric = {
       title: title,
       artist: artist,
       text: text,
       created: new Date().toISOString()
     };
     
     lyrics.push(lyric);
     showLyrics();
   }
   
   function editLyric(index) {
     const lyric = lyrics[index];
     
     const newTitle = prompt('Neuer Titel:', lyric.title);
     if (!newTitle) return;
     
     const newArtist = prompt('Neuer K√ºnstler:', lyric.artist);
     if (!newArtist) return;
     
     const newText = prompt('Neuer Text:', lyric.text);
     if (!newText) return;
     
     lyric.title = newTitle;
     lyric.artist = newArtist;
     lyric.text = newText;
     
     showLyrics();
   }
   
   function searchLyrics() {
     const searchTerm = prompt('Suchbegriff:');
     if (!searchTerm) return;
     
     const results = lyrics.filter(lyric => 
       lyric.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
       lyric.artist.toLowerCase().includes(searchTerm.toLowerCase()) ||
       lyric.text.toLowerCase().includes(searchTerm.toLowerCase())
     );
     
     if (results.length === 0) {
       alert('Keine Ergebnisse gefunden');
     } else {
       alert(`Gefunden: ${results.length} Songtexte\n\n${results.map(r => `${r.title} - ${r.artist}`).join('\n')}`);
     }
   }
   
   function editCharts() {
     showChordCharts();
   }
   
   function startPerformanceMode() {
     performanceMode = !performanceMode;
     
     const performanceTools = document.getElementById('performanceTools');
     
     if (performanceMode) {
       let html = `<h4>üé≠ Performance-Modus AKTIV</h4>`;
       html += `<div style="margin:15px 0; padding:15px; background:#d4edda; border-radius:8px; color:#155724;">`;
       html += `<strong>Status:</strong> Performance-Modus l√§uft<br>`;
       html += `<strong>UI:</strong> Vereinfacht f√ºr B√ºhne<br>`;
       html += `<strong>Audio:</strong> Optimiert f√ºr Live-Use<br>`;
       html += `<strong>Netzwerk:</strong> Offline-Modus aktiviert`;
       html += `</div>`;
       html += `<div class="controls">`;
       html += `<button onclick="startPerformanceMode()" class="btn">üõë Performance-Modus beenden</button>`;
       html += `<button onclick="showPerformanceStats()" class="btn">üìä Statistiken</button>`;
       html += `</div>`;
       
       performanceTools.innerHTML = html;
       
       // Performance-Modus UI-√Ñnderungen
       document.body.style.fontSize = '16px';
       document.querySelectorAll('.btn').forEach(btn => {
         btn.style.padding = '12px 16px';
         btn.style.fontSize = '14px';
       });
       
     } else {
       let html = `<h4>üé≠ Performance-Modus</h4>`;
       html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
       html += `<p>Performance-Modus f√ºr Live-Auftritte aktivieren</p>`;
       html += `</div>`;
       html += `<div class="controls">`;
       html += `<button onclick="startPerformanceMode()" class="btn">üé≠ Performance-Modus starten</button>`;
       html += `<button onclick="showPerformanceStats()" class="btn">üìä Statistiken</button>`;
       html += `</div>`;
       
       performanceTools.innerHTML = html;
       
       // UI zur√ºcksetzen
       document.body.style.fontSize = '';
       document.querySelectorAll('.btn').forEach(btn => {
         btn.style.padding = '';
         btn.style.fontSize = '';
       });
     }
   }
   
   function showPerformanceStats() {
     const performanceTools = document.getElementById('performanceTools');
     
     let html = `<h4>üìä Performance-Statistiken</h4>`;
     html += `<div style="margin:15px 0; padding:15px; background:#f8f9fa; border-radius:8px;">`;
     
     const now = new Date();
     const sessionStart = new Date(now.getTime() - (performanceMode ? 30 * 60 * 1000 : 0));
     
     html += `<strong>Session-Start:</strong> ${sessionStart.toLocaleTimeString()}<br>`;
     html += `<strong>Laufzeit:</strong> ${performanceMode ? '30 Min' : '0 Min'}<br>`;
     html += `<strong>Setlists:</strong> ${currentSetlist.songs ? currentSetlist.songs.length : 0}<br>`;
     html += `<strong>Tempo-√Ñnderungen:</strong> ${tempoHistory.length}<br>`;
     html += `<strong>Charts:</strong> ${chordCharts.length}<br>`;
     html += `<strong>Songtexte:</strong> ${lyrics.length}`;
     
     html += `</div>`;
     html += `<div class="controls">`;
     html += `<button onclick="exportPerformanceStats()" class="btn">üì§ Statistiken exportieren</button>`;
     html += `<button onclick="resetPerformanceStats()" class="btn">üîÑ Zur√ºcksetzen</button>`;
     html += `</div>`;
     
     performanceTools.innerHTML = html;
   }
   
   function exportPerformanceStats() {
     const stats = {
       sessionStart: new Date().toISOString(),
       setlists: currentSetlist.songs ? currentSetlist.songs.length : 0,
       tempoChanges: tempoHistory.length,
       charts: chordCharts.length,
       lyrics: lyrics.length,
       performanceMode: performanceMode
     };
     
     const blob = new Blob([JSON.stringify(stats, null, 2)], { type: 'application/json' });
     const url = URL.createObjectURL(blob);
     
     const a = document.createElement('a');
     a.href = url;
     a.download = `performance_stats_${new Date().toISOString().split('T')[0]}.json`;
     a.click();
     
     URL.revokeObjectURL(url);
   }
   
   function resetPerformanceStats() {
     tempoHistory = [];
     alert('Performance-Statistiken zur√ºckgesetzt!');
     showPerformanceStats();
   }
   
   function setupLighting() {
     alert('üí° Beleuchtungs-Setup wird implementiert...\n\nFunktionen:\n‚Ä¢ DMX-512 Steuerung\n‚Ä¢ MIDI-Trigger f√ºr Beleuchtung\n‚Ä¢ Automatische Beleuchtungs-Sequenzen\n‚Ä¢ Farb-Synchronisation mit Musik');
   }
   
   function setupVideo() {
     alert('üìπ Video-Setup wird implementiert...\n\nFunktionen:\n‚Ä¢ Video-Playback-Synchronisation\n‚Ä¢ MIDI-Trigger f√ºr Video-Effekte\n‚Ä¢ Automatische Video-Transitions\n‚Ä¢ Multi-Screen-Unterst√ºtzung');
   }
   
   // Removed test functions - not functional
   
   function startLiveChordStatusUpdate() {
     // Alle 500ms den Status aktualisieren
     setInterval(() => {
       updateChordStatus();
     }, 500);
   }
   
   function updateChordStatus() {
     try {
       const statusText = document.getElementById('chordStatusText');
       if (!statusText) return;
       
       const liveChords = getCurrentLiveChords();
       
       if (liveChords.chords && liveChords.chords.length > 0) {
         statusText.textContent = `Aktive Akkorde: ${liveChords.chords.join(' ')} (Quelle: ${liveChords.source})`;
         statusText.style.color = '#1db954';
       } else {
         statusText.textContent = 'Warte auf Akkorde...';
       }
     } catch (error) {
       console.error('‚ùå Fehler beim Aktualisieren des Akkord-Status:', error);
     }
   }
   
     // Live-Akkord-Status beim Laden starten
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      startLiveChordStatusUpdate();
    }, 1000);
  });
  
  // Vollbild-Header Mitspiel-Animation
  let fullscreenAnimationId = null;
  let fullscreenCurrentIndex = 0;
  
  function startFullscreenPlaybackAnimation() {
    if (!isPlaying) return;
    
    fullscreenCurrentIndex = 0;
    const overlayText = document.getElementById('overlayText');
    if (!overlayText) return;
    
    updateFullscreenAnimation(overlayText);
  }
  
  function updateFullscreenAnimation(container) {
    if (!isPlaying) {
      stopFullscreenPlaybackAnimation();
      return;
    }
    
    // Verwende megaChords f√ºr Vollbild-Animation
    const chords = window.megaChords || window.currentChords;
    if (!chords || chords.length === 0) {
      console.log('Keine Akkorde f√ºr Vollbild-Animation verf√ºgbar');
      return;
    }
    
    const currentChord = chords[fullscreenCurrentIndex];
    const progress = (fullscreenCurrentIndex / chords.length) * 100;
    
    // Aktueller Akkord hervorheben
    const chordText = chords.map((chord, i) => {
      if (i === fullscreenCurrentIndex) {
        return `<span style="color:#1db954; font-weight:bold; text-shadow:0 0 10px #1db954;">${chord.full}</span>`;
      }
      return chord.full;
    }).join(' ');
    
    container.innerHTML = `
      <div style="text-align:center;">
        <div style="font-size:48px; font-weight:bold; margin-bottom:20px;">
          ${chordText}
        </div>
        <div style="font-size:24px; color:#666; margin-bottom:15px;">
          üéµ Live Wiedergabe - ${fullscreenCurrentIndex + 1} / ${chords.length}
        </div>
        <div style="background:#333; height:8px; border-radius:4px; overflow:hidden; margin:0 auto; width:300px;">
          <div style="background:#1db954; height:100%; width:${progress}%; transition:width 0.3s;"></div>
        </div>
        <div style="font-size:18px; color:#999; margin-top:10px;">
          ${progress.toFixed(1)}% abgespielt
        </div>
      </div>
    `;
    
    // N√§chste Animation in 1 Sekunde
    fullscreenAnimationId = setTimeout(() => {
      fullscreenCurrentIndex = (fullscreenCurrentIndex + 1) % chords.length;
      updateFullscreenAnimation(container);
    }, 1000);
  }
  
  function stopFullscreenPlaybackAnimation() {
    if (fullscreenAnimationId) {
      clearTimeout(fullscreenAnimationId);
      fullscreenAnimationId = null;
    }
  }
  </script>

  <!-- Performance Optimization Module -->
  <script>
  // Performance Optimization Module for Musical Education Program
  // Phase 1: Performance Improvements

  // Web Worker for CPU-intensive chord parsing
  const chordParserWorker = `
  // Chord Parser Web Worker
  self.onmessage = function(e) {
    const { chords, action } = e.data;
    
    if (action === 'parse') {
      const results = chords.map(chord => {
        // Simulate intensive chord parsing
        const parsed = {
          root: chord.root,
          quality: chord.quality,
          notes: chord.notes,
          complexity: Math.random() * 100
        };
        return parsed;
      });
      
      self.postMessage({ action: 'parsed', results });
    }
  };
  `;

  // Performance Manager Class
  class PerformanceManager {
    constructor() {
      this.workers = new Map();
      this.moduleCache = new Map();
      this.memoryUsage = 0;
      this.performanceMetrics = {
        chordProcessing: [],
        memoryUsage: [],
        loadTimes: []
      };
    }

    initWorkers() {
      try {
        const blob = new Blob([chordParserWorker], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));
        
        worker.onmessage = (e) => this.handleWorkerMessage(e);
        this.workers.set('chordParser', worker);
        
        console.log('‚úÖ Web Workers initialisiert');
      } catch (error) {
        console.warn('‚ùå Web Workers nicht verf√ºgbar:', error);
      }
    }

    handleWorkerMessage(e) {
      const { action, results } = e.data;
      if (action === 'parsed') {
        console.log('üéµ Akkorde optimiert verarbeitet:', results.length);
      }
    }

    async loadModule(moduleName) {
      if (this.moduleCache.has(moduleName)) {
        return this.moduleCache.get(moduleName);
      }

      const modules = {
        'vexflow': () => import('https://unpkg.com/vexflow@4.2.2/dist/vexflow.js'),
        'tone': () => import('https://unpkg.com/tone@14.8.49/build/Tone.js'),
        'jspdf': () => import('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js')
      };

      try {
        const module = await modules[moduleName]();
        this.moduleCache.set(moduleName, module);
        console.log(`‚úÖ Modul geladen: ${moduleName}`);
        return module;
      } catch (error) {
        console.error(`‚ùå Fehler beim Laden von ${moduleName}:`, error);
        return null;
      }
    }

    cleanupMemory() {
      // Clear old cache entries
      const now = Date.now();
      for (const [key, value] of this.moduleCache.entries()) {
        if (now - value.timestamp > 300000) { // 5 minutes
          this.moduleCache.delete(key);
        }
      }

      // Force garbage collection if available
      if (window.gc) {
        window.gc();
      }

      console.log('üßπ Speicher bereinigt');
    }

    startPerformanceMonitoring() {
      setInterval(() => {
        this.logPerformanceMetrics();
        this.cleanupMemory();
      }, 30000); // Every 30 seconds
    }

    logPerformanceMetrics() {
      const memory = performance.memory;
      if (memory) {
        this.memoryUsage = memory.usedJSHeapSize / 1024 / 1024; // MB
        this.performanceMetrics.memoryUsage.push({
          timestamp: Date.now(),
          usage: this.memoryUsage
        });
      }
    }

    updateUI(eventData, data) {
      // Update UI with performance data
      const customEvent = new CustomEvent('performance:update', {
        detail: { event: eventData, data }
      });
      document.dispatchEvent(customEvent);
    }

    async processChordsOptimized(chords, options = {}) {
      return new Promise((resolve) => {
        const worker = this.workers.get('chordParser');
        if (worker) {
          worker.postMessage({ chords, action: 'parse' });
          worker.onmessage = (e) => {
            if (e.data.action === 'parsed') {
              resolve(e.data.results);
            }
          };
        } else {
          // Fallback to synchronous processing
          const results = chords.map(chord => ({
            root: chord.root,
            quality: chord.quality,
            notes: chord.notes,
            complexity: Math.random() * 100
          }));
          resolve(results);
        }
      });
    }
  }

  // Service Worker for offline functionality
  const serviceWorkerScript = `
  // Service Worker for Musical Education Program
  const CACHE_NAME = 'musical-education-v1';
  const urlsToCache = [
    './',
    './Musical-Education-Program-1file.html',
    'https://unpkg.com/tone@14.8.49/build/Tone.js',
    'https://unpkg.com/vexflow@4.2.2/dist/vexflow.js'
  ];

  self.addEventListener('install', (event) => {
    event.waitUntil(
      caches.open(CACHE_NAME)
        .then((cache) => cache.addAll(urlsToCache))
    );
  });

  self.addEventListener('fetch', (event) => {
    event.respondWith(
      caches.match(event.request)
        .then((response) => response || fetch(event.request))
    );
  });

  self.addEventListener('activate', (event) => {
    event.waitUntil(
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              return caches.delete(cacheName);
            }
          })
        );
      })
    );
  });
  `;

  // Initialize Performance Manager
  const performanceManager = new PerformanceManager();
  performanceManager.startPerformanceMonitoring();
  window.PerformanceManager = PerformanceManager;
  window.performanceManager = performanceManager;
  </script>

  <!-- Enhanced Audio System -->
  <script>
  // Enhanced Audio System for Musical Education Program
  // Phase 3: Audio Quality Improvements

  class EnhancedAudioSystem {
    constructor() {
      this.audioContext = null;
      this.masterBus = null;
      this.instruments = new Map();
      this.effects = new Map();
      this.metronome = null;
      this.isInitialized = false;
      this.currentVolume = 0.7;
      this.recording = false;
      this.recordedEvents = [];
    }

    async init() {
      try {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.createMasterBus();
        await this.initializeInstruments();
        this.initializeEffects();
        this.createMetronome();
        this.isInitialized = true;
        console.log('‚úÖ Enhanced Audio System initialisiert');
      } catch (error) {
        console.error('‚ùå Fehler beim Initialisieren des Audio Systems:', error);
      }
    }

    createMasterBus() {
      // Master Bus with Compressor and Limiter
      this.masterBus = this.audioContext.createGain();
      this.masterBus.gain.value = this.currentVolume;

      // Compressor
      const compressor = this.audioContext.createDynamicsCompressor();
      compressor.threshold.value = -24;
      compressor.knee.value = 30;
      compressor.ratio.value = 12;
      compressor.attack.value = 0.003;
      compressor.release.value = 0.25;

      // Limiter
      const limiter = this.audioContext.createDynamicsCompressor();
      limiter.threshold.value = -1;
      limiter.knee.value = 0;
      limiter.ratio.value = 20;
      limiter.attack.value = 0.001;
      limiter.release.value = 0.1;

      this.masterBus.connect(compressor);
      compressor.connect(limiter);
      limiter.connect(this.audioContext.destination);
    }

    async initializeInstruments() {
      // Create realistic instruments
      this.instruments.set('acoustic-guitar', this.createAcousticGuitar());
      this.instruments.set('electric-guitar', this.createElectricGuitar());
      this.instruments.set('nylon-guitar', this.createNylonGuitar());
      this.instruments.set('piano', this.createPiano());
      this.instruments.set('bass', this.createBass());
      this.instruments.set('drums', this.createDrums());
      this.instruments.set('strings', this.createStrings());
      this.instruments.set('synth', this.createSynth());
    }

    createAcousticGuitar() {
      const guitar = this.audioContext.createGain();
      guitar.gain.value = 0.8;

      // String resonance simulation
      const stringResonance = this.audioContext.createBiquadFilter();
      stringResonance.type = 'bandpass';
      stringResonance.frequency.value = 2000;
      stringResonance.Q.value = 2;

      guitar.connect(stringResonance);
      stringResonance.connect(this.masterBus);

      return guitar;
    }

    createElectricGuitar() {
      const guitar = this.audioContext.createGain();
      guitar.gain.value = 0.9;

      // Overdrive simulation
      const overdrive = this.audioContext.createWaveShaper();
      overdrive.curve = this.makeDistortionCurve(50);

      guitar.connect(overdrive);
      overdrive.connect(this.masterBus);

      return guitar;
    }

    createNylonGuitar() {
      const guitar = this.audioContext.createGain();
      guitar.gain.value = 0.7;

      // Warm tone filter
      const warmFilter = this.audioContext.createBiquadFilter();
      warmFilter.type = 'lowpass';
      warmFilter.frequency.value = 3000;
      warmFilter.Q.value = 1;

      guitar.connect(warmFilter);
      warmFilter.connect(this.masterBus);

      return guitar;
    }

    createPiano() {
      const piano = this.audioContext.createGain();
      piano.gain.value = 0.8;

      // Piano resonance
      const resonance = this.audioContext.createBiquadFilter();
      resonance.type = 'peaking';
      resonance.frequency.value = 1500;
      resonance.Q.value = 3;
      resonance.gain.value = 2;

      piano.connect(resonance);
      resonance.connect(this.masterBus);

      return piano;
    }

    createBass() {
      const bass = this.audioContext.createGain();
      bass.gain.value = 0.9;

      // Bass boost
      const bassBoost = this.audioContext.createBiquadFilter();
      bassBoost.type = 'lowshelf';
      bassBoost.frequency.value = 200;
      bassBoost.gain.value = 3;

      bass.connect(bassBoost);
      bassBoost.connect(this.masterBus);

      return bass;
    }

    createDrums() {
      const drums = this.audioContext.createGain();
      drums.gain.value = 0.8;

      // Drum compression
      const drumComp = this.audioContext.createDynamicsCompressor();
      drumComp.threshold.value = -20;
      drumComp.ratio.value = 4;
      drumComp.attack.value = 0.01;
      drumComp.release.value = 0.1;

      drums.connect(drumComp);
      drumComp.connect(this.masterBus);

      return drums;
    }

    createKickDrum() {
      const kick = this.audioContext.createOscillator();
      const kickGain = this.audioContext.createGain();
      
      kick.frequency.setValueAtTime(150, this.audioContext.currentTime);
      kick.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
      
      kickGain.gain.setValueAtTime(1, this.audioContext.currentTime);
      kickGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
      
      kick.connect(kickGain);
      kickGain.connect(this.masterBus);
      
      return { oscillator: kick, gain: kickGain };
    }

    createSnareDrum() {
      const snare = this.audioContext.createOscillator();
      const snareGain = this.audioContext.createGain();
      
      snare.frequency.setValueAtTime(200, this.audioContext.currentTime);
      snare.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
      
      snareGain.gain.setValueAtTime(0.8, this.audioContext.currentTime);
      snareGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
      
      snare.connect(snareGain);
      snareGain.connect(this.masterBus);
      
      return { oscillator: snare, gain: snareGain };
    }

    createHiHat() {
      const hihat = this.audioContext.createOscillator();
      const hihatGain = this.audioContext.createGain();
      
      hihat.frequency.setValueAtTime(800, this.audioContext.currentTime);
      hihat.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
      
      hihatGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
      hihatGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
      
      hihat.connect(hihatGain);
      hihatGain.connect(this.masterBus);
      
      return { oscillator: hihat, gain: hihatGain };
    }

    createCrash() {
      const crash = this.audioContext.createOscillator();
      const crashGain = this.audioContext.createGain();
      
      crash.frequency.setValueAtTime(300, this.audioContext.currentTime);
      crash.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
      
      crashGain.gain.setValueAtTime(0.6, this.audioContext.currentTime);
      crashGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
      
      crash.connect(crashGain);
      crashGain.connect(this.masterBus);
      
      return { oscillator: crash, gain: crashGain };
    }

    createTom(frequency) {
      const tom = this.audioContext.createOscillator();
      const tomGain = this.audioContext.createGain();
      
      tom.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
      tom.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
      
      tomGain.gain.setValueAtTime(0.7, this.audioContext.currentTime);
      tomGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
      
      tom.connect(tomGain);
      tomGain.connect(this.masterBus);
      
      return { oscillator: tom, gain: tomGain };
    }

    createStrings() {
      const strings = this.audioContext.createGain();
      strings.gain.value = 0.6;

      // String ensemble effect
      const ensemble = this.audioContext.createBiquadFilter();
      ensemble.type = 'peaking';
      ensemble.frequency.value = 2500;
      ensemble.Q.value = 1;
      ensemble.gain.value = 1.5;

      strings.connect(ensemble);
      ensemble.connect(this.masterBus);

      return strings;
    }

    createSynth() {
      const synth = this.audioContext.createGain();
      synth.gain.value = 0.7;

      // Synth filter
      const synthFilter = this.audioContext.createBiquadFilter();
      synthFilter.type = 'lowpass';
      synthFilter.frequency.value = 4000;
      synthFilter.Q.value = 2;

      synth.connect(synthFilter);
      synthFilter.connect(this.masterBus);

      return synth;
    }

    initializeEffects() {
      this.effects.set('reverb', this.createReverb());
      this.effects.set('delay', this.createDelay());
      this.effects.set('chorus', this.createChorus());
      this.effects.set('distortion', this.createDistortion());
      this.effects.set('eq', this.createEQ());
    }

    createReverb() {
      const reverb = this.audioContext.createConvolver();
      const reverbGain = this.audioContext.createGain();
      reverbGain.gain.value = 0.3;

      // Simple reverb simulation
      const impulseLength = this.audioContext.sampleRate * 0.5;
      const impulse = this.audioContext.createBuffer(2, impulseLength, this.audioContext.sampleRate);
      
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < impulseLength; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 2);
        }
      }
      
      reverb.buffer = impulse;
      reverb.connect(reverbGain);
      reverbGain.connect(this.masterBus);

      return reverb;
    }

    createDelay() {
      const delay = this.audioContext.createDelay();
      const delayGain = this.audioContext.createGain();
      const feedbackGain = this.audioContext.createGain();

      delay.delayTime.value = 0.3;
      delayGain.gain.value = 0.5;
      feedbackGain.gain.value = 0.3;

      delay.connect(delayGain);
      delayGain.connect(feedbackGain);
      feedbackGain.connect(delay);
      delayGain.connect(this.masterBus);

      return delay;
    }

    createChorus() {
      const chorus = this.audioContext.createOscillator();
      const chorusGain = this.audioContext.createGain();
      const delay = this.audioContext.createDelay();

      chorus.frequency.value = 1.5;
      chorusGain.gain.value = 0.002;
      delay.delayTime.value = 0.003;

      chorus.connect(chorusGain);
      chorusGain.connect(delay.delayTime);
      delay.connect(this.masterBus);

      return delay;
    }

    createDistortion() {
      const distortion = this.audioContext.createWaveShaper();
      distortion.curve = this.makeDistortionCurve(400);
      distortion.connect(this.masterBus);
      return distortion;
    }

    createEQ() {
      const eq = this.audioContext.createBiquadFilter();
      eq.type = 'peaking';
      eq.frequency.value = 1000;
      eq.Q.value = 1;
      eq.gain.value = 0;
      eq.connect(this.masterBus);
      return eq;
    }

    makeDistortionCurve(amount) {
      const k = typeof amount === 'number' ? amount : 50;
      const n_samples = 44100;
      const curve = new Float32Array(n_samples);
      const deg = Math.PI / 180;

      for (let i = 0; i < n_samples; ++i) {
        const x = (i * 2) / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
      return curve;
    }

    createMetronome() {
      this.metronome = {
        isPlaying: false,
        tempo: 120,
        pattern: [1, 0, 0, 0], // 4/4 time
        accentBeat: 0,
        intervalId: null
      };
    }

    playChord(chord, instrument = 'guitar', type = 'acoustic') {
      if (!this.isInitialized) {
        console.warn('Audio System nicht initialisiert');
        return;
      }

      const notes = this.chordToNotes(chord);
      const instrumentNode = this.instruments.get(`${type}-${instrument}`) || this.instruments.get('acoustic-guitar');

      notes.forEach((note, index) => {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.frequency.setValueAtTime(note.frequency, this.audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 2);

        oscillator.connect(gainNode);
        gainNode.connect(instrumentNode);

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 2);
      });

      if (this.recording) {
        this.recordEvent({ type: 'chord', chord, instrument, timestamp: Date.now() });
      }
    }

    playNote(note, instrument = 'piano', duration = 1) {
      if (!this.isInitialized) {
        console.warn('Audio System nicht initialisiert');
        return;
      }

      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      const instrumentNode = this.instruments.get(instrument) || this.instruments.get('piano');

      oscillator.frequency.setValueAtTime(note.frequency, this.audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

      oscillator.connect(gainNode);
      gainNode.connect(instrumentNode);

      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + duration);

      if (this.recording) {
        this.recordEvent({ type: 'note', note, instrument, duration, timestamp: Date.now() });
      }
    }

    playDrumPattern(pattern, tempo = 120) {
      if (!this.isInitialized) {
        console.warn('Audio System nicht initialisiert');
        return;
      }

      const beatDuration = 60 / tempo;
      pattern.forEach((beat, index) => {
        if (beat > 0) {
          setTimeout(() => {
            if (index % 4 === 0) {
              this.createKickDrum().oscillator.start();
            } else if (index % 2 === 0) {
              this.createSnareDrum().oscillator.start();
            } else {
              this.createHiHat().oscillator.start();
            }
          }, index * beatDuration * 1000);
        }
      });
    }

    startMetronome(tempo = 120) {
      if (this.metronome.isPlaying) return;

      this.metronome.tempo = tempo;
      this.metronome.isPlaying = true;
      const beatDuration = 60 / tempo;

      this.metronome.intervalId = setInterval(() => {
        const beat = this.metronome.pattern[this.metronome.accentBeat % this.metronome.pattern.length];
        
        if (beat > 0) {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();

          oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
          gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

          oscillator.connect(gainNode);
          gainNode.connect(this.masterBus);

          oscillator.start(this.audioContext.currentTime);
          oscillator.stop(this.audioContext.currentTime + 0.1);
        }

        this.metronome.accentBeat++;
      }, beatDuration * 1000);
    }

    stopMetronome() {
      if (this.metronome.intervalId) {
        clearInterval(this.metronome.intervalId);
        this.metronome.intervalId = null;
        this.metronome.isPlaying = false;
      }
    }

    setVolume(volume) {
      this.currentVolume = Math.max(0, Math.min(1, volume));
      if (this.masterBus) {
        this.masterBus.gain.value = this.currentVolume;
      }
    }

    applyEffect(effectName, input) {
      const effect = this.effects.get(effectName);
      if (effect) {
        input.connect(effect);
        return effect;
      }
      return input;
    }

    chordToNotes(chord) {
      const noteFrequencies = {
        'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
        'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
        'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
      };

      const chordNotes = {
        'major': [0, 4, 7],
        'minor': [0, 3, 7],
        'dim': [0, 3, 6],
        'aug': [0, 4, 8],
        'sus2': [0, 2, 7],
        'sus4': [0, 5, 7],
        '7': [0, 4, 7, 10],
        'm7': [0, 3, 7, 10],
        'maj7': [0, 4, 7, 11],
        'dim7': [0, 3, 6, 9]
      };

      const root = chord.match(/^[A-G]#?b?/)[0];
      const quality = chord.replace(/^[A-G]#?b?/, '') || 'major';
      
      const rootFreq = noteFrequencies[root];
      const intervals = chordNotes[quality] || chordNotes['major'];
      
      return intervals.map(interval => ({
        frequency: rootFreq * Math.pow(2, interval / 12)
      }));
    }

    startRecording() {
      this.recording = true;
      this.recordedEvents = [];
      console.log('üéôÔ∏è Aufnahme gestartet');
    }

    stopRecording() {
      this.recording = false;
      console.log('üéôÔ∏è Aufnahme gestoppt', this.recordedEvents.length, 'Events');
      return this.recordedEvents;
    }

    recordEvent(event) {
      this.recordedEvents.push(event);
    }
  }

  // Initialize Enhanced Audio System
  const enhancedAudioSystem = new EnhancedAudioSystem();
  window.EnhancedAudioSystem = EnhancedAudioSystem;
  window.enhancedAudioSystem = enhancedAudioSystem;
  </script>

  <!-- Improvements Integration -->
  <script>
  // Improvements Integration for Musical Education Program
  // Phase 5: Integration of all improvements

  class ImprovementsIntegration {
    constructor() {
      this.modules = new Map();
      this.isInitialized = false;
      this.autoSaveInterval = null;
      this.progressData = {
        sessions: 0,
        totalTime: 0,
        chordsPlayed: 0,
        featuresUsed: []
      };
    }

    async init() {
      try {
        await this.loadModules();
        this.initializeModules();
        this.integrateWithMainApp();
        this.isInitialized = true;
        console.log('‚úÖ Improvements Integration initialisiert');
      } catch (error) {
        console.error('‚ùå Fehler beim Initialisieren der Integration:', error);
      }
    }

    async loadModules() {
      // Load all improvement modules
      this.modules.set('performance', window.performanceManager);
      this.modules.set('audio', window.enhancedAudioSystem);
      
      console.log('üì¶ Module geladen:', Array.from(this.modules.keys()));
    }

    initializeModules() {
      // Initialize each module
      this.modules.forEach((module, name) => {
        if (module && typeof module.init === 'function') {
          module.init();
        }
      });
    }

    integrateWithMainApp() {
      // Enhance the main compute function with performance optimizations
      this.enhanceComputeFunction();
      
      // Enhance audio playback with new audio system
      this.enhanceAudioPlayback();
      
      // Add auto-save functionality
      this.addAutoSave();
      
      // Add keyboard shortcuts
      this.addKeyboardShortcuts();
      
      // Add progress tracking
      this.addProgressTracking();
      
      // Add analytics
      this.addAnalytics();
      
      // Setup event listeners
      this.setupEventListeners();
    }

    enhanceComputeFunction() {
      // Store original compute function
      const originalCompute = window.compute;
      
      // Enhanced compute function with performance optimizations
      window.compute = async function() {
        try {
          console.log('üé∏ Erweiterte compute() Funktion aufgerufen');
          
          // Use performance manager for optimized chord processing
          if (window.performanceManager) {
            const input = inp.value.trim();
            if (input) {
              const chords = input.split(/[\s|]+/).filter(Boolean).map(s => s.trim());
              const optimizedChords = await window.performanceManager.processChordsOptimized(chords);
              console.log('üéµ Akkorde optimiert verarbeitet:', optimizedChords.length);
            }
          }
          
          // Call original compute function
          console.log('üé∏ Rufe urspr√ºngliche compute() Funktion auf');
          return originalCompute.apply(this, arguments);
        } catch (error) {
          console.error('‚ùå Fehler in erweiterter compute Funktion:', error);
          console.log('üé∏ Fallback zur urspr√ºnglichen compute() Funktion');
          return originalCompute.apply(this, arguments);
        }
      };
      
      console.log('‚úÖ Compute Funktion erweitert');
    }

    enhanceAudioPlayback() {
      // Override existing audio playback functions
      const originalPlayChord = window.playChord;
      if (originalPlayChord) {
        window.playChord = function(chord, instrument = 'guitar') {
          if (window.enhancedAudioSystem && window.enhancedAudioSystem.isInitialized) {
            // Use enhanced audio system
            window.enhancedAudioSystem.playChord(chord, instrument, 'acoustic');
          } else {
            // Fallback to original
            originalPlayChord.apply(this, arguments);
          }
        };
      }
      
      console.log('‚úÖ Audio Wiedergabe erweitert');
    }

    addAutoSave() {
      this.autoSaveInterval = setInterval(() => {
        const currentData = this.getCurrentProjectData();
        if (currentData) {
          this.saveLocalData();
          console.log('üíæ Auto-Save durchgef√ºhrt');
        }
      }, 30000); // Every 30 seconds
    }

    addKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + S: Save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          this.saveLocalData();
          console.log('üíæ Speichern √ºber Tastenk√ºrzel');
        }
        
        // Ctrl/Cmd + O: Open
        if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
          e.preventDefault();
          this.loadLocalData();
          console.log('üìÇ √ñffnen √ºber Tastenk√ºrzel');
        }
        
        // Space: Play/Stop
        if (e.key === ' ' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
          // Toggle playback
          console.log('‚ñ∂Ô∏è Wiedergabe √ºber Tastenk√ºrzel');
        }
        
        // F1: Help
        if (e.key === 'F1') {
          e.preventDefault();
          this.showQuickHelp();
        }
      });
    }

    addProgressTracking() {
      // Track user progress
      const startTime = Date.now();
      
      // Track chord plays
      document.addEventListener('click', (e) => {
        if (e.target.textContent.includes('‚ñ∂') || e.target.textContent.includes('Play')) {
          this.progressData.chordsPlayed++;
          this.saveProgress(this.progressData);
        }
      });
      
      // Track session time
      window.addEventListener('beforeunload', () => {
        const sessionTime = Date.now() - startTime;
        this.progressData.totalTime += sessionTime;
        this.progressData.sessions++;
        this.saveProgress(this.progressData);
      });
    }

    saveProgress(progress) {
      try {
        localStorage.setItem('musical-education-progress', JSON.stringify(progress));
      } catch (error) {
        console.error('‚ùå Fehler beim Speichern des Fortschritts:', error);
      }
    }

    addAnalytics() {
      // Track page views
      this.trackPageView();
      
      // Track feature usage
      document.addEventListener('click', (e) => {
        const feature = this.identifyFeature(e.target);
        if (feature) {
          this.trackFeatureUsage(feature);
        }
      });
    }

    trackPageView() {
      const analytics = {
        pageView: window.location.href,
        timestamp: Date.now(),
        userAgent: navigator.userAgent
      };
      this.saveAnalytics(analytics);
    }

    trackFeatureUsage(feature) {
      const analytics = {
        feature: feature,
        timestamp: Date.now(),
        action: 'click'
      };
      this.saveAnalytics(analytics);
    }

    identifyFeature(element) {
      const text = element.textContent || '';
      const classes = element.className || '';
      
      if (text.includes('Akkord') || classes.includes('chord')) return 'chord_processing';
      if (text.includes('Play') || text.includes('‚ñ∂')) return 'audio_playback';
      if (text.includes('Transpon') || text.includes('Key')) return 'transposition';
      if (text.includes('Diagram') || text.includes('Griff')) return 'chord_diagrams';
      
      return null;
    }

    saveAnalytics(analytics) {
      try {
        const existing = JSON.parse(localStorage.getItem('musical-education-analytics') || '[]');
        existing.push(analytics);
        localStorage.setItem('musical-education-analytics', JSON.stringify(existing));
      } catch (error) {
        console.error('‚ùå Fehler beim Speichern der Analytics:', error);
      }
    }

    setupEventListeners() {
      // Listen for performance updates
      document.addEventListener('performance:update', (event) => {
        console.log('üìä Performance Update:', event.detail);
      });
      
      // Listen for audio events
      document.addEventListener('audio:playback', (event) => {
        console.log('üéµ Audio playback:', event.detail);
      });
    }

    getModule(name) {
      return this.modules.get(name);
    }

    getAllModules() {
      return Array.from(this.modules.keys());
    }

    isModuleLoaded(name) {
      return this.modules.has(name) && this.modules.get(name) !== null;
    }

    getPerformanceMetrics() {
      const metrics = {};
      this.modules.forEach((module, name) => {
        if (module && typeof module.getMetrics === 'function') {
          metrics[name] = module.getMetrics();
        }
      });
      return metrics;
    }

    exportAllData() {
      return {
        progress: this.progressData,
        analytics: JSON.parse(localStorage.getItem('musical-education-analytics') || '[]'),
        modules: this.getAllModules()
      };
    }

    resetAllData() {
      localStorage.removeItem('musical-education-progress');
      localStorage.removeItem('musical-education-analytics');
      this.progressData = {
        sessions: 0,
        totalTime: 0,
        chordsPlayed: 0,
        featuresUsed: []
      };
    }

    getCurrentProjectData() {
      try {
        const input = document.getElementById('inp');
        const orig = document.getElementById('orig');
        const target = document.getElementById('target');
        
        if (input && orig && target) {
          return {
            input: input.value,
            originalKey: orig.value,
            targetKey: target.value,
            timestamp: Date.now()
          };
        }
      } catch (error) {
        console.error('‚ùå Fehler beim Abrufen der Projektdaten:', error);
      }
      return null;
    }

    setCurrentProjectData(data) {
      try {
        const input = document.getElementById('inp');
        const orig = document.getElementById('orig');
        const target = document.getElementById('target');
        
        if (input && data.input) input.value = data.input;
        if (orig && data.originalKey) orig.value = data.originalKey;
        if (target && data.targetKey) target.value = data.targetKey;
        
        // Trigger compute if input changed
        if (input && data.input && input.value !== data.input) {
          if (typeof window.compute === 'function') {
            window.compute();
          }
        }
      } catch (error) {
        console.error('‚ùå Fehler beim Setzen der Projektdaten:', error);
      }
    }

    saveLocalData() {
      const data = this.getCurrentProjectData();
      if (data) {
        try {
          localStorage.setItem('musical-education-project', JSON.stringify(data));
        } catch (error) {
          console.error('‚ùå Fehler beim Speichern:', error);
        }
      }
    }

    loadLocalData() {
      try {
        const saved = localStorage.getItem('musical-education-project');
        if (saved) {
          const data = JSON.parse(saved);
          this.setCurrentProjectData(data);
          console.log('üìÇ Projekt geladen');
        }
      } catch (error) {
        console.error('‚ùå Fehler beim Laden:', error);
      }
    }

    showQuickHelp() {
      const helpText = `
üéµ Schnellhilfe - Musical Education Program

Tastenk√ºrzel:
‚Ä¢ Ctrl/Cmd + S: Speichern
‚Ä¢ Ctrl/Cmd + O: √ñffnen
‚Ä¢ Leertaste: Wiedergabe
‚Ä¢ F1: Diese Hilfe

Audio-System:
‚Ä¢ Hochwertige Instrumente verf√ºgbar
‚Ä¢ Verschiedene Effekte (Reverb, Delay, etc.)
‚Ä¢ Metronom mit Tempo-Kontrolle

Performance:
‚Ä¢ Optimierte Akkord-Verarbeitung
‚Ä¢ Web Workers f√ºr bessere Performance
‚Ä¢ Auto-Save alle 30 Sekunden

Module: ${this.getAllModules().join(', ')}
      `;
      
      alert(helpText);
    }
  }

  // Initialize Improvements Integration
  const improvementsIntegration = new ImprovementsIntegration();
  
  // Add integration panel to UI
  document.addEventListener('DOMContentLoaded', () => {
    const helpButton = document.createElement('button');
    helpButton.textContent = 'üîß Integration';
    helpButton.className = 'btn sec';
    helpButton.style.position = 'fixed';
    helpButton.style.top = '10px';
    helpButton.style.right = '10px';
    helpButton.style.zIndex = '1000';
    helpButton.onclick = () => improvementsIntegration.showIntegrationPanel();
    
    document.body.appendChild(helpButton);
  });

  // Add integration panel method
  ImprovementsIntegration.prototype.showIntegrationPanel = function() {
    const panel = document.createElement('div');
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #007acc;
      border-radius: 12px;
      padding: 20px;
      z-index: 1001;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    `;
    
    const modules = this.getAllModules();
    const metrics = this.getPerformanceMetrics();
    
    panel.innerHTML = `
      <h3>üîß Integration Panel</h3>
      <p><strong>Geladene Module:</strong> ${modules.join(', ')}</p>
      <p><strong>Status:</strong> ${this.isInitialized ? '‚úÖ Initialisiert' : '‚ùå Nicht initialisiert'}</p>
      <hr>
      <button onclick="improvementsIntegration.saveLocalData()" class="btn">üíæ Speichern</button>
      <button onclick="improvementsIntegration.loadLocalData()" class="btn">üìÇ Laden</button>
      <button onclick="improvementsIntegration.showQuickHelp()" class="btn">‚ùì Hilfe</button>
      <button onclick="this.parentElement.remove()" class="btn sec">‚úñÔ∏è Schlie√üen</button>
    `;
    
    document.body.appendChild(panel);
  };

  window.ImprovementsIntegration = ImprovementsIntegration;
  window.improvementsIntegration = improvementsIntegration;
  
  // 5-Linien-Notensystem implementieren
  let notationSystem = {
    isActive: false,
    staff: null,
    notes: []
  };
  
  function toggleNotation() {
    notationSystem.isActive = !notationSystem.isActive;
    
    if (notationSystem.isActive) {
      showNotification('üéº Notensystem aktiviert', '5-Linien-Stab ist jetzt verf√ºgbar', 'success');
      createNotationSystem();
    } else {
      showNotification('üìù Notensystem deaktiviert', 'Standard-Ansicht wiederhergestellt', 'info');
      removeNotationSystem();
    }
  }
  
  function createNotationSystem() {
    // Notensystem-Container erstellen
    const notationContainer = document.createElement('div');
    notationContainer.id = 'notation-system';
    notationContainer.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      width: 400px;
      height: 200px;
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
    `;
    
    // 5-Linien-Stab SVG erstellen
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '120');
    svg.setAttribute('viewBox', '0 0 360 120');
    
    // 5 Linien zeichnen
    for (let i = 0; i < 5; i++) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', '20');
      line.setAttribute('y1', 30 + (i * 15));
      line.setAttribute('x2', '340');
      line.setAttribute('y2', 30 + (i * 15));
      line.setAttribute('stroke', '#000');
      line.setAttribute('stroke-width', '2');
      svg.appendChild(line);
    }
    
    // Violinschl√ºssel hinzuf√ºgen
    const clef = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    clef.setAttribute('x', '30');
    clef.setAttribute('y', '70');
    clef.setAttribute('font-family', 'serif');
    clef.setAttribute('font-size', '40');
    clef.setAttribute('fill', '#000');
    clef.textContent = 'ùÑû';
    svg.appendChild(clef);
    
    notationContainer.appendChild(svg);
    
    // Steuerung hinzuf√ºgen
    const controls = document.createElement('div');
    controls.style.cssText = 'margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;';
    controls.innerHTML = `
      <button onclick="addNoteToStaff('C')" class="btn" style="font-size: 12px;">C</button>
      <button onclick="addNoteToStaff('D')" class="btn" style="font-size: 12px;">D</button>
      <button onclick="addNoteToStaff('E')" class="btn" style="font-size: 12px;">E</button>
      <button onclick="addNoteToStaff('F')" class="btn" style="font-size: 12px;">F</button>
      <button onclick="addNoteToStaff('G')" class="btn" style="font-size: 12px;">G</button>
      <button onclick="addNoteToStaff('A')" class="btn" style="font-size: 12px;">A</button>
      <button onclick="addNoteToStaff('B')" class="btn" style="font-size: 12px;">B</button>
      <button onclick="clearStaff()" class="btn sec" style="font-size: 12px;">üóëÔ∏è L√∂schen</button>
    `;
    
    notationContainer.appendChild(controls);
    
    // Schlie√üen-Button
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '‚ùå';
    closeBtn.style.cssText = 'position: absolute; top: 5px; right: 5px; background: none; border: none; font-size: 16px; cursor: pointer;';
    closeBtn.onclick = () => toggleNotation();
    notationContainer.appendChild(closeBtn);
    
    document.body.appendChild(notationContainer);
    notationSystem.staff = svg;
  }
  
  function addNoteToStaff(note) {
    if (!notationSystem.staff) return;
    
    // Note-Position berechnen (vereinfacht)
    const notePositions = {
      'C': 105, 'D': 90, 'E': 75, 'F': 60, 'G': 45, 'A': 30, 'B': 15
    };
    
    const y = notePositions[note] || 60;
    const x = 120 + (notationSystem.notes.length * 25);
    
    // Note als Kreis zeichnen
    const noteCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    noteCircle.setAttribute('cx', x);
    noteCircle.setAttribute('cy', y);
    noteCircle.setAttribute('r', '8');
    noteCircle.setAttribute('fill', '#000');
    noteCircle.setAttribute('class', 'staff-note');
    noteCircle.setAttribute('data-note', note);
    
    notationSystem.staff.appendChild(noteCircle);
    notationSystem.notes.push({ note, x, y });
    
    showNotification('üéµ Note hinzugef√ºgt', `Note ${note} zum Notensystem hinzugef√ºgt`, 'success');
  }
  
  function clearStaff() {
    if (!notationSystem.staff) return;
    
    const notes = notationSystem.staff.querySelectorAll('.staff-note');
    notes.forEach(note => note.remove());
    notationSystem.notes = [];
    
    showNotification('üóëÔ∏è Notensystem geleert', 'Alle Noten wurden entfernt', 'info');
  }
  
  function removeNotationSystem() {
    const container = document.getElementById('notation-system');
    if (container) {
      container.remove();
    }
    notationSystem.staff = null;
    notationSystem.notes = [];
  }
  
  // Notensystem-Funktionen global verf√ºgbar machen
  window.toggleNotation = toggleNotation;
  window.addNoteToStaff = addNoteToStaff;
  window.clearStaff = clearStaff;

  // Initialize all improvements when DOM is loaded
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('üöÄ Initialisiere Musical Education Program Verbesserungen...');
    
    // Initialize tab navigation
    if (typeof initializeTabs === 'function') {
      initializeTabs();
      console.log('‚úÖ Tab-Navigation initialisiert');
    }
    
    // Initialize improvements integration
    if (window.improvementsIntegration) {
      await window.improvementsIntegration.init();
    }
    
    // Initialize performance manager
    if (window.performanceManager) {
      window.performanceManager.initWorkers();
    }
    
    // Initialize enhanced audio system
    if (window.enhancedAudioSystem) {
      await window.enhancedAudioSystem.init();
    }
    
    console.log('‚úÖ Alle Verbesserungen initialisiert');
  });
  </script>

  <script>
  (function(){
    function qs(id){ return document.getElementById(id); }
    const toggle = qs('toggleHero');
    const hero = qs('heroOut');
    const btnMega = qs('btnMega');
    const overlay = qs('overlay');
    const overlayText = qs('overlayText');
    const megaOut = qs('megaOut');
    const btnClose = qs('btnClose');
    
    if (toggle && hero) {
      toggle.addEventListener('change', () => {
        hero.style.display = toggle.checked ? '' : 'none';
      });
    }
    
    if (btnMega && overlay && overlayText && megaOut && btnClose) {
      btnMega.addEventListener('click', () => {
        overlay.classList.add('active');
        overlayText.textContent = megaOut.textContent || '';
        
        // Mitspiel-Animation im Vollbild-Header starten
        startFullscreenPlaybackAnimation();
        
        // Fokus auf Close-Button setzen
        btnClose.focus();
      });
      
      btnClose.addEventListener('click', () => {
        overlay.classList.remove('active');
        
        // Mitspiel-Animation im Vollbild-Header stoppen
        stopFullscreenPlaybackAnimation();
        
        // Fokus zur√ºck zum Mega-Button
        btnMega.focus();
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.classList.remove('active');
          // Fokus zur√ºck zum Mega-Button
          btnMega.focus();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          overlay.classList.remove('active');
          // Fokus zur√ºck zum Mega-Button
          btnMega.focus();
        }
      });
    }
  })();
  </script>
  <!-- Fretboard-Implantat Script -->
  <script>
  (()=>{ 'use strict';
  // Minimalistischer, eigenst√§ndiger Fretboard-Editor als "Implantat" (eine Datei, kein Build, keine Dependencies)
  // Features: Klick zum Setzen/Entfernen, Drag zum Verschieben, Doppelklick/Right-Click/Ctrl zum L√∂schen, JSON-Export.

  if (!window.Fretboard) window.Fretboard = {};
  const STYLE_ID = 'fretboard-implant-style';
  function injectStyles(){
    if (document.getElementById(STYLE_ID)) return;
    const css = `
    .fb-wrap{display:inline-block;position:relative;user-select:none;touch-action:none;border-radius:14px;overflow:hidden;background:#fff}
    .fb-svg{width:100%;height:auto;display:block}
    .fb-grid{stroke:#6b7280;stroke-width:0.015}
    .fb-grid.fret{stroke:#d1d5db}
    .fb-nut{stroke:#374151;stroke-width:0.05}
    .fb-dot{fill:#111;opacity:.95;cursor:grab;filter: drop-shadow(0 .5px 1px rgba(0,0,0,.25))}
    .fb-dot:active{cursor:grabbing}
    .fb-hot{fill:transparent}
    .fb-badge{position:absolute;top:6px;right:8px;background:#0000000d;border:1px solid #0000001a;border-radius:999px;padding:2px 8px;font-size:12px}
    `;
    const style=document.createElement('style'); style.id=STYLE_ID; style.textContent=css; document.head.appendChild(style);
  }

  function build(el){
    const strings = +el.dataset.strings || 6;   // Anzahl Saiten
    const frets   = +el.dataset.frets   || 5;   // Anzahl B√ºnde (ohne Nullbund)
    const title   = el.dataset.title || '';
    const widthPx = +el.dataset.width || parseFloat(getComputedStyle(el).width) || 300;
    el.classList.add('fb-wrap'); if (!el.style.width) el.style.width = widthPx + 'px';

    // Virtuelle Koordinaten (viewBox), damit alles sch√∂n skaliert
    const vbw = strings - 1;   // Strings sind vertikale Linien 0..strings-1
    const vbh = frets;         // Frets sind horizontale Linien 0..frets
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('viewBox', `0 0 ${vbw} ${vbh}`);
    svg.classList.add('fb-svg');

    // Saiten (vertikal)
    for(let s=0; s<strings; s++){
      const x = s * (vbw/(strings-1));
      const l = document.createElementNS(svgNS,'line');
      l.setAttribute('x1', x); l.setAttribute('y1', 0);
      l.setAttribute('x2', x); l.setAttribute('y2', vbh);
      l.setAttribute('class','fb-grid string');
      svg.appendChild(l);
    }
    // B√ºnde (horizontal)
    for(let f=0; f<=frets; f++){
      const y = f * (vbh/frets);
      const l = document.createElementNS(svgNS,'line');
      l.setAttribute('x1', 0); l.setAttribute('y1', y);
      l.setAttribute('x2', vbw); l.setAttribute('y2', y);
      l.setAttribute('class', f===0? 'fb-nut' : 'fb-grid fret');
      svg.appendChild(l);
    }

    // Hot-Layer f√ºr Klicks/Pointer
    const hot = document.createElementNS(svgNS,'rect');
    hot.setAttribute('x', 0); hot.setAttribute('y', 0);
    hot.setAttribute('width', vbw); hot.setAttribute('height', vbh);
    hot.setAttribute('class','fb-hot');
    svg.appendChild(hot);

    el.appendChild(svg);
    if (title){ const badge=document.createElement('div'); badge.textContent=title; badge.className='fb-badge'; el.appendChild(badge); }

    const state = { strings, frets, vbw, vbh, dots: [] };
    el._fretboard = state;

    function snap(pt){ // Punkt auf Raster abbilden
      const s = Math.round(pt.x * (strings-1) / vbw); // 0..strings-1
      let f = Math.round(pt.y * frets / vbh);         // 0..frets
      if (f < 1) f = 1; if (f > frets) f = frets;     // nur 1..frets (kein 0=Leersaite hier, bewusst simpel)
      return { s, f };
    }
    function posOf(sf){ // Mittelpunkt eines Griffpunktes im Bund
      const x = sf.s * (vbw/(strings-1));
      const y = (sf.f - 0.5) * (vbh/frets);
      return { x, y };
    }
    function findDot(sf){ return state.dots.find(d => d.s===sf.s && d.f===sf.f); }

    function redraw(){
      // alte Punkte weg
      [...svg.querySelectorAll('.fb-dot')].forEach(n => n.remove());
      for(const d of state.dots){
        const c = document.createElementNS(svgNS,'circle');
        const {x,y} = posOf(d);
        c.setAttribute('cx', x); c.setAttribute('cy', y);
        c.setAttribute('r', (0.11*vbw)/strings);
        c.setAttribute('class','fb-dot');
        c.dataset.s = d.s; c.dataset.f = d.f;
        svg.appendChild(c);
      }
      emit();
    }

    function emit(){
      el.dispatchEvent(new CustomEvent('fretboard:change', { detail: { dots: state.dots.map(d => ({...d})) } }));
      const sync = el.dataset.syncInput && document.querySelector(el.dataset.syncInput);
      if (sync){ try { sync.value = JSON.stringify(state.dots); } catch(_){} }
    }
    function toggle(sf){
      const exists = findDot(sf);
      if (exists) state.dots = state.dots.filter(d => !(d.s===sf.s && d.f===sf.f));
      else state.dots = [...state.dots.filter(d => !(d.s===sf.s && d.f===sf.f)), sf];
      redraw();
    }
    function clientToSvg(e){
      const rect = svg.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width * vbw;
      const y = (e.clientY - rect.top)  / rect.height * vbh;
      return { x, y };
    }

    // Klick zum Setzen/Entfernen
    hot.addEventListener('click', (e) => {
      const pt = clientToSvg(e);
      toggle(snap(pt));
    });

    // Dragging
    let drag = null;
    svg.addEventListener('pointerdown', (e) => {
      const t = e.target;
      if (!t.classList.contains('fb-dot')) return;
      drag = { orig: { s:+t.dataset.s, f:+t.dataset.f }, circle: t };
      t.setPointerCapture(e.pointerId);
    });
    svg.addEventListener('pointermove', (e) => {
      if (!drag) return;
      const sf = snap(clientToSvg(e));
      drag.circle.setAttribute('cx', sf.s * (vbw/(strings-1)));
      drag.circle.setAttribute('cy', (sf.f - .5) * (vbh/frets));
    });
    svg.addEventListener('pointerup', (e) => {
      if (!drag) return;
      const sf = snap(clientToSvg(e));
      // Ctrl/Meta/Right‚ÄëClick => l√∂schen statt bewegen
      if (e.ctrlKey || e.metaKey || e.button === 2){
        state.dots = state.dots.filter(d => !(d.s===drag.orig.s && d.f===drag.orig.f));
      } else {
        state.dots = state.dots
          .filter(d => !(d.s===drag.orig.s && d.f===drag.orig.f))
          .filter(d => !(d.s===sf.s && d.f===sf.f))
          .concat([sf]);
      }
      try{ drag.circle.releasePointerCapture(e.pointerId); }catch(_){ }
      drag = null;
      redraw();
    });
    svg.addEventListener('dblclick', (e) => {
      if (e.target.classList.contains('fb-dot')){
        const s = +e.target.dataset.s, f = +e.target.dataset.f;
        state.dots = state.dots.filter(d => !(d.s===s && d.f===f));
        redraw();
      }
    });
    svg.addEventListener('contextmenu', (e) => e.preventDefault());

    // Vorbelegung aus data-json (optional)
    if (el.dataset.json){ try { const arr = JSON.parse(el.dataset.json); if (Array.isArray(arr)) state.dots = arr.map(x => ({ s:+x.s, f:+x.f })); } catch(_){ } }
    redraw();

    // einfache API ans Element h√§ngen
    const api = {
      get(){ return state.dots.map(d => ({...d})); },
      set(dots){ state.dots = (dots||[]).map(x => ({ s:+x.s, f:+x.f })); redraw(); },
      clear(){ state.dots = []; redraw(); }
    };
    el._fbApi = api;
    return api;
  }

  function init(root=document){
    injectStyles();
    // Sicherstellen, dass root ein g√ºltiges DOM-Element oder document ist
    if (!root || typeof root.querySelectorAll !== 'function') {
      root = document;
    }
    const els = [...root.querySelectorAll('[data-fretboard]')];
    els.forEach(el => build(el));
  }

  window.Fretboard.init = init;
  window.Fretboard.attach = (el) => build(el);

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init);
  })();
  </script>
  <script>
;(()=>{
  function __unlockAudioOnce(){
    try {
      const ctxs = [];
      if (window.enhancedAudioSystem && window.enhancedAudioSystem.audioContext) ctxs.push(window.enhancedAudioSystem.audioContext);
      if (window.audioSystem && window.audioSystem.audioContext) ctxs.push(window.audioSystem.audioContext);
      ctxs.forEach(ctx => { if (ctx && typeof ctx.resume === 'function' && ctx.state !== 'running') { ctx.resume(); } });
    } catch(e) {}
  }
  ['click','touchstart','keydown'].forEach(ev => window.addEventListener(ev, __unlockAudioOnce, { once:true, capture:true }));
})();
</script>
</body>
</html>