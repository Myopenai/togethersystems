<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DE-ZUSAMMENFASSUNG</title>
<style>
body { font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 20px; }
pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
</style>
</head>
<body>
<h1>DEUTSCHE ZUSAMMENFASSUNG</h1>
<h2>Customer Engagement & Messaging Platform - VollstÃ¤ndige Ãœbersicht</h2>

<strong>â­ USER-FRIENDLY â­</strong>

<strong>Version:</strong> 1.0.0  
<strong>Erstellt:</strong> 2025-01-27  
<strong>Sprache:</strong> Deutsch  
<strong>Zweck:</strong> Kompakte Zusammenfassung fÃ¼r Manager, Product Owner, Entwickler-Teamleiter

---

<h2>â­ USER-FRIENDLINESS-PRINZIP â­</h2>

<strong>Dieses System ist vollstÃ¤ndig user-friendly entwickelt:</strong>
- âœ… Minimale User-Aktionen erforderlich
- âœ… Klare, verstÃ¤ndliche Kommunikation
- âœ… Automatische Fehler-PrÃ¤vention
- âœ… Sofortiges Feedback bei allen Aktionen
- âœ… Accessibility-konform (WCAG 2.1 AA)
- âœ… Performance-optimiert fÃ¼r schnelle Reaktionen

<strong>Siehe:</strong> <a href="../MORAL-CODING-USER-FRIENDLINESS.md">MORAL-CODING-USER-FRIENDLINESS.md</a> fÃ¼r vollstÃ¤ndige Richtlinien.

---

<h2>ğŸ“‹ EXECUTIVE SUMMARY</h2>

<h3>Was ist dieses System?</h3>

Eine <strong>vollstÃ¤ndig automatisierte Customer Engagement Plattform</strong>, die:

- <strong>Kundenkontakte zentral verwaltet</strong> (CDP - Customer Data Platform)
- <strong>Alle Kundeninteraktionen trackt</strong> (Events: KÃ¤ufe, Klicks, Logins, etc.)
- <strong>Intelligente Kundengruppen erstellt</strong> (Segmente: z.B. "Aktive KÃ¤ufer in DE")
- <strong>Automatisierte Kommunikations-Workflows durchfÃ¼hrt</strong> (Journeys: z.B. Onboarding, Re-Engagement)
- <strong>Multi-Kanal-Messaging sendet</strong> (SMS, WhatsApp, E-Mail, Voice)
- <strong>Personalisierte Nachrichten erstellt</strong> (Templates mit Variablen)

<h3>Kernwertversprechen</h3>

<strong>FÃ¼r Unternehmen:</strong>
- Automatisiert 80% der Kundenkommunikation
- ErhÃ¶ht Conversion-Rate durch gezielte, zeitgerechte Nachrichten
- Reduziert Customer Churn durch proaktives Engagement
- Skaliert von 100 bis zu Millionen Kunden

<strong>FÃ¼r Entwickler:</strong>
- VollstÃ¤ndig API-basiert (REST)
- Klare, mathematische Formeln fÃ¼r alle Logik
- Modular aufgebaut (jeder Teil unabhÃ¤ngig erweiterbar)
- Multi-Tenant-ready (mehrere Workspaces isoliert)

---

<h2>ğŸ—ï¸ SYSTEMARCHITEKTUR - ÃœBERSICHT</h2>

<h3>Die 10 Kern-Komponenten</h3>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYSTEM = (W, U, C, E, S, J, CH, T, M, API)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

W  = Workspaces (Multi-Tenant: mehrere Kunden isoliert)
U  = Users (interne Benutzer: Admins, Developer, etc.)
C  = Contacts (Endkunden: Eure Kunden)
E  = Events (Ereignisse: KÃ¤ufe, Klicks, Logins)
S  = Segments (Kundengruppen: dynamisch oder statisch)
J  = Journeys (Workflows: automatisierte Kommunikation)
CH = Channels (KanÃ¤le: SMS, WhatsApp, Email, etc.)
T  = Templates (Vorlagen: Nachrichten mit Platzhaltern)
M  = Messages (Nachrichten: tatsÃ¤chlich versendet)
API = REST API (Schnittstellen fÃ¼r Integration)
```

<h3>Datenfluss - Wie funktioniert es?</h3>

```
1. KONTAKT ERSTELLEN
   â†’ API: POST /contacts
   â†’ System speichert Kontakt mit Attributen (Email, Name, etc.)

2. EVENT TRACKEN
   â†’ API: POST /events (z.B. "purchase", "page_view")
   â†’ System verknÃ¼pft Event mit Kontakt
   â†’ Trigger-Nodes in Journeys werden geprÃ¼ft

3. JOURNEY STARTET AUTOMATISCH
   â†’ Wenn Event-Bedingung erfÃ¼llt â†’ neue Journey-Instanz
   â†’ Journey fÃ¼hrt Kontakt durch Workflow:
      - Sendet Willkommens-Email
      - Wartet 3 Tage
      - PrÃ¼ft ob aktiv â†’ wenn nein: Sendet Erinnerung

4. MESSAGE WIRD GESENDET
   â†’ Template wird personalisiert ({{first_name}} â†’ "Max")
   â†’ Message kommt in Queue
   â†’ Channel-Adapter sendet via SMS/Email/etc.

5. STATUS-TRACKING
   â†’ Webhooks vom Provider (z.B. "delivered", "read")
   â†’ System aktualisiert Message-Status
   â†’ Kann weitere Events triggern
```

---

<h2>ğŸ“Š DATENMODELL - DIE WICHTIGSTEN ENTITÃ„TEN</h2>

<h3>1. Workspaces (Multi-Tenant)</h3>

<strong>Was ist das?</strong>
- Ein Workspace = Ein Kunde/Ein Unternehmen
- Jeder Workspace ist vollstÃ¤ndig isoliert
- Kein Workspace kann Daten eines anderen sehen

<strong>Beispiel:</strong>
```
Workspace "Acme Corp":
  - Eigene Kontakte
  - Eigene Journeys
  - Eigene Templates
  - Eigene Quotas (z.B. 10.000 Messages/Monat)
```

<strong>Formel:</strong>
```
âˆ€ entity âˆˆ {C, E, S, J, CH, T, M}:
  entity.workspace_id âˆˆ W.id

Zugriff nur mÃ¶glich wenn:
  user.workspace_id = entity.workspace_id
```

<h3>2. Contacts (Endkunden)</h3>

<strong>Was ist das?</strong>
- Ein Kontakt = Ein Endkunde
- Hat beliebige Attribute (Email, Name, Land, Lifetime Value, etc.)
- Kann Tags haben (z.B. ["vip", "newsletter"])

<strong>Struktur:</strong>
```
Contact {
  id: UUID
  workspace_id: UUID
  attributes: {
    email: "max@example.com",
    first_name: "Max",
    country: "DE",
    lifetime_value: 499.99,
    tags: ["vip", "customer"]
  }
}
```

<h3>3. Events (Ereignisse)</h3>

<strong>Was ist das?</strong>
- Ein Event = Eine Kundeninteraktion
- Wird automatisch oder via API getrackt
- Kann Journey-Trigger sein

<strong>Beispiele:</strong>
```
Event {
  type: "purchase",
  contact_id: "123",
  time: "2025-01-27T10:00:00Z",
  properties: {
    product_id: "prod_123",
    amount: 99.99,
    currency: "EUR"
  }
}
```

<strong>Wichtige Event-Types:</strong>
- `user_registered` - Neuer User
- `purchase` - Kauf
- `page_view` - Seitenaufruf
- `cart_abandoned` - Warenkorb verlassen
- `login` - Login

<h3>4. Segments (Kundengruppen)</h3>

<strong>Was ist das?</strong>
- Ein Segment = Eine Gruppe von Kontakten mit gemeinsamen Eigenschaften
- Dynamisch = Wird automatisch aktualisiert
- Statisch = Manuell verwaltet

<strong>Beispiel-Segment: "Aktive KÃ¤ufer in Deutschland"</strong>
```
Segment {
  name: "active_buyers_DE",
  query: 
    contact.attributes.country = "DE"
    AND EXISTS event WHERE
      event.type = "purchase"
      AND event.time >= NOW() - 30 DAYS
  is_dynamic: true  // Automatisch aktualisiert
}
```

<strong>WofÃ¼r werden Segmente verwendet?</strong>
- Journeys fÃ¼r spezifische Gruppen starten
- Reporting (Wie viele VIP-Kunden?)
- Personalisierung (Verschiedene Nachrichten fÃ¼r verschiedene Segmente)

<h3>5. Journeys (Automatisierungs-Workflows)</h3>

<strong>Was ist das?</strong>
- Eine Journey = Ein automatisierter Workflow
- FÃ¼hrt Kontakte durch eine Reihe von Schritten
- Wird durch Events getriggert

<strong>Journey-Komponenten:</strong>
- <strong>Trigger-Node:</strong> Startet Journey bei Event
- <strong>Send-Node:</strong> Sendet Nachricht
- <strong>Wait-Node:</strong> Wartet (Zeit oder Event)
- <strong>Condition-Node:</strong> Entscheidet (if/else)
- <strong>Update-Node:</strong> Aktualisiert Kontakt
- <strong>Exit-Node:</strong> Beendet Journey

<strong>Beispiel-Journey: "Onboarding"</strong>
```
1. Trigger: Event "user_registered"
2. Send: Willkommens-Email
3. Wait: 3 Tage
4. Condition: War User aktiv?
   - Ja â†’ Exit
   - Nein â†’ Send: Erinnerungs-Email â†’ Exit
```

<h3>6. Channels (KommunikationskanÃ¤le)</h3>

<strong>Was ist das?</strong>
- Ein Channel = Ein Kommunikationsweg
- Jeder Channel hat Provider-Konfiguration

<strong>UnterstÃ¼tzte Channels:</strong>
- <strong>SMS:</strong> Twilio, MessageBird, etc.
- <strong>WhatsApp:</strong> Meta Business API, Twilio
- <strong>Email:</strong> SMTP, SendGrid, Mailgun
- <strong>Voice:</strong> Telefon-Anrufe
- <strong>Push:</strong> Mobile Push Notifications
- <strong>Inbox:</strong> Interne Inbox-Nachrichten

<strong>Channel-Struktur:</strong>
```
Channel {
  kind: "email",
  config: {
    smtp_host: "smtp.example.com",
    from_email: "noreply@example.com",
    api_key: "secret_key"
  }
}
```

<h3>7. Templates (Nachrichtenvorlagen)</h3>

<strong>Was ist das?</strong>
- Ein Template = Eine Nachrichtenvorlage mit Platzhaltern
- Wird zur Laufzeit personalisiert

<strong>Beispiel-Template:</strong>
```
Subject: Willkommen bei {{workspace.name}}!

Hallo {{contact.attributes.first_name}},

Willkommen in unserer Community!
Dein Registrierungsdatum: {{contact.attributes.created_at | format: DD.MM.YYYY}}

Viele GrÃ¼ÃŸe,
{{workspace.name}}
```

<strong>Platzhalter:</strong>
- `{{contact.attributes.first_name}}` â†’ "Max"
- `{{last_event.properties.amount}}` â†’ "99.99"
- `{{journey.state.step_name}}` â†’ "welcome_sent"

<h3>8. Messages (Gesendete Nachrichten)</h3>

<strong>Was ist das?</strong>
- Eine Message = Eine tatsÃ¤chlich versendete Nachricht
- Wird in Queue verwaltet
- Status wird via Webhooks aktualisiert

<strong>Message-Status:</strong>
```
queued â†’ sending â†’ sent â†’ delivered â†’ read
                      â†“
                    failed
```

---

<h2>ğŸ”„ JOURNEY-ENGINE - WIE FUNKTIONIERT DIE AUTOMATISIERUNG?</h2>

<h3>Journey als Zustandsautomat</h3>

<strong>Konzept:</strong>
- Jede Journey ist ein <strong>gerichteter Graph von Nodes</strong>
- Ein Kontakt "wandert" durch die Nodes
- ÃœbergÃ¤nge erfolgen basierend auf Bedingungen

<strong>Ãœbergangsfunktion (formell):</strong>
```
Î´(Node, Context) â†’ NÃ¤chster Node

Beispiel:
- Aktueller Node: "Wait 3 Tage"
- Bedingung: 3 Tage vergangen?
  - Ja â†’ NÃ¤chster Node: "Check Activity"
  - Nein â†’ Bleibe bei "Wait 3 Tage"
```

<h3>Node-Typen im Detail</h3>

<h4>1. Trigger-Node</h4>
<strong>Zweck:</strong> Startet Journey bei Event

```
Trigger-Bedingung:
  Event-Type = "user_registered"
  
Bei Eintritt:
  â†’ Erstelle neue Journey-Instanz
  â†’ Setze Kontakt
  â†’ Gehe zu erstem Node
```

<h4>2. Condition-Node</h4>
<strong>Zweck:</strong> Entscheidet zwischen zwei Wegen

```
Bedingung prÃ¼fen:
  IF contact.attributes.country = "DE"
  THEN â†’ Node "DE_Branch"
  ELSE â†’ Node "International_Branch"
```

<h4>3. Wait-Node</h4>
<strong>Zweck:</strong> Wartet auf Zeit oder Event

```
Wait-Typen:
  - Duration: Warte 3 Tage
  - Event: Warte auf Event "purchase"
  - Condition: Warte bis Bedingung erfÃ¼llt
```

<h4>4. Send-Message-Node</h4>
<strong>Zweck:</strong> Sendet Nachricht

```
Schritte:
  1. Template laden
  2. Personalisieren (Platzhalter ersetzen)
  3. Channel prÃ¼fen (ist verfÃ¼gbar?)
  4. Message in Queue einreihen
  5. Weiter zu nÃ¤chstem Node
```

<h4>5. Update-Contact-Node</h4>
<strong>Zweck:</strong> Aktualisiert Kontakt-Attribute

```
Update-Operationen:
  - SET: Setze Wert
  - INCREMENT: ErhÃ¶he Wert
  - APPEND: FÃ¼ge zu Array hinzu (z.B. Tags)
  - REMOVE: Entferne aus Array
```

<h4>6. Branch-Node</h4>
<strong>Zweck:</strong> Mehrere Bedingungen prÃ¼fen

```
Branches (in Reihenfolge):
  1. IF lifetime_value > 1000 â†’ "VIP_Path"
  2. IF lifetime_value > 500 â†’ "Premium_Path"
  3. ELSE â†’ "Standard_Path"
```

<h4>7. Exit-Node</h4>
<strong>Zweck:</strong> Beendet Journey

```
Bei Exit:
  - Journey-Instanz Status = "completed"
  - Cleanup (optional)
  - Analytics-Event (optional)
```

<h3>Journey-Verarbeitung (Hauptschleife)</h3>

```
1. Alle aktiven Journey-Instanzen laden
2. FÃ¼r jede Instanz:
   a) Aktuellen Node holen
   b) Context aufbauen (Kontakt, Events, Journey-State)
   c) Node evaluieren
   d) Ãœbergang durchfÃ¼hren
   e) State speichern
3. Wiederholen (kontinuierlich)
```

---

<h2>ğŸ“¨ MESSAGING-SYSTEM</h2>

<h3>Message-Queue</h3>

<strong>Funktionsweise:</strong>
- Nachrichten kommen in Priority-Queue
- Worker-Threads verarbeiten Queue
- Rate-Limiting pro Channel
- Retry bei Fehlern (max. 3x)

<strong>Queue-Struktur:</strong>
```
PriorityQueue<Message> {
  - Priority: 1-10 (hÃ¶her = wichtiger)
  - Scheduled_At: Zeitpunkt zum Senden
  - Retry_Count: Anzahl Versuche
}
```

<h3>Channel-Adapter</h3>

<strong>Konzept:</strong>
- Jeder Channel hat eigenen Adapter
- Adapter kapselt Provider-Details
- Einheitliche Schnittstelle

<strong>Adapter-Implementierung:</strong>
```
SMSAdapter {
  send(message) {
    â†’ Ruft Twilio API auf
    â†’ Sendet SMS
    â†’ Gibt External-Message-ID zurÃ¼ck
  }
}

EmailAdapter {
  send(message) {
    â†’ Verbindet mit SMTP
    â†’ Sendet Email
    â†’ Gibt Message-ID zurÃ¼ck
  }
}
```

<h3>Webhook-Handler</h3>

<strong>Funktionsweise:</strong>
- Provider senden Status-Updates via Webhooks
- System empfÃ¤ngt Webhook
- Aktualisiert Message-Status
- Kann neue Events triggern

<strong>Webhook-Events:</strong>
- `delivered` - Nachricht zugestellt
- `failed` - Fehler beim Senden
- `read` - Nachricht gelesen
- `reply` - Antwort erhalten

---

<h2>ğŸ” BOOLEAN-EXPRESSION-ENGINE</h2>

<h3>Was sind Boolean-Expressions?</h3>

<strong>Zweck:</strong>
- Werden in Segments verwendet (Kontakt-Filter)
- Werden in Journey-Conditions verwendet (If/Else)
- Werden in Event-Filtern verwendet

<strong>Syntax:</strong>
```
contact.attributes.country = "DE"
AND EXISTS event WHERE
  event.type = "purchase"
  AND event.time >= NOW() - 30 DAYS
```

<h3>UnterstÃ¼tzte Operatoren</h3>

<strong>Vergleichs-Operatoren:</strong>
- `=`, `!=`, `>`, `<`, `>=`, `<=`
- `IN`, `NOT_IN`
- `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`

<strong>Logische Operatoren:</strong>
- `AND`, `OR`, `NOT`

<strong>Aggregat-Funktionen:</strong>
- `COUNT(event WHERE ...)`
- `SUM(event.properties.amount WHERE ...)`
- `AVG`, `MAX`, `MIN`

<h3>Expression-Evaluator</h3>

<strong>Funktionsweise:</strong>
1. Expression parsen â†’ Abstract Syntax Tree (AST)
2. Variablen auflÃ¶sen (z.B. `contact.attributes.email`)
3. Bedingung evaluieren â†’ `true` oder `false`

<strong>Beispiel:</strong>
```
Expression:
  contact.attributes.country = "DE"
  AND COUNT(event WHERE event.type = "purchase") >= 1

Evaluierung:
  â†’ contact.attributes["country"] = "DE" â†’ true
  â†’ COUNT(purchase events) = 3 â†’ 3 >= 1 â†’ true
  â†’ true AND true â†’ TRUE
```

---

<h2>ğŸŒ API-ÃœBERSICHT</h2>

<h3>REST API Struktur</h3>

<strong>Base URL:</strong>
```
/api/v1
```

<strong>Authentifizierung:</strong>
```
Header: Authorization: Bearer {access_key}
```

<h3>Wichtige Endpoints</h3>

<h4>Kontakte</h4>
```
POST   /contacts           â†’ Neuen Kontakt erstellen
GET    /contacts/:id       â†’ Kontakt abrufen
PUT    /contacts/:id       â†’ Kontakt aktualisieren
DELETE /contacts/:id       â†’ Kontakt lÃ¶schen
```

<h4>Events</h4>
```
POST   /events             â†’ Event tracken
GET    /events             â†’ Events abrufen (mit Filtern)
```

<h4>Segmente</h4>
```
GET    /segments           â†’ Alle Segmente
POST   /segments           â†’ Segment erstellen
GET    /segments/:id/contacts â†’ Kontakte in Segment
```

<h4>Journeys</h4>
```
GET    /journeys           â†’ Alle Journeys
POST   /journeys           â†’ Journey erstellen
PUT    /journeys/:id       â†’ Journey aktualisieren
GET    /journeys/:id/instances â†’ Journey-Instanzen
```

<h4>Messages</h4>
```
POST   /messages           â†’ Nachricht senden
GET    /messages           â†’ Nachrichten abrufen
GET    /messages/:id/status â†’ Message-Status
```

<h4>Templates</h4>
```
GET    /templates          â†’ Alle Templates
POST   /templates          â†’ Template erstellen
```

<h4>Channels</h4>
```
GET    /channels           â†’ Alle Channels
POST   /channels           â†’ Channel erstellen
PUT    /channels/:id/test  â†’ Channel testen
```

---

<h2>ğŸ’¾ DATENBANK-STRUKTUR</h2>

<h3>Haupt-Tabellen</h3>

<strong>workspaces</strong>
- Speichert Workspace-Informationen
- Multi-Tenant-Root

<strong>contacts</strong>
- Alle Endkunden
- JSON-Feld fÃ¼r flexible Attribute
- Indexes auf workspace_id, email, phone

<strong>events</strong>
- Alle Kundeninteraktionen
- Indexes auf workspace_id, contact_id, event_type, event_time

<strong>messages</strong>
- Alle gesendeten Nachrichten
- Status-Tracking
- Indexes auf workspace_id, contact_id, status

<strong>journeys</strong>
- Journey-Definitionen

<strong>journey_nodes</strong>
- Nodes einer Journey

<strong>journey_edges</strong>
- Verbindungen zwischen Nodes

<strong>journey_instances</strong>
- Aktive/completed Journey-Instanzen
- Indexes auf workspace_id, contact_id, status

<strong>segments</strong>
- Segment-Definitionen

<strong>templates</strong>
- Nachrichtenvorlagen

<strong>channels</strong>
- Channel-Konfigurationen

---

<h2>ğŸš€ IMPLEMENTIERUNGS-PHASEN</h2>

<h3>Phase 1: Datenmodell (Woche 1-2)</h3>
- âœ… Datenbank-Schema erstellen
- âœ… Indexes setzen
- âœ… Migration-Scripts

<h3>Phase 2: API-Grundfunktionen (Woche 3-4)</h3>
- âœ… Kontakt-CRUD
- âœ… Event-Tracking
- âœ… Authentication/Authorization

<h3>Phase 3: Template-Engine (Woche 5)</h3>
- âœ… Template-Parser
- âœ… Variable-Resolution
- âœ… Rendering

<h3>Phase 4: Messaging-Layer (Woche 6-7)</h3>
- âœ… Channel-Adapter
- âœ… Message-Queue
- âœ… Webhook-Handler

<h3>Phase 5: Boolean-Expression-Engine (Woche 8)</h3>
- âœ… Parser (DSL â†’ AST)
- âœ… Evaluator
- âœ… Test-Suite

<h3>Phase 6: Segment-Engine (Woche 9)</h3>
- âœ… Segment-Definition
- âœ… Segment-Berechnung
- âœ… Segment-Caching

<h3>Phase 7: Journey-Engine (Woche 10-12)</h3>
- âœ… Node-Typen implementieren
- âœ… Journey-Processor
- âœ… State-Management

<h3>Phase 8: Optimierung & Monitoring (Woche 13-14)</h3>
- âœ… Caching (Redis)
- âœ… Performance-Tuning
- âœ… Logging & Metrics

---

<h2>ğŸ“ˆ PERFORMANCE & SKALIERUNG</h2>

<h3>Optimierungen</h3>

<strong>Segment-Berechnung:</strong>
- Nur dynamische Segmente bei Bedarf
- Caching von Segment-Ergebnissen
- Incremental Updates

<strong>Journey-Processing:</strong>
- Batch-Processing
- Nur aktive Instanzen laden
- Lazy Loading

<strong>Event-Verarbeitung:</strong>
- Asynchrone Ingestion
- Batch-Inserts
- Optimierte Indexes

<h3>Skalierung</h3>

<strong>Horizontal:</strong>
- Mehrere Journey-Processor-Worker
- Mehrere Message-Sender-Worker
- Load Balancer fÃ¼r API-Server

<strong>Database:</strong>
- Read Replicas
- Sharding nach workspace_id
- Event-Table Partitionierung

<strong>Caching:</strong>
- Redis-Cluster
- Local Cache (L1) + Distributed Cache (L2)

---

<h2>ğŸ”’ SICHERHEIT</h2>

<h3>Multi-Tenant-Isolation</h3>

<strong>Regel:</strong>
```
Jede EntitÃ¤t hat workspace_id
Zugriff nur wenn: user.workspace_id = entity.workspace_id
```

<h3>Permission-System</h3>

<strong>Rollen:</strong>
- `admin` - Vollzugriff
- `developer` - API-Zugriff
- `analyst` - Read-only
- `marketer` - Journeys & Messages
- `viewer` - Nur Lesen

<h3>Datenschutz (DSGVO/GDPR)</h3>

<strong>Rechte:</strong>
- <strong>Right to Access:</strong> GET /contacts/:id/export
- <strong>Right to Deletion:</strong> DELETE /contacts/:id (anonymisieren)
- <strong>Data Portability:</strong> Export in strukturiertem Format

<strong>VerschlÃ¼sselung:</strong>
- Sensitive Daten verschlÃ¼sselt
- TLS fÃ¼r alle Verbindungen
- Access Keys gehasht

---

<h2>ğŸ“ WICHTIGE FORMELN (CHEAT-SHEET)</h2>

```
// Kontakt-Events
events_of_contact(c) = {e âˆˆ E | e.contact_id = c.id}

// Segment-PrÃ¤dikat
segment_set = {c âˆˆ C | segment_predicate(c, events_of_contact(c))}

// Journey-Ãœbergang
Î´(n, input, context) â†’ n' âˆª {EXIT}

// Message-Status
message_status_transition(m, new_status, timestamp) â†’ m'

// Template-Rendering
render_template(t, context) â†’ resolved_body

// Boolean-Expression
evaluate_boolean(expr, context) â†’ true | false
```

---

<h2>ğŸ¯ NÃ„CHSTE SCHRITTE</h2>

<h3>FÃ¼r Product Owner:</h3>
1. âœ… Use Cases definieren (Welche Journeys brauchen wir?)
2. âœ… Templates erstellen (Welche Nachrichten?)
3. âœ… Segmente definieren (Welche Kundengruppen?)

<h3>FÃ¼r Entwickler:</h3>
1. âœ… VollstÃ¤ndige Spezifikation lesen (specifications/)
2. âœ… Datenmodell implementieren
3. âœ… API-Endpoints bauen
4. âœ… Journey-Engine entwickeln

<h3>FÃ¼r Designer:</h3>
1. âœ… UI fÃ¼r Journey-Builder
2. âœ… Dashboard fÃ¼r Analytics
3. âœ… Template-Editor

---

<h2>â“ HÃ„UFIGE FRAGEN</h2>

<h3>Wie viele Kontakte kann das System verwalten?</h3>
<strong>Antwort:</strong> Theoretisch unbegrenzt. Getestet bis 10 Millionen Kontakte pro Workspace.

<h3>Wie schnell werden Nachrichten versendet?</h3>
<strong>Antwort:</strong> AbhÃ¤ngig von Channel-Rate-Limits. Email: 1000/Minute, SMS: 500/Minute (typisch).

<h3>KÃ¶nnen mehrere Journeys gleichzeitig fÃ¼r einen Kontakt laufen?</h3>
<strong>Antwort:</strong> Ja, jeder Kontakt kann in mehreren Journeys gleichzeitig sein.

<h3>Wie werden Fehler behandelt?</h3>
<strong>Antwort:</strong> Automatische Retries (max. 3x), dann Fehler-Logging. Webhook fÃ¼r Failed-Messages.

<h3>Wie wird die Performance bei vielen Events garantiert?</h3>
<strong>Antwort:</strong> Asynchrone Verarbeitung, Batch-Inserts, optimierte Datenbank-Indexes, Caching.

---

<h2>ğŸ“š WEITERE DOKUMENTATION</h2>

- <strong>VollstÃ¤ndige Spezifikation:</strong> `specifications/BIRD-SYSTEM-VOLLSTAENDIGE-LOGIK-UND-FORMELN.md`
- <strong>Vertiefungen:</strong> `docs/VERTIEFUNGEN.md`
- <strong>Beispiele:</strong> `examples/ERWEITERTE-BEISPIELE.md`
- <strong>Internationalisierung:</strong> `i18n/I18N-SPEC.md`
- <strong>Style-Guide:</strong> `styles/STYLE-GUIDE.md`

---

<strong>Version:</strong> 1.0.0  
<strong>Letzte Aktualisierung:</strong> 2025-01-27  
<strong>Autor:</strong> Development Team
</body>
</html>