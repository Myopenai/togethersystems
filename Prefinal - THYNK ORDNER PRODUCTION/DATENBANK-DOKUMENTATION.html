<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DATENBANK-DOKUMENTATION</title>
<style>
body { font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 20px; }
pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
</style>
</head>
<body>
<h1>üóÑÔ∏è THYNK ORDERS - Datenbank-Dokumentation</h1>

<strong>Zweck:</strong> Vollst√§ndige Dokumentation der Datenbank-Struktur, Schema und Migrationen  
<strong>Aktuell:</strong> localStorage | <strong>Zuk√ºnftig:</strong> IndexedDB / Server-Datenbank

---

<h2>üìã INHALTSVERZEICHNIS</h2>

1. <a href="#aktuelle-datenbank-localstorage">Aktuelle Datenbank (localStorage)</a>
2. <a href="#datenstruktur">Datenstruktur</a>
3. <a href="#schema-definition">Schema-Definition</a>
4. <a href="#migration-zu-server-datenbank">Migration zu Server-Datenbank</a>
5. <a href="#indexeddb-alternative">IndexedDB Alternative</a>
6. <a href="#datenbank-operations">Datenbank-Operations</a>

---

<h2>üíæ AKTUELLE DATENBANK (localStorage)</h2>

<h3>Storage-Keys</h3>

<strong>Primary Keys:</strong>
- `thynk_orders` - Alle Bestellungen (Array)
- `thynk_settings` - Einstellungen (Object)

<h3>Struktur</h3>

```javascript
// localStorage['thynk_orders'] = Array von Order-Objekten
// localStorage['thynk_settings'] = Settings-Object
```

---

<h2>üìä DATENSTRUKTUR</h2>

<h3>Order-Objekt (Komplett)</h3>

```javascript
{
  // Identifikation
  "id": "order-1234567890",                    // Eindeutige ID
  "order_number": "ORD-2024-01-15-ABC123",     // Bestellnummer (benutzerfreundlich)
  
  // Status
  "status": "pending",                         // pending | paid | shipped | cancelled
  "payment_status": "pending",                 // pending | paid | failed | refunded
  
  // Kunde
  "customer": {
    "name": "Max Mustermann",                  // Pflicht
    "email": "max@example.com",                // Pflicht
    "address": "Musterstra√üe 123",             // Optional
    "phone": "+49 123 456789",                 // Optional
    "company": "Firma GmbH",                   // Optional
    "vat_id": "DE123456789"                    // Optional (USt-IdNr.)
  },
  
  // Bestellpositionen
  "items": [
    {
      "id": "item-1234567890",                 // Eindeutige Item-ID
      "name": "Produkt Name",                  // Produktname
      "price": 29.99,                          // Einzelpreis
      "quantity": 1,                           // Menge
      "total": 29.99,                          // Gesamt (price * quantity)
      "sku": "PROD-001",                       // Optional: SKU
      "description": "Produktbeschreibung",    // Optional
      "tax_rate": 19.0,                        // Optional: MwSt-Satz
      "tax_amount": 4.79                       // Optional: MwSt-Betrag
    }
  ],
  
  // Finanzen
  "total_amount": 29.99,                       // Gesamtbetrag (netto)
  "tax_amount": 4.79,                          // Gesamt-MwSt
  "total_with_tax": 34.78,                     // Gesamtbetrag (brutto)
  "currency": "EUR",                           // W√§hrung
  "payment_method": "credit_card",             // Optional: Zahlungsmethode
  
  // Zeiten
  "created_at": "2024-01-15T10:30:00.000Z",   // Erstellt am
  "updated_at": "2024-01-15T10:30:00.000Z",   // Aktualisiert am
  "paid_at": null,                             // Bezahlt am (wenn status = paid)
  "shipped_at": null,                          // Versendet am (wenn status = shipped)
  "cancelled_at": null,                        // Storniert am (wenn status = cancelled)
  
  // Zus√§tzliche Daten
  "notes": "Besondere Anweisungen",            // Optional: Notizen
  "metadata": {                                 // Optional: Metadaten
    "source": "web",
    "campaign": "summer2024",
    "referrer": "google.com"
  },
  
  // Versand
  "shipping": {                                // Optional: Versandinfo
    "method": "standard",
    "cost": 5.99,
    "tracking_number": "123456789",
    "address": {
      "street": "Lieferstra√üe 456",
      "city": "Berlin",
      "postal_code": "10115",
      "country": "DE"
    }
  }
}
```

<h3>Settings-Objekt</h3>

```javascript
{
  "currency": "EUR",                           // Standard-W√§hrung
  "currencySymbol": "‚Ç¨",                       // W√§hrungssymbol
  "tax_rate": 19.0,                            // Standard-MwSt-Satz
  "language": "de",                            // Sprache
  "date_format": "DD.MM.YYYY",                 // Datumsformat
  "number_format": "de-DE",                    // Zahlenformat
  "auto_save": true,                           // Automatisches Speichern
  "notifications": {                           // Benachrichtigungen
    "email": true,
    "sound": false,
    "desktop": false
  },
  "export_format": "json",                     // json | csv | excel
  "backup_interval": 7                         // Backup alle X Tage
}
```

---

<h2>üìê SCHEMA-DEFINITION</h2>

<h3>Order-Schema (TypeScript-like)</h3>

```typescript
interface Order {
  // Pflichtfelder
  id: string;                  // Format: "order-{timestamp}"
  order_number: string;        // Format: "ORD-{YYYY}-{MM}-{DD}-{RANDOM}"
  status: OrderStatus;         // pending | paid | shipped | cancelled
  payment_status: PaymentStatus; // pending | paid | failed | refunded
  customer: Customer;
  items: OrderItem[];
  total_amount: number;        // Netto-Betrag
  currency: string;            // ISO 4217 Code
  created_at: string;          // ISO 8601 Datum
  
  // Optionale Felder
  updated_at?: string;
  paid_at?: string;
  shipped_at?: string;
  cancelled_at?: string;
  tax_amount?: number;
  total_with_tax?: number;
  payment_method?: string;
  notes?: string;
  metadata?: Record<string, any>;
  shipping?: ShippingInfo;
}

interface Customer {
  name: string;
  email: string;
  address?: string;
  phone?: string;
  company?: string;
  vat_id?: string;
}

interface OrderItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  total: number;
  sku?: string;
  description?: string;
  tax_rate?: number;
  tax_amount?: number;
}

interface ShippingInfo {
  method: string;
  cost: number;
  tracking_number?: string;
  address?: Address;
}

interface Address {
  street: string;
  city: string;
  postal_code: string;
  country: string;
}

type OrderStatus = 'pending' | 'paid' | 'shipped' | 'cancelled';
type PaymentStatus = 'pending' | 'paid' | 'failed' | 'refunded';
```

---

<h2>üîÑ MIGRATION ZU SERVER-DATENBANK</h2>

<h3>SQL-Schema (f√ºr Server-Datenbank)</h3>

```sql
-- Orders Tabelle
CREATE TABLE orders (
  id TEXT PRIMARY KEY,
  order_number TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  payment_status TEXT NOT NULL DEFAULT 'pending',
  customer_name TEXT NOT NULL,
  customer_email TEXT NOT NULL,
  customer_address TEXT,
  customer_phone TEXT,
  total_amount REAL NOT NULL,
  tax_amount REAL DEFAULT 0,
  total_with_tax REAL,
  currency TEXT NOT NULL DEFAULT 'EUR',
  payment_method TEXT,
  notes TEXT,
  metadata TEXT, -- JSON
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP,
  paid_at TIMESTAMP,
  shipped_at TIMESTAMP,
  cancelled_at TIMESTAMP
);

-- Order Items Tabelle
CREATE TABLE order_items (
  id TEXT PRIMARY KEY,
  order_id TEXT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  price REAL NOT NULL,
  quantity INTEGER NOT NULL,
  total REAL NOT NULL,
  sku TEXT,
  description TEXT,
  tax_rate REAL,
  tax_amount REAL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Shipping Tabelle
CREATE TABLE shipping (
  id TEXT PRIMARY KEY,
  order_id TEXT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  method TEXT NOT NULL,
  cost REAL NOT NULL,
  tracking_number TEXT,
  street TEXT,
  city TEXT,
  postal_code TEXT,
  country TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indizes
CREATE INDEX idx_orders_order_number ON orders(order_number);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_customer_email ON orders(customer_email);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_shipping_order_id ON shipping(order_id);
```

<h3>Migrations-Script</h3>

```javascript
async function migrateToServer(localOrders, apiUrl) {
    console.log(`Migrating ${localOrders.length} orders to server...`);
    
    const results = [];
    
    for (const order of localOrders) {
        try {
            // Order erstellen
            const orderResponse = await fetch(`${apiUrl}/orders`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    id: order.id,
                    order_number: order.order_number,
                    status: order.status,
                    payment_status: order.payment_status,
                    customer_name: order.customer.name,
                    customer_email: order.customer.email,
                    customer_address: order.customer.address,
                    customer_phone: order.customer.phone,
                    total_amount: order.total_amount,
                    tax_amount: order.tax_amount || 0,
                    total_with_tax: order.total_with_tax || order.total_amount,
                    currency: order.currency,
                    payment_method: order.payment_method,
                    notes: order.notes,
                    metadata: JSON.stringify(order.metadata || {}),
                    created_at: order.created_at
                })
            });
            
            const savedOrder = await orderResponse.json();
            
            // Items erstellen
            for (const item of order.items) {
                await fetch(`${apiUrl}/orders/${savedOrder.id}/items`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(item)
                });
            }
            
            // Shipping erstellen (falls vorhanden)
            if (order.shipping) {
                await fetch(`${apiUrl}/orders/${savedOrder.id}/shipping`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(order.shipping)
                });
            }
            
            results.push({ order: order.order_number, status: 'success' });
        } catch (error) {
            results.push({ order: order.order_number, status: 'error', error: error.message });
        }
    }
    
    return results;
}
```

---

<h2>üíø INDEXEDDB ALTERNATIVE</h2>

<h3>IndexedDB Setup</h3>

```javascript
let db;

function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('thynk_orders_db', 1);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            db = request.result;
            resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            
            // Orders Store
            if (!db.objectStoreNames.contains('orders')) {
                const ordersStore = db.createObjectStore('orders', { keyPath: 'id' });
                ordersStore.createIndex('order_number', 'order_number', { unique: true });
                ordersStore.createIndex('status', 'status', { unique: false });
                ordersStore.createIndex('customer_email', 'customer.email', { unique: false });
                ordersStore.createIndex('created_at', 'created_at', { unique: false });
            }
            
            // Items Store
            if (!db.objectStoreNames.contains('items')) {
                const itemsStore = db.createObjectStore('items', { keyPath: 'id' });
                itemsStore.createIndex('order_id', 'order_id', { unique: false });
            }
            
            // Settings Store
            if (!db.objectStoreNames.contains('settings')) {
                db.createObjectStore('settings', { keyPath: 'key' });
            }
        };
    });
}
```

<h3>IndexedDB Operations</h3>

```javascript
// Bestellung speichern
function saveOrderToIndexedDB(order) {
    const transaction = db.transaction(['orders'], 'readwrite');
    const store = transaction.objectStore('orders');
    return store.put(order);
}

// Alle Bestellungen abrufen
function getAllOrdersFromIndexedDB() {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(['orders'], 'readonly');
        const store = transaction.objectStore('orders');
        const request = store.getAll();
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

// Bestellung nach Status suchen
function getOrdersByStatus(status) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(['orders'], 'readonly');
        const store = transaction.objectStore('orders');
        const index = store.index('status');
        const request = index.getAll(status);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}
```

---

<h2>üîß DATENBANK-OPERATIONS</h2>

<h3>CRUD-Operationen</h3>

<h4>CREATE (Erstellen)</h4>

```javascript
function createOrder(orderData) {
    const order = {
        id: 'order-' + Date.now(),
        order_number: generateOrderNumber(),
        ...orderData,
        created_at: new Date().toISOString()
    };
    
    const orders = getOrders();
    orders.push(order);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(orders));
    
    return order;
}
```

<h4>READ (Lesen)</h4>

```javascript
function getOrder(orderId) {
    const orders = getOrders();
    return orders.find(o => o.id === orderId);
}

function getAllOrders() {
    return getOrders();
}

function getOrdersByStatus(status) {
    const orders = getOrders();
    return orders.filter(o => o.status === status);
}
```

<h4>UPDATE (Aktualisieren)</h4>

```javascript
function updateOrder(orderId, updates) {
    const orders = getOrders();
    const index = orders.findIndex(o => o.id === orderId);
    
    if (index !== -1) {
        orders[index] = {
            ...orders[index],
            ...updates,
            updated_at: new Date().toISOString()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(orders));
        return orders[index];
    }
    
    return null;
}
```

<h4>DELETE (L√∂schen)</h4>

```javascript
function deleteOrder(orderId) {
    const orders = getOrders().filter(o => o.id !== orderId);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(orders));
    return true;
}
```

<h3>Queries & Filter</h3>

```javascript
// Bestellungen nach Datum filtern
function getOrdersByDateRange(startDate, endDate) {
    const orders = getOrders();
    return orders.filter(order => {
        const orderDate = new Date(order.created_at);
        return orderDate >= startDate && orderDate <= endDate;
    });
}

// Bestellungen nach Kunde suchen
function getOrdersByCustomer(email) {
    const orders = getOrders();
    return orders.filter(o => o.customer.email === email);
}

// Statistiken berechnen
function calculateStatistics() {
    const orders = getOrders();
    return {
        total: orders.length,
        totalRevenue: orders.reduce((sum, o) => sum + o.total_amount, 0),
        pending: orders.filter(o => o.status === 'pending').length,
        paid: orders.filter(o => o.status === 'paid').length
    };
}
```

---

<h2>üîÑ DATENBANK-MIGRATION</h2>

<h3>Von localStorage zu IndexedDB</h3>

```javascript
async function migrateLocalStorageToIndexedDB() {
    await initIndexedDB();
    
    const localOrders = getOrders();
    const transaction = db.transaction(['orders'], 'readwrite');
    const store = transaction.objectStore('orders');
    
    for (const order of localOrders) {
        await new Promise((resolve, reject) => {
            const request = store.put(order);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }
    
    console.log(`Migrated ${localOrders.length} orders to IndexedDB`);
}
```

<h3>Von localStorage zu Server</h3>

Siehe: <a href="#migrations-script">Migrations-Script oben</a>

---

<h2>üìã CHECKLISTE</h2>

<h3>Datenbank-Design:</h3>
- [x] ‚úÖ Order-Schema definiert
- [x] ‚úÖ Customer-Schema definiert
- [x] ‚úÖ OrderItem-Schema definiert
- [x] ‚úÖ Settings-Schema definiert

<h3>Migration:</h3>
- [ ] ‚è≥ localStorage ‚Üí IndexedDB
- [ ] ‚è≥ localStorage ‚Üí Server-DB
- [ ] ‚è≥ Backup-System

---

<strong>Version:</strong> 1.0.0  
<strong>Letzte Aktualisierung:</strong> $(Get-Date -Format "yyyy-MM-dd")
</body>
</html>